This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
content/
  النحو/
    سليمان_العيوني/
      النحو_الصغير/
        ١_الكلمة/
          ١_أنواع _الكلمة/
            ١_الاسم/
              index.md
            ٢_الفعل/
              ١_الماضي/
                index.md
              ٢_المضارع/
                index.md
              ٣_الأمر/
                index.md
              index.md
            ٣_الحرف/
              index.md
          ٢_النكرة_والمعرفة/
            ١_النكرة/
              index.md
            ٢_المعرفة/
              ١_الضمير/
                ١_المتصل/
                  index.md
                ٢_المنفصل/
                  index.md
              ٢_العلم/
                index.md
              ٣_أسماء_الإشارة/
                index.md
              ٤_الأسماء_الموصولة/
                index.md
              ٥_المعرف_بـ(أل)/
                index.md
              ٦_المضاف_إلى_معرفة/
                index.md
          ٣_المعرب_والمبني/
            ١_المعرب/
              ١_الأحكام_الإعرابية/
                index.md
              ٢_خط_الإعراب/
                index.md
              ٣_علامات_الإعراب/
                index.md
            ٢_المبني/
              index.md
        ٢_الكلام/
          ١_الجملة_الفعلية/
            ١_الفاعل/
              index.md
            ٢_نائب_الفاعل/
              index.md
          ٢_الجملة_الاسمية/
            ١_المبتدأ_والخبر/
              index.md
            ٢_(كان)_وأخواتها/
              index.md
            ٣_(إن)_وأخواتها/
              index.md
            ٤_(ظننت)_وأخواتها/
              index.md
          ٣_مكملات_الجملتين/
            ١_المكملات_المنصوبات/
              ١_المفاعيل/
                ١_المفعول_به/
                  index.md
                ٢_المفعول_فيه/
                  ١_ظرف_الزمان/
                    index.md
                  ٢_ظرف_المكان/
                    index.md
                ٣_المفعول_له/
                  index.md
                ٤_المفعول_معه/
                  index.md
                ٥_المفعول_المطلق/
                  index.md
              ٢_الحال/
                index.md
              ٣_التمييز/
                index.md
              ٤_المستثنى/
                index.md
              ٥_المنادى/
                index.md
            ٢_المكملات_المجرورات/
              ١_المجرور_بحرف_جر/
                index.md
              ٢_المجرور_بالإضافة/
                index.md
            ٣_المكملات_التوابع/
              ١_النعت/
                index.md
              ٢_المعطوف/
                index.md
              ٣_التوكيد/
                index.md
              ٤_البدل/
                index.md
          ٤_إعراب_المضارع/
            ١_نصب_المضارع/
              index.md
            ٢_جزم_المضارع/
              index.md
            ٣_رفع_المضارع/
              index.md
        landing.ts
src/
  app/
    [subjectSlug]/
      [authorSlug]/
        [bookSlug]/
          [...slug]/
            page.tsx
          page.tsx
    fonts.ts
    globals.css
    layout.tsx
    not-found.tsx
    page.tsx
  components/
    common/
      markdown-renderer.tsx
      section.tsx
      theme-mode-toggle.tsx
    debug/
      index.tsx
      tree-structure.hook.ts
      tree-structure.view.tsx
    layout/
      sidebar.tsx
    ui/
      badge.tsx
      button.tsx
      collapsible.tsx
      custom-dialog.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      scroll-area.tsx
      separator.tsx
      sheet.tsx
      sidebar.tsx
      skeleton.tsx
      table.tsx
      tabs.tsx
      tooltip.tsx
    visualizations/
      renderers/
        radial/
          radial-sunburst-renderer.tsx
        spatial/
          circle-pack-renderer.tsx
          grid-layout-renderer.tsx
          nested-boxes-renderer.tsx
        tree/
          ascii-tree-renderer.tsx
          collapsible-tree-renderer.tsx
          node-link-diagram-renderer.tsx
      visualization-switcher.tsx
  config/
    env.ts
    site.ts
  constants/
    arabic-to-english-map.ts
  hooks/
    use-mobile.ts
    use-sidebar.tsx
  lib/
    content/
      core/
        content-loader.ts
        landing-page-loader.ts
        tree-builder.ts
      query/
        find-node.ts
        get-all-paths.ts
        get-breadcrumbs.ts
        get-leaf-nodes.ts
        get-node-path.ts
      utils/
        path-utils.ts
        tree-utils.ts
      api.ts
      types.ts
    styles/
      tailwind-utils.ts
    text/
      ascii-tree-generator.ts
      transliteration.ts
    output.txt
  providers/
    theme-provider.tsx
  output.txt
.gitignore
.prettierignore
.prettierrc.js
components.json
env.d.ts
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
wrangler.jsonc

================================================================
Files
================================================================

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/١_أنواع _الكلمة/١_الاسم/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/١_أنواع _الكلمة/٢_الفعل/١_الماضي/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/١_أنواع _الكلمة/٢_الفعل/٢_المضارع/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/١_أنواع _الكلمة/٢_الفعل/٣_الأمر/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/١_أنواع _الكلمة/٢_الفعل/index.md
================
---
order: 2
slug: null
title: 'الفعل'
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/١_أنواع _الكلمة/٣_الحرف/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/١_النكرة/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/٢_المعرفة/١_الضمير/١_المتصل/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/٢_المعرفة/١_الضمير/٢_المنفصل/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/٢_المعرفة/٢_العلم/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/٢_المعرفة/٣_أسماء_الإشارة/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/٢_المعرفة/٤_الأسماء_الموصولة/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/٢_المعرفة/٥_المعرف_بـ(أل)/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٢_النكرة_والمعرفة/٢_المعرفة/٦_المضاف_إلى_معرفة/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٣_المعرب_والمبني/١_المعرب/١_الأحكام_الإعرابية/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٣_المعرب_والمبني/١_المعرب/٢_خط_الإعراب/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٣_المعرب_والمبني/١_المعرب/٣_علامات_الإعراب/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/١_الكلمة/٣_المعرب_والمبني/٢_المبني/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/١_الجملة_الفعلية/١_الفاعل/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/١_الجملة_الفعلية/٢_نائب_الفاعل/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٢_الجملة_الاسمية/١_المبتدأ_والخبر/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٢_الجملة_الاسمية/٢_(كان)_وأخواتها/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٢_الجملة_الاسمية/٣_(إن)_وأخواتها/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٢_الجملة_الاسمية/٤_(ظننت)_وأخواتها/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/١_المفاعيل/١_المفعول_به/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/١_المفاعيل/٢_المفعول_فيه/١_ظرف_الزمان/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/١_المفاعيل/٢_المفعول_فيه/٢_ظرف_المكان/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/١_المفاعيل/٣_المفعول_له/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/١_المفاعيل/٤_المفعول_معه/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/١_المفاعيل/٥_المفعول_المطلق/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/٢_الحال/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/٣_التمييز/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/٤_المستثنى/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/١_المكملات_المنصوبات/٥_المنادى/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/٢_المكملات_المجرورات/١_المجرور_بحرف_جر/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/٢_المكملات_المجرورات/٢_المجرور_بالإضافة/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/٣_المكملات_التوابع/١_النعت/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/٣_المكملات_التوابع/٢_المعطوف/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/٣_المكملات_التوابع/٣_التوكيد/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٣_مكملات_الجملتين/٣_المكملات_التوابع/٤_البدل/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٤_إعراب_المضارع/١_نصب_المضارع/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٤_إعراب_المضارع/٢_جزم_المضارع/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/٢_الكلام/٤_إعراب_المضارع/٣_رفع_المضارع/index.md
================
---
excerpt: 'السلام عليكم'
---

# السلام عليكم

================
File: content/النحو/سليمان_العيوني/النحو_الصغير/landing.ts
================
import type { BookLandingConfigFunction } from "@/lib/content/types";
export const generateLandingConfig: BookLandingConfigFunction = (
  bookChapters,
) => {
  const part1Nodes = bookChapters.filter((chapter) =>
    chapter.title.includes("الكلمة"),
  );
  const part2Nodes = bookChapters.filter((chapter) =>
    chapter.title.includes("الكلام"),
  );
  return {
    sections: [
      {
        type: "text",
        title: "مقدمة الكتاب",
        content: [
          "النحو مكون من جزأين كبيرين لا ثالث لهما.",
          "فيدرس في الجزء الأول الكلمة: (أنواع الكلمة. وانقسام الاسم إلى نكرة ومعرفة. وانقسام الكلمة إلى معرب ومبني).",
          "ويدرس في الجزء الثاني الكلام: (الجملة الفعلية. الجملة الاسمية. مكملات الجملة الفعلية والاسمية. وإعراب الفعل المضارع).",
        ],
      },
      {
        type: "visualization",
        title: "الجزء الأول: الكلمة",
        nodes: part1Nodes,
      },
      {
        type: "visualization",
        title: "الجزء الثاني: الكلام",
        nodes: part2Nodes,
      },
      {
        type: "visualization",
        title: "نظرة عامة على الكتاب",
        nodes: bookChapters,
      },
    ],
  };
};

================
File: src/app/[subjectSlug]/[authorSlug]/[bookSlug]/[...slug]/page.tsx
================
import { MarkdownRenderer } from '@/components/common/markdown-renderer';
import { getContentNodeBySlugPath } from '@/lib/content/api';
import { getTreeSlugs } from '@/lib/content/query/get-all-paths';
import type { Metadata, ResolvingMetadata } from 'next';
import { notFound } from 'next/navigation';
type Props = {
  params: Promise<{ slug: string[] }>;
};
export async function generateStaticParams() {
  const slugs = await getTreeSlugs();
  return slugs.map((slugParts) => ({
    slug: slugParts,
  }));
}
export async function generateMetadata(
  { params }: Props,
  parent: ResolvingMetadata
): Promise<Metadata> {
  const resolvedParams = await params;
  const slugPath = resolvedParams.slug;
  const markdown = await getContentNodeBySlugPath(slugPath);
  if (!markdown) {
    return {
      title: 'Not Found',
      description: 'The requested documentation page could not be found.',
    };
  }
  const previousImages = (await parent).openGraph?.images || [];
  const description =
    markdown.excerpt ||
    (markdown.contentHtml
      ? markdown.contentHtml
          .replace(/<[^>]*>/g, '')
          .slice(0, 160)
          .trim() + '...'
      : '');
  const canonicalSlug = slugPath.join('/');
  return {
    title: markdown.title,
    description,
    openGraph: {
      title: markdown.title,
      description,
      type: 'article',
      url: `/learn/${canonicalSlug}`,
      images: previousImages,
    },
    twitter: {
      card: 'summary_large_image',
      title: markdown.title,
      description,
      images: previousImages,
    },
    alternates: {
      canonical: `/learn/${canonicalSlug}`,
    },
  };
}
export default async function Page({ params }: Props) {
  const resolvedParams = await params;
  const slugPath = resolvedParams.slug;
  const markdown = await getContentNodeBySlugPath(slugPath);
  if (!markdown) {
    notFound();
  }
  return (
    <article className="prose prose-slate dark:prose-invert max-w-none">
      <h1>{markdown.title}</h1>
      {markdown.contentHtml ? (
        <MarkdownRenderer content={markdown.contentHtml} />
      ) : (
        <p className="text-muted">No content available for this section.</p>
      )}
    </article>
  );
}

================
File: src/app/[subjectSlug]/[authorSlug]/[bookSlug]/page.tsx
================
import { Section } from "@/components/common/section";
import { VisualizationSwitcher } from "@/components/visualizations/visualization-switcher";
import { getContentNodeBySlugPath } from "@/lib/content/api";
import type {
  TextLandingSection,
  VisualizationLandingSection,
} from "@/lib/content/types";
import { notFound } from "next/navigation";
type PageProps = {
  params: Promise<{
    subjectSlug: string;
    authorSlug: string;
    bookSlug: string;
  }>;
};
export default async function Page({ params }: PageProps) {
  const resolvedParams = await params;
  const { subjectSlug, authorSlug, bookSlug } = resolvedParams;
  const slugPath = [subjectSlug, authorSlug, bookSlug];
  const bookNode = await getContentNodeBySlugPath(slugPath);
  if (!bookNode) {
    return notFound();
  }
  if (!bookNode.landingPageConfig) {
    return (
      <div className="mx-auto flex max-w-4xl flex-col gap-12 p-6">
        <Section>
          <Section.H level={1}>{bookNode.title}</Section.H>
          <Section.P>
            This book does not have a custom landing page configuration.
          </Section.P>
          {bookNode.children.length > 0 && (
            <div className="mt-6">
              <Section.H level={3}>Chapters:</Section.H>
              <ul>
                {bookNode.children.map((child) => (
                  <li key={child.slug}>
                    <a
                      href={`/${slugPath.join("/")}/${child.slug}`}
                      className="text-blue-600 hover:underline"
                    >
                      {child.title}
                    </a>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </Section>
      </div>
    );
  }
  const { landingPageConfig } = bookNode;
  return (
    <div className="mx-auto flex max-w-4xl flex-col gap-12 p-6">
      <Section>
        <Section.H level={1}>{bookNode.title}</Section.H>
      </Section>
      {landingPageConfig.sections.map((section, index) => (
        <Section key={`${section.type}-${index}`}>
          <Section.H level={2}>{section.title}</Section.H>
          {section.type === "text" && (
            <div>
              {(section as TextLandingSection).content.map(
                (paragraph, pIndex) => (
                  <Section.P key={pIndex}>{paragraph}</Section.P>
                ),
              )}
            </div>
          )}
          {section.type === "visualization" && (
            <VisualizationSwitcher
              nodes={(section as VisualizationLandingSection).nodes}
            />
          )}
        </Section>
      ))}
    </div>
  );
}

================
File: src/lib/content/core/landing-page-loader.ts
================
import { createRequire } from "module";
import path from "path";
import type {
  BookLandingConfigFunction,
  BookLandingPageConfig,
  SummaryNode,
} from "../types";
const require = createRequire(import.meta.url);
const CONTENT_BASE_PATH = path.join(process.cwd(), "content");
const LANDING_CONFIG_FILENAME = "landing.ts";
export async function loadBookLandingPageConfigForBuild(
  bookNodeSlugPath: string[],
  bookChapters: SummaryNode[],
): Promise<BookLandingPageConfig | null> {
  if (bookNodeSlugPath.length === 0) return null;
  const landingConfigPath = path.join(
    CONTENT_BASE_PATH,
    ...bookNodeSlugPath,
    LANDING_CONFIG_FILENAME,
  );
  try {
    const imported = require(landingConfigPath);
    const configFunction: BookLandingConfigFunction =
      typeof imported.default === "function"
        ? imported.default
        : typeof imported === "function"
          ? imported
          : null;
    if (!configFunction) {
      throw new Error(
        `Expected a default-exported function in ${landingConfigPath}`,
      );
    }
    const config = configFunction(bookChapters);
    if (!config || !Array.isArray(config.sections)) {
      throw new Error(
        `Landing config at ${landingConfigPath} returned invalid structure.`,
      );
    }
    return config;
  } catch (error: any) {
    if (error.code === "MODULE_NOT_FOUND" || error.code === "ENOENT") {
      return null;
    }
    console.error(
      `❌ Failed to load landing page config at ${landingConfigPath}:`,
      error,
    );
    return null;
  }
}

================
File: src/lib/output.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
content/
  core/
    build-summary-tree.ts
    get-content-node.ts
  query/
    find-node.ts
    get-all-paths.ts
    get-breadcrumbs.ts
    get-leaf-nodes.ts
    get-node-path.ts
  utils/
    normalize-slug.ts
    normalize-title.ts
    parse-filename-order.ts
    tree-flattener.ts
    tree-walker.ts
  types.ts
styles/
  tailwind.ts
text/
  ascii-generator.ts
  transliteration.ts

================================================================
Files
================================================================

================
File: content/core/build-summary-tree.ts
================
import fs from "fs";
import path from "path";
import type { SummaryNode } from "../types";
import { normalizeSlug } from "../utils/normalize-slug";
import { normalizeTitle } from "../utils/normalize-title";
import { parseFilenameOrder } from "../utils/parse-filename-order";
const MARKDOWN_BASE_PATH = path.join(process.cwd(), "content");
let _cache: SummaryNode[] | null = null;
async function walkDir(
  dir: string,
  parentPath: string[] = []
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(dir, { withFileTypes: true });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    const fullPath = path.join(dir, entry.name);
    const isMarkdownFile = entry.name.endsWith(".md");
    const filenameWithoutExtension = isMarkdownFile
      ? entry.name.replace(/\.md$/, "")
      : entry.name;
    const { fileOrder, rawUnprefixedFilename } = parseFilenameOrder({
      filename: filenameWithoutExtension,
    });
    if (entry.isDirectory()) {
      const children = await walkDir(fullPath, [
        ...parentPath,
        normalizeSlug(rawUnprefixedFilename),
      ]);
      items.push({
        title: normalizeTitle(rawUnprefixedFilename),
        slug: normalizeSlug(rawUnprefixedFilename),
        order: fileOrder,
        parentPath,
        children,
      });
    } else if (isMarkdownFile) {
      continue;
    }
  }
  return items.sort((a, b) => a.order - b.order);
}
export async function buildSummaryTree(): Promise<SummaryNode[]> {
  if (_cache) return _cache;
  _cache = await walkDir(MARKDOWN_BASE_PATH);
  return _cache;
}

================
File: content/core/get-content-node.ts
================
import fs from "fs/promises";
import matter from "gray-matter";
import path from "path";
import { remark } from "remark";
import html from "remark-html";
import type { ContentNode } from "../types";
import { normalizeSlug } from "../utils/normalize-slug";
import { normalizeTitle } from "../utils/normalize-title";
import { parseFilenameOrder } from "../utils/parse-filename-order";
const MARKDOWN_BASE_PATH = path.join(process.cwd(), "content");
export async function getContentNode(
  slugPath: string[]
): Promise<ContentNode | null> {
  if (slugPath.length === 0) return null;
  const normalizedSlugs = slugPath.map(normalizeSlug);
  const filename = `${normalizedSlugs.at(-1)}.md`;
  const filePath = path.join(
    MARKDOWN_BASE_PATH,
    ...normalizedSlugs.slice(0, -1),
    filename
  );
  try {
    const raw = await fs.readFile(filePath, "utf-8");
    const { data, content } = matter(raw);
    const processed = await remark().use(html).process(content);
    const slug = normalizedSlugs.at(-1)!;
    return {
      title: data.title ?? normalizeTitle(slug),
      slug,
      order: data.order ?? parseFilenameOrder({ filename: slug }).fileOrder,
      parentPath: normalizedSlugs.slice(0, -1),
      children: [],
      excerpt: data.excerpt,
      contentHtml: processed.toString(),
    };
  } catch (error) {
    return null;
  }
}

================
File: content/query/find-node.ts
================
import type { SummaryNode } from "../types";
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[]
): SummaryNode | null {
  let current: SummaryNode | undefined;
  for (const slug of slugPath) {
    current = (current?.children ?? tree).find((node) => node.slug === slug);
    if (!current) return null;
  }
  return current ?? null;
}

================
File: content/query/get-all-paths.ts
================
import { buildSummaryTree } from "../core/build-summary-tree";
import type { SummaryNode } from "../types";
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, path: string[] = []) {
    const currentPath = [...path, node.slug];
    slugs.push(currentPath);
    node.children.forEach((child) => traverse(child, currentPath));
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: content/query/get-breadcrumbs.ts
================
import type { SummaryNode } from "../types";
import { findDeepestNode } from "./find-node";
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[]
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  let current = findDeepestNode(tree, node.parentPath);
  while (current) {
    breadcrumbs.unshift({ title: current.title, slug: current.slug });
    current = findDeepestNode(tree, current.parentPath);
  }
  return breadcrumbs;
}

================
File: content/query/get-leaf-nodes.ts
================
import type { LeafNode, SummaryNode } from "../types";
export function getLeafNodes(tree: SummaryNode[]): LeafNode[] {
  const leaves: LeafNode[] = [];
  function walk(node: SummaryNode, path: string[] = []) {
    const fullPath = [...path, node.slug];
    if (node.children.length === 0) {
      leaves.push({ title: node.title, slug: fullPath.join("/") });
    } else {
      node.children.forEach((child) => walk(child, fullPath));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: content/query/get-node-path.ts
================
import { SummaryNode } from "../types";
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join("/");
}

================
File: content/utils/normalize-slug.ts
================
import { transliterate } from "@/lib/text/transliteration";
export function normalizeSlug(raw: string): string {
  const base = raw.replace(/\.md$/, "");
  const arabicOnly = base.replace(/[^\u0600-\u06FF_]/g, "");
  return transliterate({
    input: arabicOnly,
    mode: "arabic-to-latin",
  }).replace(/_+/g, "-");
}

================
File: content/utils/normalize-title.ts
================
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, "");
  return arabicOnly.replace(/_+/g, " ");
}

================
File: content/utils/parse-filename-order.ts
================
import { transliterate } from "@/lib/text/transliteration";
export function parseFilenameOrder({ filename }: { filename: string }): {
  fileOrder: number;
  rawUnprefixedFilename: string;
} {
  if (/\.[a-z0-9]+$/i.test(filename)) {
    throw new Error(
      `Filename "${filename}" must not contain a file extension.`
    );
  }
  const match = filename.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (!match) {
    throw new Error(
      `Invalid filename format: "${filename}". Expected format: <number>_<name>`
    );
  }
  const [, numericPrefix, remainder] = match;
  const fileOrder = parseInt(
    transliterate({ input: numericPrefix, mode: "arabic-to-latin" }),
    10
  );
  if (isNaN(fileOrder)) {
    throw new Error(
      `Invalid numeric prefix in filename: "${filename}". Could not parse "${numericPrefix}" to a number.`
    );
  }
  return {
    fileOrder,
    rawUnprefixedFilename: remainder,
  };
}

================
File: content/utils/tree-flattener.ts
================
import type { SummaryNode } from "../types";
import { walkTree } from "./tree-walker";
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: content/utils/tree-walker.ts
================
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  path: string[] = [],
  level: number = 0
): void {
  for (const node of nodes) {
    callback(node, path, level);
    if (node.children.length > 0) {
      walkTree(node.children, callback, [...path, node.slug], level + 1);
    }
  }
}

================
File: content/types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type ContentNode = SummaryNode & {
  excerpt?: string;
  contentHtml: string;
};
export type LeafNode = BaseNode;

================
File: styles/tailwind.ts
================
import clsx, { type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

================
File: text/ascii-generator.ts
================
import type { SummaryNode } from "../content/types";
export function generateASCIITree(
  docs: SummaryNode[],
  options: {
    indent?: string;
    splitLevel?: number;
    splitString?: string;
    currentLevel?: number;
  } = {}
): string {
  const {
    indent = "",
    splitLevel = Infinity,
    splitString = "",
    currentLevel = 0,
  } = options;
  return docs
    .map((node, index) => {
      const isLast = index === docs.length - 1;
      const branch = isLast ? "└── " : "├── ";
      const nextIndent = indent + (isLast ? "    " : "│   ");
      const label = node.title.replace(/_/g, " ");
      let output = "";
      if (currentLevel === splitLevel && label !== splitString) {
        return "";
      }
      output += `${indent}${branch}${label}\n`;
      if (node.children.length > 0) {
        output += generateASCIITree(node.children, {
          indent: nextIndent,
          splitLevel,
          splitString,
          currentLevel: currentLevel + 1,
        });
      }
      return output;
    })
    .join("");
}

================
File: text/transliteration.ts
================
type ArabicToLatinOptions = {
  mode: "arabic-to-latin";
  input: string;
};
type LatinToArabicDigitsOptions = {
  mode: "latin-to-arabic-digits";
  input: string;
};
type LatinNumbersToArabicDigitsOptions = {
  mode: "latin-numbers-to-arabic-digits";
  input: string | number;
};
type LatinToArabicOptions = {
  mode: "latin-to-arabic";
  input: string;
};
type Options =
  | ArabicToLatinOptions
  | LatinToArabicDigitsOptions
  | LatinNumbersToArabicDigitsOptions
  | LatinToArabicOptions;
const LATIN_TO_ARABIC_DIGITS: Record<string, string> = {
  "0": "٠",
  "1": "١",
  "2": "٢",
  "3": "٣",
  "4": "٤",
  "5": "٥",
  "6": "٦",
  "7": "٧",
  "8": "٨",
  "9": "٩",
};
const ARABIC_TO_LATIN_DIGITS: Record<string, string> = Object.fromEntries(
  Object.entries(LATIN_TO_ARABIC_DIGITS).map(([w, a]) => [a, w])
);
const digitSet = new Set(Object.keys(LATIN_TO_ARABIC_DIGITS));
const ARABIC_TO_LATIN_LETTERS: Record<string, string> = {
  ا: "a",
  ب: "b",
  ت: "t",
  ث: "th",
  ج: "j",
  ح: "h",
  خ: "kh",
  د: "d",
  ذ: "dh",
  ر: "r",
  ز: "z",
  س: "s",
  ش: "sh",
  ص: "s",
  ض: "d",
  ط: "t",
  ظ: "z",
  ع: "a",
  غ: "gh",
  ف: "f",
  ق: "q",
  ك: "k",
  ل: "l",
  م: "m",
  ن: "n",
  ه: "h",
  و: "w",
  ي: "y",
  ء: "",
  ى: "a",
  ئ: "y",
  ؤ: "w",
  ة: "h",
  إ: "i",
  أ: "a",
  آ: "aa",
  "ٓ": "",
  "َ": "a",
  "ُ": "u",
  "ِ": "i",
  "ّ": "",
  "ْ": "",
  "ً": "an",
  "ٌ": "un",
  "ٍ": "in",
};
const ARABIC_TO_LATIN_MAP = {
  ...ARABIC_TO_LATIN_LETTERS,
  ...ARABIC_TO_LATIN_DIGITS,
};
const LATIN_TO_ARABIC_LETTERS: Record<string, string> = Object.fromEntries(
  Object.entries(ARABIC_TO_LATIN_LETTERS)
    .filter(([_arb, lat]) => lat.length > 0)
    .map(([arb, lat]) => [lat, arb])
);
const LATIN_LETTER_KEYS = Object.keys(LATIN_TO_ARABIC_LETTERS).sort(
  (a, b) => b.length - a.length
);
export function transliterate(options: Options): string {
  const { mode } = options;
  const inputStr = options.input.toString();
  switch (mode) {
    case "arabic-to-latin":
      return [...inputStr].map((ch) => ARABIC_TO_LATIN_MAP[ch] ?? ch).join("");
    case "latin-to-arabic-digits":
      return inputStr.replace(/[0-9]/g, (d) => LATIN_TO_ARABIC_DIGITS[d]);
    case "latin-numbers-to-arabic-digits":
      if (!/^\d+$/.test(inputStr)) {
        throw new Error(
          "Mode 'latin-numbers-to-arabic-digits' requires digits only."
        );
      }
      return [...inputStr].map((d) => LATIN_TO_ARABIC_DIGITS[d]).join("");
    case "latin-to-arabic":
      return transliterateLatinToArabic(inputStr);
    default:
      const _exhaustive: never = mode;
      throw new Error(`Unsupported mode: ${_exhaustive}`);
  }
}
function transliterateLatinToArabic(s: string): string {
  let result = "";
  let i = 0;
  const N = s.length;
  const lower = s.toLowerCase();
  while (i < N) {
    let matched = false;
    for (const key of LATIN_LETTER_KEYS) {
      if (lower.startsWith(key, i)) {
        result += LATIN_TO_ARABIC_LETTERS[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const ch = s[i];
    if (digitSet.has(ch)) {
      result += LATIN_TO_ARABIC_DIGITS[ch];
    } else {
      result += ch;
    }
    i++;
  }
  return result;
}



================================================================
End of Codebase
================================================================

================
File: src/output.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
app/
  [subjectSlug]/
    [authorSlug]/
      [bookSlug]/
        [...slug]/
          page.tsx
        page.tsx
  fonts.ts
  globals.css
  layout.tsx
  not-found.tsx
  page.tsx
components/
  common/
    markdown-renderer.tsx
    section.tsx
    theme-mode-toggle.tsx
  debug/
    index.tsx
    tree-structure.hook.ts
    tree-structure.view.tsx
  layout/
    sidebar.tsx
  ui/
    badge.tsx
    button.tsx
    collapsible.tsx
    custom-dialog.tsx
    dialog.tsx
    dropdown-menu.tsx
    input.tsx
    scroll-area.tsx
    separator.tsx
    sheet.tsx
    sidebar.tsx
    skeleton.tsx
    table.tsx
    tabs.tsx
    tooltip.tsx
  visualizations/
    renderers/
      radial/
        radial-sunburst-renderer.tsx
      spatial/
        circle-pack-renderer.tsx
        grid-layout-renderer.tsx
        nested-boxes-renderer.tsx
      tree/
        ascii-tree-renderer.tsx
        collapsible-tree-renderer.tsx
        node-link-diagram-renderer.tsx
    visualization-switcher.tsx
config/
  env.ts
  site.ts
constants/
  arabic-to-english-map.ts
hooks/
  use-mobile.ts
  use-sidebar.tsx
lib/
  content/
    core/
      content-loader.ts
      landing-page-loader.ts
      tree-builder.ts
    query/
      find-node.ts
      get-all-paths.ts
      get-breadcrumbs.ts
      get-leaf-nodes.ts
      get-node-path.ts
    utils/
      path-utils.ts
      tree-utils.ts
    api.ts
    types.ts
  styles/
    tailwind-utils.ts
  text/
    ascii-tree-generator.ts
    transliteration.ts
  output.txt
providers/
  theme-provider.tsx

================================================================
Files
================================================================

================
File: app/[subjectSlug]/[authorSlug]/[bookSlug]/[...slug]/page.tsx
================
import { MarkdownRenderer } from '@/components/common/markdown-renderer';
import { getContentNodeBySlugPath } from '@/lib/content/api';
import { getTreeSlugs } from '@/lib/content/query/get-all-paths';
import type { Metadata, ResolvingMetadata } from 'next';
import { notFound } from 'next/navigation';
type Props = {
  params: Promise<{ slug: string[] }>;
};
export async function generateStaticParams() {
  const slugs = await getTreeSlugs();
  return slugs.map((slugParts) => ({
    slug: slugParts,
  }));
}
export async function generateMetadata(
  { params }: Props,
  parent: ResolvingMetadata
): Promise<Metadata> {
  const resolvedParams = await params;
  const slugPath = resolvedParams.slug;
  const markdown = await getContentNodeBySlugPath(slugPath);
  if (!markdown) {
    return {
      title: 'Not Found',
      description: 'The requested documentation page could not be found.',
    };
  }
  const previousImages = (await parent).openGraph?.images || [];
  const description =
    markdown.excerpt ||
    (markdown.contentHtml
      ? markdown.contentHtml
          .replace(/<[^>]*>/g, '')
          .slice(0, 160)
          .trim() + '...'
      : '');
  const canonicalSlug = slugPath.join('/');
  return {
    title: markdown.title,
    description,
    openGraph: {
      title: markdown.title,
      description,
      type: 'article',
      url: `/learn/${canonicalSlug}`,
      images: previousImages,
    },
    twitter: {
      card: 'summary_large_image',
      title: markdown.title,
      description,
      images: previousImages,
    },
    alternates: {
      canonical: `/learn/${canonicalSlug}`,
    },
  };
}
export default async function Page({ params }: Props) {
  const resolvedParams = await params;
  const slugPath = resolvedParams.slug;
  const markdown = await getContentNodeBySlugPath(slugPath);
  if (!markdown) {
    notFound();
  }
  return (
    <article className="prose prose-slate dark:prose-invert max-w-none">
      <h1>{markdown.title}</h1>
      {markdown.contentHtml ? (
        <MarkdownRenderer content={markdown.contentHtml} />
      ) : (
        <p className="text-muted">No content available for this section.</p>
      )}
    </article>
  );
}

================
File: app/[subjectSlug]/[authorSlug]/[bookSlug]/page.tsx
================
import { Section } from "@/components/common/section";
import { VisualizationSwitcher } from "@/components/visualizations/visualization-switcher";
import { getContentNodeBySlugPath } from "@/lib/content/api";
import type {
  TextLandingSection,
  VisualizationLandingSection,
} from "@/lib/content/types";
import { notFound } from "next/navigation";
interface PageProps {
  params: {
    subjectSlug: string;
    authorSlug: string;
    bookSlug: string;
  };
}
export default async function BookLandingPage({ params }: PageProps) {
  const { subjectSlug, authorSlug, bookSlug } = params;
  const slugPath = [subjectSlug, authorSlug, bookSlug];
  const bookNode = await getContentNodeBySlugPath(slugPath);
  if (!bookNode) {
    return notFound();
  }
  if (!bookNode.landingPageConfig) {
    return (
      <div className="mx-auto flex max-w-4xl flex-col gap-12 p-6">
        <Section>
          <Section.H level={1}>{bookNode.title}</Section.H>
          <Section.P>
            This book does not have a custom landing page configuration.
          </Section.P>
          {bookNode.children.length > 0 && (
            <div className="mt-6">
              <Section.H level={3}>Chapters:</Section.H>
              <ul>
                {bookNode.children.map((child) => (
                  <li key={child.slug}>
                    <a
                      href={`/${slugPath.join("/")}/${child.slug}`}
                      className="text-blue-600 hover:underline"
                    >
                      {child.title}
                    </a>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </Section>
      </div>
    );
  }
  const { landingPageConfig } = bookNode;
  return (
    <div className="mx-auto flex max-w-4xl flex-col gap-12 p-6">
      <Section>
        <Section.H level={1}>{bookNode.title}</Section.H>
      </Section>
      {landingPageConfig.sections.map((section, index) => (
        <Section key={`${section.type}-${index}`}>
          <Section.H level={2}>{section.title}</Section.H>
          {section.type === "text" && (
            <div>
              {(section as TextLandingSection).content.map(
                (paragraph, pIndex) => (
                  <Section.P key={pIndex}>{paragraph}</Section.P>
                ),
              )}
            </div>
          )}
          {section.type === "visualization" && (
            <VisualizationSwitcher
              nodes={(section as VisualizationLandingSection).nodes}
            />
          )}
        </Section>
      ))}
    </div>
  );
}

================
File: app/fonts.ts
================
import localFont from 'next/font/local';
export const ibmPlexSansArabic = localFont({
  src: [
    {
      path: '../../public/fonts/IBMPlexSansArabic-Regular-400.ttf',
      weight: '400',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-Medium-500.ttf',
      weight: '500',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-SemiBold-600.ttf',
      weight: '600',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-Bold-700.ttf',
      weight: '700',
      style: 'normal',
    },
  ],
  variable: '--font-ibmPlexSansArabic',
  display: 'swap',
  preload: true,
});

================
File: app/globals.css
================
@import 'tailwindcss';
@import 'tw-animate-css';
@plugin "@tailwindcss/typography";
@plugin "tailwindcss-debug-screens" {
  classname: 'debug-screens';
  position: 'bottom, right';
  prefix: 'screen: ';
}
@custom-variant dark (&:is(.dark *));
@theme {
  --font-ibmPlexSansArabic: var(--font-ibmPlexSansArabic);
}
@theme {
  --breakpoint-*: initial;
  --breakpoint-xxs: 20rem;
  --breakpoint-xs: 30rem;
  --breakpoint-sm: 40rem;
  --breakpoint-md: 48rem;
  --breakpoint-lg: 64rem;
  --breakpoint-xl: 80rem;
  --breakpoint-2xl: 96rem;
  --breakpoint-3xl: 112rem;
  --breakpoint-4xl: 128rem;
}
@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}
:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}
.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}
@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/layout.tsx
================
import { DevDebuggers } from '@/components/debug';
import { Sidebar } from '@/components/layout/sidebar';
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from '@/components/ui/sidebar';
import { isDev } from '@/config/env';
import { SITE_URL } from '@/config/site';
import { buildContentSummaryTree } from '@/lib/content/core/tree-builder';
import { cn } from '@/lib/styles/tailwind-utils';
import { ThemeProvider } from '@/providers/theme-provider';
import type { Metadata } from 'next';
import { ibmPlexSansArabic } from './fonts';
import './globals.css';
export const metadata: Metadata = {
  metadataBase: new URL(SITE_URL),
  title: {
    template: '%s | Documentation',
    default: 'Documentation',
  },
  description: 'Documentation site built with Next.js',
};
export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const summaryTree = await buildContentSummaryTree();
  return (
    <>
      <html
        dir="rtl"
        lang="ar"
        className={cn(ibmPlexSansArabic.variable)}
        suppressHydrationWarning
      >
        <body
          className={cn(
            'overflow-x-hidden overflow-y-scroll',
            'font-ibmPlexSansArabic antialiased',
            {
              'debug-screens': isDev,
            }
          )}
        >
          <ThemeProvider
            attribute="class"
            defaultTheme="light"
            enableSystem
            disableTransitionOnChange
          >
            <DevDebuggers summaryTree={summaryTree} />
            <SidebarProvider>
              <Sidebar summaryTree={summaryTree} />
              <SidebarInset className="px-4 py-6 md:px-8">
                <header className="mb-4 flex items-center">
                  <SidebarTrigger />
                </header>
                <main className="pb-16">{children}</main>
              </SidebarInset>
            </SidebarProvider>
          </ThemeProvider>
        </body>
      </html>
    </>
  );
}

================
File: app/not-found.tsx
================
import { Button } from '@/components/ui/button';
import { flattenTree } from '@/lib/content/api';
import { buildContentSummaryTree } from '@/lib/content/core/tree-builder';
import { getNodeSlugPath } from '@/lib/content/query/get-node-path';
import { FileQuestion, Home, Search } from 'lucide-react';
import Link from 'next/link';
export const metadata = {
  title: 'Page Not Found | Documentation',
  description: "The page you're looking for doesn't exist or has been moved.",
};
export default async function NotFound() {
  const summaryTree = await buildContentSummaryTree();
  const flatTree = flattenTree(summaryTree);
  const suggestedPages = flatTree.sort(() => 0.5 - Math.random()).slice(0, 3);
  return (
    <div className="flex flex-col items-center justify-center px-4 py-16 text-center">
      <div className="mb-8 rounded-full bg-slate-100 p-6 dark:bg-slate-800">
        <FileQuestion className="h-16 w-16 text-slate-500" />
      </div>
      <h1 className="mb-2 text-4xl font-bold tracking-tight">
        {`404 - Page Not Found`}
      </h1>
      <p className="mb-8 max-w-md text-lg text-slate-500 dark:text-slate-400">
        {`The documentation page you're looking for doesn't exist or has been
        moved to a new location.`}
      </p>
      <div className="mb-12 flex flex-wrap justify-center gap-4">
        <Button asChild>
          <Link href="/">
            <Home className="mr-2 h-4 w-4" />
            Back to Home
          </Link>
        </Button>
        <Button variant="outline" asChild>
          <Link href="/learn">
            <Search className="mr-2 h-4 w-4" />
            Browse All Docs
          </Link>
        </Button>
      </div>
      {suggestedPages.length > 0 && (
        <>
          <h2 className="mb-4 text-xl font-semibold">
            You might be interested in:
          </h2>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {suggestedPages.map((page) => (
              <Link
                key={page.slug}
                href={`/learn/${getNodeSlugPath(page)}`}
                className="rounded-lg border border-slate-200 bg-white p-4 shadow-sm transition-colors hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-800 dark:hover:bg-slate-700"
              >
                <h3 className="font-medium">{page.title}</h3>
              </Link>
            ))}
          </div>
        </>
      )}
    </div>
  );
}

================
File: app/page.tsx
================
import { redirect } from "next/navigation";
export default function Page() {
  redirect("/alnhw/slyman-alaywny/alnhw-alsghyr/");
}

================
File: components/common/markdown-renderer.tsx
================
export function MarkdownRenderer({ content }: { content: string }) {
  return (
    <div
      className="prose-code:bg-gray-100 prose-code:p-1 prose-code:rounded"
      dangerouslySetInnerHTML={{ __html: content }}
    />
  );
}

================
File: components/common/section.tsx
================
import { ReactNode } from 'react';
type SectionProps = {
  children: ReactNode;
};
type SectionTitleProps = {
  children: ReactNode;
  level?: 1 | 2 | 3 | 4 | 5 | 6;
};
type SectionPProps = {
  children: ReactNode;
};
function Section({ children }: SectionProps) {
  return (
    <section className="flex flex-col gap-6">
      {children}
      <div className="h-2 w-full border-t border-zinc-200"></div>
    </section>
  );
}
Section.H = function SectionTitle({ children, level = 2 }: SectionTitleProps) {
  const Tag = `h${level}` as const;
  const sizeMap = {
    1: 'text-4xl',
    2: 'text-3xl',
    3: 'text-2xl',
    4: 'text-xl',
    5: 'text-lg',
    6: 'text-base',
  };
  return <Tag className={`${sizeMap[level]} font-bold`}>{children}</Tag>;
};
Section.P = function SectionParagraph({ children }: SectionPProps) {
  return <p className="text-lg">{children}</p>;
};
export { Section };

================
File: components/common/theme-mode-toggle.tsx
================
'use client';
import { Moon, Sun } from 'lucide-react';
import { useTheme } from 'next-themes';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
export function ThemeModeToggle() {
  const { setTheme } = useTheme();
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: components/debug/index.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import { memo } from 'react';
import { TreeStructureDebugger } from './tree-structure.view';
function DevDebuggersComponent({
  summaryTree,
}: {
  summaryTree: SummaryNode[];
}) {
  return (
    <>
      <TreeStructureDebugger summaryTree={summaryTree} />
    </>
  );
}
export const DevDebuggers = memo(DevDebuggersComponent);

================
File: components/debug/tree-structure.hook.ts
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as React from 'react';
export interface TreeDebuggerState {
  open: boolean;
  copied: boolean;
  searchTerm: string;
  expandedNodes: string[];
  expandAll: boolean;
  activeTab: string;
}
export interface TreeDebuggerActions {
  setOpen: (open: boolean) => void;
  handleCopy: () => void;
  toggleNode: (path: string) => void;
  toggleExpandAll: () => void;
  setSearchTerm: (term: string) => void;
  setActiveTab: (tab: string) => void;
}
export interface TreeDebuggerHelpers {
  formattedTree: string;
  countNodes: (nodes: SummaryNode[]) => number;
  calculateMaxDepth: (nodes: SummaryNode[], currentDepth?: number) => number;
  matchesSearch: (node: SummaryNode, term: string) => boolean;
}
export interface UseTreeDebuggerResult {
  state: TreeDebuggerState;
  actions: TreeDebuggerActions;
  helpers: TreeDebuggerHelpers;
}
export function useTreeStructureDebugger(
  tree: SummaryNode[]
): UseTreeDebuggerResult {
  const [open, setOpen] = React.useState(false);
  const [copied, setCopied] = React.useState(false);
  const [searchTerm, setSearchTerm] = React.useState('');
  const [expandedNodes, setExpandedNodes] = React.useState<string[]>([]);
  const [expandAll, setExpandAll] = React.useState(false);
  const [activeTab, setActiveTab] = React.useState('visual');
  const formattedTree = React.useMemo(
    () => JSON.stringify(tree, null, 2),
    [tree]
  );
  const handleCopy = React.useCallback(() => {
    navigator.clipboard.writeText(formattedTree).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    });
  }, [formattedTree]);
  const toggleNode = React.useCallback((path: string) => {
    setExpandedNodes((prev) =>
      prev.includes(path) ? prev.filter((p) => p !== path) : [...prev, path]
    );
  }, []);
  const toggleExpandAll = React.useCallback(() => {
    setExpandAll((prev) => !prev);
    if (!expandAll) {
      const allPaths: string[] = [];
      const collectPaths = (nodes: SummaryNode[], currentPath = '') => {
        nodes.forEach((node) => {
          const nodePath = currentPath
            ? `${currentPath}.${node.slug}`
            : node.slug;
          allPaths.push(nodePath);
          if (node.children.length) {
            collectPaths(node.children, nodePath);
          }
        });
      };
      collectPaths(tree);
      setExpandedNodes(allPaths);
    } else {
      setExpandedNodes([]);
    }
  }, [expandAll, tree]);
  const countNodes = React.useCallback((nodes: SummaryNode[]): number => {
    let count = nodes.length;
    for (const node of nodes) {
      count += countNodes(node.children);
    }
    return count;
  }, []);
  const calculateMaxDepth = React.useCallback(
    (nodes: SummaryNode[], currentDepth = 1): number => {
      if (nodes.length === 0) return currentDepth - 1;
      let maxDepth = currentDepth;
      for (const node of nodes) {
        if (node.children.length > 0) {
          const childDepth = calculateMaxDepth(node.children, currentDepth + 1);
          maxDepth = Math.max(maxDepth, childDepth);
        }
      }
      return maxDepth;
    },
    []
  );
  const matchesSearch = React.useCallback(
    (node: SummaryNode, term: string): boolean => {
      if (!term) return true;
      const nodeMatches =
        node.title.toLowerCase().includes(term.toLowerCase()) ||
        node.slug.toLowerCase().includes(term.toLowerCase());
      if (nodeMatches) return true;
      return node.children.some((child) => matchesSearch(child, term));
    },
    []
  );
  return {
    state: {
      open,
      copied,
      searchTerm,
      expandedNodes,
      expandAll,
      activeTab,
    },
    actions: {
      setOpen,
      handleCopy,
      toggleNode,
      toggleExpandAll,
      setSearchTerm,
      setActiveTab,
    },
    helpers: {
      formattedTree,
      countNodes,
      calculateMaxDepth,
      matchesSearch,
    },
  };
}

================
File: components/debug/tree-structure.view.tsx
================
'use client';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import {
  CustomDialog,
  CustomDialogContent,
  CustomDialogHeader,
  CustomDialogTitle,
} from '@/components/ui/custom-dialog';
import { DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import type { SummaryNode } from '@/lib/content/types';
import {
  ChevronRight,
  Copy,
  FolderTreeIcon as FileTree,
  Maximize2,
  Minimize2,
  Search,
  X,
} from 'lucide-react';
import { memo } from 'react';
import { useTreeStructureDebugger } from './tree-structure.hook';
function TreeStructureDebuggerComponent({
  summaryTree,
}: {
  summaryTree: SummaryNode[];
}) {
  const { state, actions, helpers } = useTreeStructureDebugger(summaryTree);
  const { open, copied, searchTerm, expandedNodes, expandAll, activeTab } =
    state;
  const {
    setOpen,
    handleCopy,
    toggleNode,
    toggleExpandAll,
    setSearchTerm,
    setActiveTab,
  } = actions;
  const { formattedTree, countNodes, calculateMaxDepth, matchesSearch } =
    helpers;
  if (process.env.NODE_ENV === 'production') return null;
  return (
    <>
      <Button
        onClick={() => setOpen(true)}
        className="fixed bottom-4 left-4 z-50"
        variant="default"
        size="sm"
      >
        <FileTree className="mr-2 h-4 w-4" />
        Tree Debugger
      </Button>
      <CustomDialog open={open} onOpenChange={setOpen}>
        <CustomDialogContent
          dir="ltr"
          className="border-border h-[90vh] w-[90vw] max-w-4xl overflow-x-hidden overflow-y-scroll rounded-lg border p-0 shadow-lg"
        >
          <CustomDialogHeader className="border-b px-6 pt-6 pb-4">
            <div className="flex items-center justify-between">
              <CustomDialogTitle className="flex items-center text-xl font-semibold">
                <FileTree className="text-primary mr-2 h-5 w-5" />
                Tree Structure Debugger
              </CustomDialogTitle>
              <div className="flex items-center gap-2">
                {activeTab === 'visual' && (
                  <Button size="sm" variant="outline" onClick={toggleExpandAll}>
                    {expandAll ? (
                      <>
                        <Minimize2 className="mr-1 h-4 w-4" />
                        Collapse All
                      </>
                    ) : (
                      <>
                        <Maximize2 className="mr-1 h-4 w-4" />
                        Expand All
                      </>
                    )}
                  </Button>
                )}
                {activeTab === 'json' && (
                  <Button size="sm" variant="outline" onClick={handleCopy}>
                    <Copy className="mr-1 h-4 w-4" />
                    {copied ? 'Copied!' : 'Copy JSON'}
                  </Button>
                )}
                <DialogClose asChild>
                  <Button size="icon" variant="ghost">
                    <X className="h-4 w-4" />
                  </Button>
                </DialogClose>
              </div>
            </div>
            <div className="relative mt-4">
              <Search className="text-muted-foreground absolute top-2.5 left-2.5 h-4 w-4" />
              <Input
                placeholder="Search nodes..."
                className="pl-9"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
          </CustomDialogHeader>
          <Tabs
            defaultValue="visual"
            className="flex h-[calc(90vh-160px)] flex-col"
            onValueChange={setActiveTab}
          >
            <TabsList className="mx-6 mt-4 w-auto self-start">
              <TabsTrigger value="visual">Visual Tree</TabsTrigger>
              <TabsTrigger value="json">Raw JSON</TabsTrigger>
            </TabsList>
            <TabsContent
              value="visual"
              className="flex-1 overflow-hidden px-6 pb-6"
            >
              <ScrollArea className="bg-background h-full rounded-md border">
                <div className="p-4">
                  {summaryTree.map((node) => (
                    <TreeNode
                      key={node.slug}
                      node={node}
                      level={0}
                      searchTerm={searchTerm}
                      expandedNodes={expandedNodes}
                      toggleNode={toggleNode}
                      expandAll={expandAll}
                      matchesSearch={matchesSearch}
                    />
                  ))}
                </div>
              </ScrollArea>
            </TabsContent>
            <TabsContent
              value="json"
              className="flex-1 overflow-hidden px-6 pb-6"
            >
              <ScrollArea className="bg-background h-full rounded-md border">
                <pre className="overflow-visible p-4 font-mono text-sm whitespace-pre-wrap">
                  {formattedTree}
                </pre>
              </ScrollArea>
            </TabsContent>
          </Tabs>
          <div className="bg-muted/10 text-muted-foreground border-t px-6 py-3 text-xs">
            <div className="flex items-center justify-between">
              <div>
                Total nodes: {countNodes(summaryTree)} • Root nodes:{' '}
                {summaryTree.length} • Max depth:{' '}
                {calculateMaxDepth(summaryTree)}
              </div>
              <div>
                <span className="font-mono">
                  process.env.NODE_ENV !== "production"
                </span>
              </div>
            </div>
          </div>
        </CustomDialogContent>
      </CustomDialog>
    </>
  );
}
interface TreeNodeProps {
  node: SummaryNode;
  level: number;
  searchTerm: string;
  expandedNodes: string[];
  toggleNode: (path: string) => void;
  expandAll: boolean;
  matchesSearch: (node: SummaryNode, term: string) => boolean;
  parentPath?: string;
}
function TreeNode({
  node,
  level,
  searchTerm,
  expandedNodes,
  toggleNode,
  expandAll,
  matchesSearch,
  parentPath = '',
}: TreeNodeProps) {
  const hasChildren = node.children.length > 0;
  const nodePath = parentPath ? `${parentPath}.${node.slug}` : node.slug;
  const isExpanded = expandedNodes.includes(nodePath) || expandAll;
  const isMatch = matchesSearch(node, searchTerm);
  // If there's a search term and no match, don't render this node
  if (searchTerm && !isMatch) return null;
  return (
    <div className={`${level > 0 ? `ml-${level * 3}` : ''} my-1`}>
      <Collapsible
        open={isExpanded}
        onOpenChange={() => hasChildren && toggleNode(nodePath)}
      >
        <div className="group hover:bg-muted/20 flex items-center rounded-md px-1 py-1">
          {hasChildren ? (
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="text-muted-foreground hover:text-foreground mr-1 h-6 w-6 p-0"
              >
                <ChevronRight
                  className={`h-4 w-4 transition-transform ${
                    isExpanded ? 'rotate-90' : ''
                  }`}
                />
                <span className="sr-only">Toggle</span>
              </Button>
            </CollapsibleTrigger>
          ) : (
            <div className="w-7" />
          )}
          <div className="flex flex-1 items-center gap-2">
            <span
              className={`font-medium ${
                searchTerm &&
                node.title.toLowerCase().includes(searchTerm.toLowerCase())
                  ? 'rounded bg-yellow-100 px-1 dark:bg-yellow-900/30'
                  : ''
              }`}
            >
              {node.title}
            </span>
            <span className="text-muted-foreground font-mono text-xs">
              ({node.slug})
            </span>
            {node.order && (
              <Badge variant="outline" className="text-xs">
                Order: {node.order}
              </Badge>
            )}
          </div>
        </div>
        {hasChildren && (
          <CollapsibleContent>
            <div className="border-muted mt-1 ml-3 border-l-2 pl-3">
              {node.children.map((childNode) => (
                <TreeNode
                  key={childNode.slug}
                  node={childNode}
                  level={level + 1}
                  searchTerm={searchTerm}
                  expandedNodes={expandedNodes}
                  toggleNode={toggleNode}
                  expandAll={expandAll}
                  matchesSearch={matchesSearch}
                  parentPath={nodePath}
                />
              ))}
            </div>
          </CollapsibleContent>
        )}
      </Collapsible>
    </div>
  );
}
export const TreeStructureDebugger = memo(TreeStructureDebuggerComponent);

================
File: components/layout/sidebar.tsx
================
'use client';
import {
  SidebarContent,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  Sidebar as UISidebar,
} from '@/components/ui/sidebar';
import { useSidebar } from '@/hooks/use-sidebar';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import {
  BookOpen,
  ChevronDown,
  ChevronLeft,
  ChevronsDownUp,
  FileText,
  Folder,
} from 'lucide-react';
import Link from 'next/link';
import React, { memo, useCallback } from 'react';
function SidebarComponent({ summaryTree }: { summaryTree: SummaryNode[] }) {
  const {
    flatItems,
    expandedSections,
    toggleSection,
    isCurrentPage,
    toggleAll,
  } = useSidebar(summaryTree);
  const isVisible = useCallback(
    (node: SummaryNode): boolean => {
      let path = '';
      for (const part of node.parentPath) {
        path = path ? `${path}/${part}` : part;
        if (!expandedSections[path]) return false;
      }
      return true;
    },
    [expandedSections]
  );
  return (
    <UISidebar side="right">
      <SidebarContent
        className={cn('overflow-y-scroll', '[&::-webkit-scrollbar]:w-0')}
      >
        <SidebarGroup>
          <SidebarGroupLabel>النحو الرقمي</SidebarGroupLabel>
          <SidebarGroupAction onClick={toggleAll} title="طي وبسط">
            <ChevronsDownUp /> <span className="sr-only">Toggle</span>
          </SidebarGroupAction>
          <SidebarGroupContent>
            <SidebarMenu>
              <SidebarMenuItem key="__home">
                <SidebarMenuButton
                  asChild
                  isActive={isCurrentPage('__home')}
                  className="pl-1.5"
                >
                  <Link href="/">
                    <BookOpen className="h-4 w-4 shrink-0" />
                    <span>مقدمة</span>
                  </Link>
                </SidebarMenuButton>
              </SidebarMenuItem>
              {flatItems.map(({ node, level }) => {
                const fullPath = [...node.parentPath, node.slug].join('/');
                const hasChildren = node.children.length > 0;
                const isExpanded = expandedSections[fullPath] || false;
                const isActive = isCurrentPage(fullPath);
                const visible = isVisible(node);
                if (!visible) return null;
                return (
                  <SidebarMenuItem key={fullPath}>
                    {hasChildren ? (
                      <SidebarMenuButton
                        className={cn(
                          'pr-[calc(0.5rem*var(--level))] pl-1.5',
                          isActive &&
                            'bg-sidebar-accent text-sidebar-accent-foreground font-medium'
                        )}
                        style={{ '--level': 1 + level } as React.CSSProperties}
                        onClick={() => toggleSection(fullPath)}
                      >
                        <Folder className="h-4 w-4 shrink-0" />
                        <span>{node.title}</span>
                        {isExpanded ? (
                          <ChevronDown className="mr-auto h-4 w-4" />
                        ) : (
                          <ChevronLeft className="mr-auto h-4 w-4" />
                        )}
                      </SidebarMenuButton>
                    ) : (
                      <SidebarMenuButton
                        asChild
                        isActive={isActive}
                        className={cn('pr-[calc(0.5rem*var(--level))]')}
                        style={{ '--level': 1 + level } as React.CSSProperties}
                      >
                        <Link href={`/learn/${fullPath}`}>
                          <FileText className="h-4 w-4 shrink-0" />
                          <span>{node.title}</span>
                        </Link>
                      </SidebarMenuButton>
                    )}
                  </SidebarMenuItem>
                );
              })}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
    </UISidebar>
  );
}
export const Sidebar = memo(SidebarComponent);

================
File: components/ui/badge.tsx
================
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
const badgeVariants = cva(
  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',
        destructive:
          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);
function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<'span'> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'span';
  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  );
}
export { Badge, badgeVariants };

================
File: components/ui/button.tsx
================
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',
        destructive:
          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary:
          'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost:
          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}
export { Button, buttonVariants };

================
File: components/ui/collapsible.tsx
================
'use client';
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';
function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />;
}
function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  );
}
function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  );
}
export { Collapsible, CollapsibleTrigger, CollapsibleContent };

================
File: components/ui/custom-dialog.tsx
================
'use client';
import { cn } from '@/lib/styles/tailwind-utils';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import * as React from 'react';
const CustomDialog = DialogPrimitive.Root;
const CustomDialogTrigger = DialogPrimitive.Trigger;
const CustomDialogPortal = DialogPrimitive.Portal;
const CustomDialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/90',
      className
    )}
    {...props}
  />
));
CustomDialogOverlay.displayName = DialogPrimitive.Overlay.displayName;
const CustomDialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <CustomDialogPortal>
    <CustomDialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] fixed top-[50%] left-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border p-6 shadow-lg duration-200 sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      {}
    </DialogPrimitive.Content>
  </CustomDialogPortal>
));
CustomDialogContent.displayName = DialogPrimitive.Content.displayName;
const CustomDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
CustomDialogHeader.displayName = 'CustomDialogHeader';
const CustomDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
CustomDialogFooter.displayName = 'CustomDialogFooter';
const CustomDialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg leading-none font-semibold tracking-tight',
      className
    )}
    {...props}
  />
));
CustomDialogTitle.displayName = DialogPrimitive.Title.displayName;
const CustomDialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-muted-foreground text-sm', className)}
    {...props}
  />
));
CustomDialogDescription.displayName = DialogPrimitive.Description.displayName;
export {
  CustomDialog,
  CustomDialogContent,
  CustomDialogDescription,
  CustomDialogFooter,
  CustomDialogHeader,
  CustomDialogOverlay,
  CustomDialogPortal,
  CustomDialogTitle,
  CustomDialogTrigger,
};

================
File: components/ui/dialog.tsx
================
'use client';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}
function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}
function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}
function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}
function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className
      )}
      {...props}
    />
  );
}
function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}
function DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  );
}
function DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        'flex flex-col-reverse gap-2 sm:flex-row sm:justify-end',
        className
      )}
      {...props}
    />
  );
}
function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn('text-lg leading-none font-semibold', className)}
      {...props}
    />
  );
}
function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}
export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};

================
File: components/ui/dropdown-menu.tsx
================
'use client';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}
function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}
function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}
function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}
function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: 'default' | 'destructive';
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}
function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}
function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}
function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        'px-2 py-1.5 text-sm font-medium data-[inset]:pl-8',
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  );
}
function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        'text-muted-foreground ml-auto text-xs tracking-widest',
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}
function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        'focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8',
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}
function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg',
        className
      )}
      {...props}
    />
  );
}
export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};

================
File: components/ui/input.tsx
================
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        'file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        'focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',
        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
        className
      )}
      {...props}
    />
  );
}
export { Input };

================
File: components/ui/scroll-area.tsx
================
'use client';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn('relative', className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}
function ScrollBar({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        'flex touch-none p-px transition-colors select-none',
        orientation === 'vertical' &&
          'h-full w-2.5 border-l border-l-transparent',
        orientation === 'horizontal' &&
          'h-2.5 flex-col border-t border-t-transparent',
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}
export { ScrollArea, ScrollBar };

================
File: components/ui/separator.tsx
================
'use client';
import * as SeparatorPrimitive from '@radix-ui/react-separator';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Separator({
  className,
  orientation = 'horizontal',
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',
        className
      )}
      {...props}
    />
  );
}
export { Separator };

================
File: components/ui/sheet.tsx
================
'use client';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />;
}
function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />;
}
function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />;
}
function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />;
}
function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className
      )}
      {...props}
    />
  );
}
function SheetContent({
  className,
  children,
  side = 'right',
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: 'top' | 'right' | 'bottom' | 'left';
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
          side === 'right' &&
            'data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm',
          side === 'left' &&
            'data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm',
          side === 'top' &&
            'data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b',
          side === 'bottom' &&
            'data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t',
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  );
}
function SheetHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-header"
      className={cn('flex flex-col gap-1.5 p-4', className)}
      {...props}
    />
  );
}
function SheetFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn('mt-auto flex flex-col gap-2 p-4', className)}
      {...props}
    />
  );
}
function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn('text-foreground font-semibold', className)}
      {...props}
    />
  );
}
function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}
export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
};

================
File: components/ui/sidebar.tsx
================
'use client';
import { Slot } from '@radix-ui/react-slot';
import { VariantProps, cva } from 'class-variance-authority';
import { PanelRightIcon } from 'lucide-react';
import * as React from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Separator } from '@/components/ui/separator';
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useIsMobile } from '@/hooks/use-mobile';
import { cn } from '@/lib/styles/tailwind-utils';
const SIDEBAR_COOKIE_NAME = 'sidebar_state';
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = '16rem';
const SIDEBAR_WIDTH_MOBILE = '18rem';
const SIDEBAR_WIDTH_ICON = '3rem';
const SIDEBAR_KEYBOARD_SHORTCUT = 'b';
type SidebarContextProps = {
  state: 'expanded' | 'collapsed';
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};
const SidebarContext = React.createContext<SidebarContextProps | null>(null);
function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.');
  }
  return context;
}
function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === 'function' ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault();
        toggleSidebar();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleSidebar]);
  const state = open ? 'expanded' : 'collapsed';
  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );
  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH,
              '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            'group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full',
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
}
function Sidebar({
  side = 'left',
  variant = 'sidebar',
  collapsible = 'offcanvas',
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  side?: 'left' | 'right';
  variant?: 'sidebar' | 'floating' | 'inset';
  collapsible?: 'offcanvas' | 'icon' | 'none';
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();
  if (collapsible === 'none') {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          'bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col',
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }
  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === 'collapsed' ? collapsible : ''}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          'relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear',
          'group-data-[collapsible=offcanvas]:w-0',
          'group-data-[side=right]:rotate-180',
          variant === 'floating' || variant === 'inset'
            ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon)'
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          'fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex',
          side === 'left'
            ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
            : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
          variant === 'floating' || variant === 'inset'
            ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l',
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
}
function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar();
  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn('size-7', className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelRightIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
}
function SidebarRail({ className, ...props }: React.ComponentProps<'button'>) {
  const { toggleSidebar } = useSidebar();
  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        'hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex',
        'in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize',
        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
        'hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full',
        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
        className
      )}
      {...props}
    />
  );
}
function SidebarInset({ className, ...props }: React.ComponentProps<'main'>) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        'bg-background relative flex w-full flex-1 flex-col',
        'md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2',
        className
      )}
      {...props}
    />
  );
}
function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn('bg-background h-8 w-full shadow-none', className)}
      {...props}
    />
  );
}
function SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}
function SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}
function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn('bg-sidebar-border mx-2 w-auto', className)}
      {...props}
    />
  );
}
function SidebarContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
      {...props}
    />
  );
}
function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'div'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'div';
  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        'text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 left-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'after:absolute after:-inset-2 md:after:hidden',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn('w-full text-sm', className)}
      {...props}
    />
  );
}
function SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn('flex w-full min-w-0 flex-col gap-1', className)}
      {...props}
    />
  );
}
function SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn('group/menu-item relative', className)}
      {...props}
    />
  );
}
const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:p-0!',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = 'default',
  size = 'default',
  tooltip,
  className,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : 'button';
  const { isMobile, state } = useSidebar();
  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );
  if (!tooltip) {
    return button;
  }
  if (typeof tooltip === 'string') {
    tooltip = {
      children: tooltip,
    };
  }
  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== 'collapsed' || isMobile}
        {...tooltip}
      />
    </Tooltip>
  );
}
function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'after:absolute after:-inset-2 md:after:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        'text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none',
        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<'div'> & {
  showIcon?: boolean;
}) {
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);
  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  );
}
function SidebarMenuSub({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        'border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn('group/menu-sub-item relative', className)}
      {...props}
    />
  );
}
function SidebarMenuSubButton({
  asChild = false,
  size = 'md',
  isActive = false,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean;
  size?: 'sm' | 'md';
  isActive?: boolean;
}) {
  const Comp = asChild ? Slot : 'a';
  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};

================
File: components/ui/skeleton.tsx
================
import { cn } from '@/lib/styles/tailwind-utils';
function Skeleton({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="skeleton"
      className={cn('bg-accent animate-pulse rounded-md', className)}
      {...props}
    />
  );
}
export { Skeleton };

================
File: components/ui/table.tsx
================
'use client';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Table({ className, ...props }: React.ComponentProps<'table'>) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn('w-full caption-bottom text-sm', className)}
        {...props}
      />
    </div>
  );
}
function TableHeader({ className, ...props }: React.ComponentProps<'thead'>) {
  return (
    <thead
      data-slot="table-header"
      className={cn('[&_tr]:border-b', className)}
      {...props}
    />
  );
}
function TableBody({ className, ...props }: React.ComponentProps<'tbody'>) {
  return (
    <tbody
      data-slot="table-body"
      className={cn('[&_tr:last-child]:border-0', className)}
      {...props}
    />
  );
}
function TableFooter({ className, ...props }: React.ComponentProps<'tfoot'>) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        'bg-muted/50 border-t font-medium [&>tr]:last:border-b-0',
        className
      )}
      {...props}
    />
  );
}
function TableRow({ className, ...props }: React.ComponentProps<'tr'>) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        'hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors',
        className
      )}
      {...props}
    />
  );
}
function TableHead({ className, ...props }: React.ComponentProps<'th'>) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        'text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}
function TableCell({ className, ...props }: React.ComponentProps<'td'>) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        'p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}
function TableCaption({
  className,
  ...props
}: React.ComponentProps<'caption'>) {
  return (
    <caption
      data-slot="table-caption"
      className={cn('text-muted-foreground mt-4 text-sm', className)}
      {...props}
    />
  );
}
export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
};

================
File: components/ui/tabs.tsx
================
'use client';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn('flex flex-col gap-2', className)}
      {...props}
    />
  );
}
function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        'bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]',
        className
      )}
      {...props}
    />
  );
}
function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}
function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn('flex-1 outline-none', className)}
      {...props}
    />
  );
}
export { Tabs, TabsContent, TabsList, TabsTrigger };

================
File: components/ui/tooltip.tsx
================
'use client';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}
function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}
function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance',
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}
export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };

================
File: components/visualizations/renderers/radial/radial-sunburst-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as d3 from 'd3';
import { ZoomIn, ZoomOut } from 'lucide-react';
import { memo, useCallback, useEffect, useRef, useState } from 'react';
type HierarchyDatum = {
  name: string;
  value: number;
  children?: HierarchyDatum[];
};
const GRADIENT_DEFINITIONS = [
  { id: 'gradient-1', from: '#fafafa', to: '#f4f4f5' },
  { id: 'gradient-2', from: '#f4f4f5', to: '#e4e4e7' },
  { id: 'gradient-3', from: '#e4e4e7', to: '#d4d4d8' },
  { id: 'gradient-4', from: '#d4d4d8', to: '#a1a1aa' },
  { id: 'gradient-5', from: '#a1a1aa', to: '#71717a' },
  { id: 'gradient-6', from: '#71717a', to: '#52525b' },
  { id: 'gradient-7', from: '#52525b', to: '#3f3f46' },
  { id: 'gradient-8', from: '#3f3f46', to: '#27272a' },
  { id: 'gradient-9', from: '#27272a', to: '#18181b' },
] as const;
export const RadialSunburstRenderer = memo(
  ({
    nodes,
    initialWidth = 1000,
    initialHeight = 1000,
  }: {
    nodes: SummaryNode[];
    initialWidth?: number;
    initialHeight?: number;
  }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const svgRef = useRef<SVGSVGElement>(null);
    const zoomBehaviorRef = useRef<d3.ZoomBehavior<
      SVGSVGElement,
      unknown
    > | null>(null);
    const [zoomLevel, setZoomLevel] = useState(1);
    const [dimensions, setDimensions] = useState({
      width: initialWidth,
      height: initialHeight,
    });
    const transformData = useCallback(
      (nodes: SummaryNode[]): HierarchyDatum[] => {
        const transform = (nodes: SummaryNode[]): HierarchyDatum[] => {
          return nodes.map(
            (node): HierarchyDatum => ({
              name: node.title,
              value: node.children.length ? 0 : 1,
              children: node.children.length
                ? transform(node.children)
                : undefined,
            })
          );
        };
        return transform(nodes);
      },
      []
    );
    useEffect(() => {
      const updateDimensions = () => {
        if (!containerRef.current) return;
        const containerWidth = containerRef.current.clientWidth;
        const containerHeight = containerRef.current.clientHeight;
        const size = Math.max(
          Math.min(
            Math.min(containerWidth - 40, containerHeight - 100),
            initialWidth
          ),
          1000
        );
        setDimensions({ width: size, height: size });
      };
      updateDimensions();
      window.addEventListener('resize', updateDimensions);
      return () => window.removeEventListener('resize', updateDimensions);
    }, [initialWidth, initialHeight]);
    const handleZoomIn = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        d3.select(svgRef.current)
          .transition()
          .duration(300)
          .call(zoomBehaviorRef.current.scaleBy, 1.5);
      }
    }, []);
    const handleZoomOut = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        d3.select(svgRef.current)
          .transition()
          .duration(300)
          .call(zoomBehaviorRef.current.scaleBy, 1 / 1.5);
      }
    }, []);
    const handleResetZoom = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        const { width, height } = dimensions;
        const centerX = width / 2;
        const centerY = height / 2;
        d3.select(svgRef.current)
          .transition()
          .duration(500)
          .call(
            zoomBehaviorRef.current.transform,
            d3.zoomIdentity.translate(centerX, centerY).scale(1)
          );
      }
    }, [dimensions]);
    useEffect(() => {
      if (!svgRef.current || !nodes.length || !dimensions.width) return;
      const svg = d3.select(svgRef.current);
      svg.selectAll('*').remove();
      const { width, height } = dimensions;
      const radius = Math.min(width, height) / 2.2;
      const defs = svg.append('defs');
      GRADIENT_DEFINITIONS.forEach((gradientDef) => {
        const gradient = defs
          .append('radialGradient')
          .attr('id', gradientDef.id)
          .attr('cx', '50%')
          .attr('cy', '50%')
          .attr('r', '50%');
        gradient
          .append('stop')
          .attr('offset', '0%')
          .attr('stop-color', gradientDef.from);
        gradient
          .append('stop')
          .attr('offset', '100%')
          .attr('stop-color', gradientDef.to);
      });
      const zoom = d3
        .zoom<SVGSVGElement, unknown>()
        .scaleExtent([0.5, 5])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
          setZoomLevel(event.transform.k);
        });
      zoomBehaviorRef.current = zoom;
      svg.call(zoom);
      const g = svg
        .append('g')
        .attr('transform', `translate(${width / 2},${height / 2})`);
      const root = d3
        .hierarchy<HierarchyDatum>({
          name: 'root',
          value: 0,
          children: transformData(nodes),
        })
        .sum((d) => d.value);
      const partition = d3
        .partition<HierarchyDatum>()
        .size([2 * Math.PI, radius * 0.95]);
      const rootWithPartition = partition(root);
      const gradientScale = d3
        .scaleOrdinal<number, string>()
        .domain([1, 2, 3, 4, 5, 6, 7, 8, 9])
        .range(GRADIENT_DEFINITIONS.map((def) => def.id));
      const arc = d3
        .arc<d3.HierarchyRectangularNode<HierarchyDatum>>()
        .startAngle((d) => d.x0)
        .endAngle((d) => d.x1)
        .innerRadius((d) => d.y0)
        .outerRadius((d) => d.y1);
      const segments = g
        .selectAll('path')
        .data(rootWithPartition.descendants().slice(1))
        .enter()
        .append('path')
        .attr('d', (d) => arc(d as d3.HierarchyRectangularNode<HierarchyDatum>))
        .style('fill', (d) => `url(#${gradientScale(d.depth)})`)
        .style('opacity', 0.9)
        .style('stroke', '#ffffff')
        .style('stroke-width', '1px')
        .style('cursor', 'pointer')
        .on('mouseover', function () {
          d3.select(this).style('opacity', 1).style('stroke-width', '2px');
        })
        .on('mouseout', function () {
          d3.select(this).style('opacity', 0.9).style('stroke-width', '1px');
        });
      segments.append('title').text((d) => d.data.name);
      const textNodes = rootWithPartition
        .descendants()
        .slice(1)
        .filter((d) => {
          const node = d as d3.HierarchyRectangularNode<HierarchyDatum>;
          const arcAngleDegrees = (node.x1 - node.x0) * (180 / Math.PI);
          const radialThickness = node.y1 - node.y0;
          const minAngle = node.depth === 1 ? 3 : node.depth === 2 ? 2 : 1.5;
          const minThickness = radius * 0.02;
          return arcAngleDegrees > minAngle && radialThickness > minThickness;
        });
      const textContainers = g
        .selectAll('.text-container')
        .data(textNodes)
        .enter()
        .append('g')
        .attr('class', 'text-container');
      textContainers.each(function (d) {
        const node = d as d3.HierarchyRectangularNode<HierarchyDatum>;
        const middleAngle = (node.x0 + node.x1) / 2;
        const middleRadius = (node.y0 + node.y1) / 2;
        const x = Math.sin(middleAngle) * middleRadius;
        const y = -Math.cos(middleAngle) * middleRadius;
        const arcWidth = node.y1 - node.y0;
        const arcAngle = node.x1 - node.x0;
        const arcLength = arcAngle * middleRadius;
        const boxWidth = Math.min(arcLength * 0.9, arcWidth * 2);
        const boxHeight = arcWidth * 0.9;
        const baseFontSize =
          Math.min(dimensions.width, dimensions.height) / 100;
        let fontSize;
        if (d.depth === 1) {
          fontSize = Math.min(baseFontSize * 2.5, arcWidth * 0.4);
        } else if (d.depth === 2) {
          fontSize = Math.min(baseFontSize * 2, arcWidth * 0.3);
        } else {
          fontSize = Math.min(baseFontSize * 1.5, arcWidth * 0.25);
        }
        fontSize = Math.max(fontSize, 8);
        let rotation = (middleAngle * 180) / Math.PI;
        if (rotation > 90 && rotation < 270) {
          rotation += 180;
        }
        const textColor = d.depth <= 4 ? '#18181b' : '#ffffff';
        const textElement = d3
          .select(this)
          .attr('transform', `translate(${x},${y}) rotate(${rotation})`)
          .append('text')
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .attr('fill', textColor)
          .attr('font-size', `${fontSize}px`)
          .attr('font-family', 'var(--font-ibmPlexSansArabic)')
          .attr('font-weight', '600')
          .style(
            'text-shadow',
            textColor === '#ffffff'
              ? '1px 1px 3px rgba(0,0,0,0.8)'
              : '1px 1px 3px rgba(255,255,255,0.8)'
          );
        const words = d.data.name.split(/\s+/);
        const lineHeight = fontSize * 1.2;
        const maxLines = Math.max(1, Math.floor(boxHeight / lineHeight));
        const charsPerLine = Math.max(
          3,
          Math.floor(boxWidth / (fontSize * 0.55))
        );
        if (
          words.length === 1 &&
          words[0].length > charsPerLine &&
          maxLines > 1
        ) {
          const word = words[0];
          let currentLine = '';
          let lineNumber = 0;
          for (let i = 0; i < word.length && lineNumber < maxLines; i++) {
            currentLine += word[i];
            if (currentLine.length >= charsPerLine || i === word.length - 1) {
              const isLastLine =
                lineNumber === maxLines - 1 || i === word.length - 1;
              const text =
                isLastLine && i < word.length - 1
                  ? currentLine + '...'
                  : currentLine;
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(text);
              currentLine = '';
              lineNumber++;
            }
          }
        } else {
          // Handle multiple words
          let currentLine = '';
          let lineNumber = 0;
          for (let i = 0; i < words.length && lineNumber < maxLines; i++) {
            const word = words[i];
            const testLine = currentLine + (currentLine ? ' ' : '') + word;
            if (testLine.length <= charsPerLine || currentLine === '') {
              currentLine = testLine;
            } else {
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(currentLine);
              currentLine = word;
              lineNumber++;
            }
            if (i === words.length - 1 && lineNumber < maxLines) {
              const isLastPossibleLine = lineNumber === maxLines - 1;
              const hasMoreWords = i < words.length - 1;
              const text =
                isLastPossibleLine && hasMoreWords
                  ? currentLine + '...'
                  : currentLine;
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(text);
            }
          }
        }
      });
    }, [nodes, dimensions, transformData]);
    return (
      <div
        ref={containerRef}
        className="relative h-[80vh] w-full rounded-lg bg-zinc-100/80 shadow ring-1 shadow-zinc-100 ring-zinc-200 dark:bg-slate-800"
      >
        {}
        <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
          <button
            onClick={handleZoomIn}
            className="flex items-center justify-center rounded-lg border border-zinc-200 bg-white p-2 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700"
            title="Zoom In"
          >
            <ZoomIn className="h-5 w-5 text-zinc-600 dark:text-zinc-300" />
          </button>
          <button
            onClick={handleZoomOut}
            className="flex items-center justify-center rounded-lg border border-zinc-200 bg-white p-2 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700"
            title="Zoom Out"
          >
            <ZoomOut className="h-5 w-5 text-zinc-600 dark:text-zinc-300" />
          </button>
          <button
            onClick={handleResetZoom}
            className="rounded-lg border border-zinc-200 bg-white px-3 py-2 text-xs font-bold text-zinc-600 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700 dark:text-zinc-300"
            title="Reset Zoom"
          >
            اضبط
          </button>
        </div>
        {}
        <div className="absolute right-4 bottom-4 z-10 rounded-lg border border-zinc-200 bg-white px-3 py-1 shadow-xs dark:border-zinc-600 dark:bg-zinc-700">
          <span className="text-xs font-medium text-zinc-600 dark:text-zinc-300">
            {Math.round(zoomLevel * 100)}%
          </span>
        </div>
        {}
        <div className="flex h-full w-full items-center justify-center overflow-hidden">
          <svg
            ref={svgRef}
            className="cursor-grab active:cursor-grabbing"
            width={`${dimensions.width}px`}
            height={`${dimensions.height}px`}
            viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
            preserveAspectRatio="xMidYMid meet"
          />
        </div>
      </div>
    );
  }
);
RadialSunburstRenderer.displayName = 'RadialSunburstRenderer';

================
File: components/visualizations/renderers/spatial/circle-pack-renderer.tsx
================
'use client';
import * as d3 from 'd3';
import { useEffect, useRef } from 'react';
interface SummaryNode {
  title: string;
  children: SummaryNode[];
}
interface PackVisualizationProps {
  nodes: SummaryNode[];
  width?: number;
  height?: number;
}
type HierarchyData = {
  title: string;
  children?: HierarchyData[];
};
export function CirclePackRenderer({
  nodes,
  width = 800,
  height = 800,
}: PackVisualizationProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    if (!svgRef.current || !containerRef.current || nodes.length === 0) return;
    const hierarchyData: HierarchyData = {
      title: 'root',
      children: nodes as HierarchyData[],
    };
    const root = d3
      .hierarchy(hierarchyData)
      .sum((d) => Math.max(20, d.title.length));
    const pack = d3.pack<HierarchyData>().size([width, height]).padding(20);
    const packedData = pack(root);
    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();
    const g = svg.append('g');
    const zoom = d3
      .zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
    svg.call(zoom);
    function wrap(
      text: d3.Selection<SVGTextElement, any, any, any>,
      width: number
    ) {
      text.each(function () {
        const textElement = d3.select(this);
        const words = textElement.text().split(/\s+/);
        const lineHeight = 1.1;
        let line: string[] = [];
        let lineNumber = 0;
        const y = textElement.attr('y') || 0;
        const dy = parseFloat(textElement.attr('dy') || '0');
        textElement.text('');
        let tspan = textElement
          .append('tspan')
          .attr('x', 0)
          .attr('y', y)
          .attr('dy', `${dy}em`);
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          line.push(word);
          tspan.text(line.join(' '));
          if (
            (tspan.node()?.getComputedTextLength() || 0) > width &&
            line.length > 1
          ) {
            line.pop();
            tspan.text(line.join(' '));
            line = [word];
            lineNumber++;
            tspan = textElement
              .append('tspan')
              .attr('x', 0)
              .attr('dy', `${lineHeight}em`)
              .text(word);
          }
        }
        const totalLines = lineNumber + 1;
        const offsetY = -(totalLines - 1) * lineHeight * 0.5;
        textElement.selectAll('tspan').each(function (d, i) {
          d3.select(this).attr(
            'dy',
            i === 0 ? `${dy + offsetY}em` : `${lineHeight}em`
          );
        });
      });
    }
    function getTextPosition(d: d3.HierarchyCircularNode<HierarchyData>) {
      if (!d.children) {
        return { x: 0, y: 0 };
      }
      const children = d.children;
      const radius = d.r;
      const positions = [
        { x: 0, y: -radius * 0.7 },
        { x: 0, y: radius * 0.7 },
        { x: -radius * 0.7, y: 0 },
        { x: radius * 0.7, y: 0 },
        { x: -radius * 0.5, y: -radius * 0.5 },
        { x: radius * 0.5, y: -radius * 0.5 },
        { x: -radius * 0.5, y: radius * 0.5 },
        { x: radius * 0.5, y: radius * 0.5 },
      ];
      let bestPosition = positions[0];
      let minOverlap = Infinity;
      for (const pos of positions) {
        let overlap = 0;
        for (const child of children) {
          const distance = Math.sqrt(
            Math.pow(pos.x - (child.x - d.x), 2) +
              Math.pow(pos.y - (child.y - d.y), 2)
          );
          if (distance < child.r + 20) {
            overlap += child.r + 20 - distance;
          }
        }
        if (overlap < minOverlap) {
          minOverlap = overlap;
          bestPosition = pos;
        }
      }
      return bestPosition;
    }
    const hasChildren = (
      d: d3.HierarchyCircularNode<HierarchyData>
    ): boolean => {
      return Boolean(d.children && d.children.length > 0);
    };
    const node = g
      .selectAll<SVGGElement, d3.HierarchyCircularNode<HierarchyData>>('g')
      .data(packedData.descendants().filter((d) => d.depth > 0))
      .join('g')
      .attr('transform', (d) => `translate(${d.x},${d.y})`);
    node
      .filter((d) => !hasChildren(d))
      .append('circle')
      .attr('r', (d) => d.r)
      .attr('fill', '#ffffff00')
      .attr('stroke', '#999')
      .attr('stroke-width', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function () {
        d3.select(this).attr('stroke-width', 2);
      })
      .on('mouseout', function () {
        d3.select(this).attr('stroke-width', 1);
      });
    node
      .filter((d) => hasChildren(d))
      .append('circle')
      .attr('r', (d) => d.r)
      .attr('fill', '#ffffff00')
      .attr('stroke', '#999')
      .attr('stroke-width', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function () {
        d3.select(this).attr('stroke-width', 2);
      })
      .on('mouseout', function () {
        d3.select(this).attr('stroke-width', 1);
      });
    const textElements = node
      .append('text')
      .attr('text-anchor', 'middle')
      .attr('transform', (d) => {
        const pos = getTextPosition(d);
        return `translate(${pos.x}, ${pos.y})`;
      })
      .style('font-size', (d) => {
        const baseSize = Math.min(d.r / 4, 14);
        const textLength = d.data.title.length;
        const scaleFactor = d.children ? 0.8 : 1;
        return `${Math.max(
          baseSize * scaleFactor * (25 / Math.max(textLength, 25)),
          8
        )}px`;
      })
      .style('fill', (d) => (d.children ? '#666666' : '#000000'))
      .style('font-weight', (d) => (d.children ? 'bold' : 'normal'))
      .style('pointer-events', 'none')
      .text((d) => d.data.title);
    textElements.each(function (d) {
      const wrapWidth = d.children ? d.r * 0.8 : d.r * 1.6;
      wrap(d3.select(this), wrapWidth);
    });
    node.on('dblclick', (event, d) => {
      event.stopPropagation();
      const dx = d.x;
      const dy = d.y;
      const scale = Math.min(width / (d.r * 2), height / (d.r * 2)) * 0.9;
      svg
        .transition()
        .duration(750)
        .call(
          zoom.transform,
          d3.zoomIdentity
            .translate(width / 2, height / 2)
            .scale(scale)
            .translate(-dx, -dy)
        );
    });
    svg.on('dblclick', () => {
      svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
    });
  }, [nodes, width, height]);
  return (
    <div
      ref={containerRef}
      className="flex items-center justify-center overflow-hidden rounded-lg bg-zinc-100 shadow ring-1 shadow-zinc-100 ring-zinc-200"
      style={{ width: '100%', height: '100%' }}
    >
      <svg
        ref={svgRef}
        width={'100%'}
        height={'100%'}
        viewBox={`0 0 ${width} ${height}`}
        style={{ maxWidth: '100%', height: 'auto' }}
      />
    </div>
  );
}

================
File: components/visualizations/renderers/spatial/grid-layout-renderer.tsx
================
import { getLeafNodes } from '@/lib/content/query/get-leaf-nodes';
import type { SummaryNode } from '@/lib/content/types';
import { memo } from 'react';
export const GridLayoutRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    const leafNodes = getLeafNodes(nodes);
    return (
      <div className="xs:grid-cols-2 grid grid-cols-1 gap-4 py-4 md:grid-cols-3 lg:grid-cols-4">
        {leafNodes.map((node) => (
          <a
            key={node.slug}
            href={`/learn/${node.slug}`}
            className="rounded-lg border p-4 transition-colors hover:bg-zinc-50 dark:hover:bg-zinc-800"
          >
            <h2 className="text-base">{node.title}</h2>
          </a>
        ))}
      </div>
    );
  }
);

================
File: components/visualizations/renderers/spatial/nested-boxes-renderer.tsx
================
'use client';
import { getNodeSlugPath } from '@/lib/content/query/get-node-path';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import Link from 'next/link';
import { memo, useId } from 'react';
const COLOR_SCHEMES = [
  {
    bg: 'bg-gradient-to-br from-zinc-50 to-zinc-100',
    border: 'border-zinc-200',
    text: 'text-zinc-700',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-100 to-zinc-200',
    border: 'border-zinc-300',
    text: 'text-zinc-800',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-200 to-zinc-300',
    border: 'border-zinc-400',
    text: 'text-zinc-900',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-300 to-zinc-400',
    border: 'border-zinc-500',
    text: 'text-white',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-400 to-zinc-500',
    border: 'border-zinc-600',
    text: 'text-white',
  },
] as const;
const FONT_SIZES = {
  0: 'text-lg md:text-xl',
  1: 'text-base md:text-lg',
  2: 'text-sm md:text-base',
  default: 'text-xs md:text-sm',
} as const;
const PADDINGS = {
  0: 'py-3 px-4 md:py-4 md:px-5',
  1: 'py-2 px-3 md:py-3 md:px-4',
  default: 'py-1.5 px-2 md:py-2 md:px-3',
} as const;
const GAPS = {
  container: 'gap-2 md:gap-4',
  margin: 'mt-2 md:mt-4',
} as const;
const CONTAINER_STYLES = {
  wrapper: 'w-full bg-zinc-100 rounded-lg ring-1 ring-zinc-200 overflow-hidden',
  flexContainer: 'w-full flex flex-wrap',
  centerContent: 'justify-center',
} as const;
const BOX_STYLES = {
  base: 'w-full rounded-lg border transition-all duration-200',
  interactive: 'group cursor-pointer',
  textBase: 'font-medium transition-all duration-200',
  linkBase: 'transition-all duration-200 block truncate',
} as const;
const ANIMATIONS = {
  duration: 'duration-200',
  fontWeight: 'group-hover:font-semibold',
} as const;
export const NestedBoxesRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    return (
      <div className={CONTAINER_STYLES.wrapper}>
        <BoxView nodes={nodes} />
      </div>
    );
  }
);
const BoxView = memo(
  ({ nodes, depth = 0 }: { nodes: SummaryNode[]; depth?: number }) => {
    const scheme = COLOR_SCHEMES[depth % COLOR_SCHEMES.length];
    const uniqueId = useId();
    const getFontSize = (depth: number): string => {
      if (depth in FONT_SIZES) {
        return FONT_SIZES[depth as keyof typeof FONT_SIZES];
      }
      return FONT_SIZES.default;
    };
    const getPadding = (depth: number): string => {
      if (depth in PADDINGS) {
        return PADDINGS[depth as keyof typeof PADDINGS];
      }
      return PADDINGS.default;
    };
    return (
      <div
        className={cn(
          CONTAINER_STYLES.flexContainer,
          GAPS.container,
          depth > 0 ? GAPS.margin : CONTAINER_STYLES.centerContent
        )}
      >
        {nodes.map((node) => (
          <div
            key={`${uniqueId}-${node.slug}`}
            className={cn(
              BOX_STYLES.base,
              BOX_STYLES.interactive,
              scheme.bg,
              scheme.border,
              getPadding(depth)
            )}
          >
            <div
              className={cn(
                BOX_STYLES.textBase,
                scheme.text,
                ANIMATIONS.fontWeight,
                getFontSize(depth)
              )}
            >
              <Link
                href={`/learn/${getNodeSlugPath(node)}`}
                className={BOX_STYLES.linkBase}
              >
                {node.title}
              </Link>
            </div>
            {node.children.length > 0 && (
              <BoxView nodes={node.children} depth={depth + 1} />
            )}
          </div>
        ))}
      </div>
    );
  }
);

================
File: components/visualizations/renderers/tree/ascii-tree-renderer.tsx
================
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import { generateASCIITree } from '@/lib/text/ascii-tree-generator';
import { memo } from 'react';
export const ASCIITreeRenderer = memo(({ nodes }: { nodes: SummaryNode[] }) => {
  return (
    <div className="max-w-none overflow-hidden rounded-lg bg-zinc-100/80 shadow ring-1 shadow-zinc-100 ring-zinc-200">
      <p
        className={cn(
          'overflow-auto p-6 text-base whitespace-pre text-zinc-700'
        )}
      >
        {generateASCIITree(nodes, {
          indent: '',
        })}
      </p>
    </div>
  );
});

================
File: components/visualizations/renderers/tree/collapsible-tree-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import { transliterate } from '@/lib/text/transliteration';
import { memo } from 'react';
const ZINC_SHADES = [
  {
    background: 'bg-zinc-50 dark:bg-zinc-900',
    border: 'border-zinc-200 dark:border-zinc-700',
    text: 'text-zinc-900 dark:text-zinc-100',
    connection: 'border-zinc-300 dark:border-zinc-600',
  },
  {
    background: 'bg-zinc-100 dark:bg-zinc-800',
    border: 'border-zinc-300 dark:border-zinc-600',
    text: 'text-zinc-800 dark:text-zinc-200',
    connection: 'border-zinc-400 dark:border-zinc-500',
  },
  {
    background: 'bg-zinc-200 dark:bg-zinc-700',
    border: 'border-zinc-400 dark:border-zinc-500',
    text: 'text-zinc-700 dark:text-zinc-300',
    connection: 'border-zinc-500 dark:border-zinc-400',
  },
  {
    background: 'bg-zinc-300 dark:bg-zinc-600',
    border: 'border-zinc-500 dark:border-zinc-400',
    text: 'text-zinc-600 dark:text-zinc-400',
    connection: 'border-zinc-600 dark:border-zinc-300',
  },
  {
    background: 'bg-zinc-400 dark:bg-zinc-500',
    border: 'border-zinc-600 dark:border-zinc-300',
    text: 'text-white dark:text-zinc-100',
    connection: 'border-zinc-700 dark:border-zinc-200',
  },
  {
    background: 'bg-zinc-500 dark:bg-zinc-400',
    border: 'border-zinc-700 dark:border-zinc-200',
    text: 'text-white dark:text-zinc-900',
    connection: 'border-zinc-800 dark:border-zinc-100',
  },
] as const;
const CONTAINER_COLORS = {
  background: 'bg-zinc-50 dark:bg-zinc-900',
  ring: 'ring-zinc-200 dark:ring-zinc-700',
  shadow: 'shadow-zinc-100 dark:shadow-zinc-800',
} as const;
const SPACING = {
  container: 'p-6',
  nodeGap: 'space-y-3',
  nodeMargin: 'mt-3',
  nodePadding: 'px-4 py-3',
  indent: 'mr-4',
  connector: 'w-4',
} as const;
const LAYOUT = {
  containerBase: 'w-full rounded-lg shadow ring-1',
  flexColumn: 'flex flex-col',
  flexRow: 'flex items-center',
  nodeBase: 'rounded-lg border transition-all duration-200',
  nodeParent: 'font-semibold',
  nodeLeaf: 'font-medium',
  connectionLine: 'border-l-2',
  connectionHorizontal: 'h-0.5',
  connectionHeight: 'h-6',
  connectionShort: 'h-3',
  hover: 'hover:shadow-md hover:scale-[1.01]',
} as const;
const getColorsForLevel = (level: number) => {
  return ZINC_SHADES[level % ZINC_SHADES.length];
};
export const CollapsibleTreeRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    return (
      <div
        className={cn(
          LAYOUT.containerBase,
          CONTAINER_COLORS.background,
          CONTAINER_COLORS.ring,
          CONTAINER_COLORS.shadow,
          SPACING.container
        )}
      >
        <TreeView nodes={nodes} />
      </div>
    );
  }
);
const TreeView = memo(
  ({ nodes, level = 0 }: { nodes: SummaryNode[]; level?: number }) => {
    const levelColors = getColorsForLevel(level);
    return (
      <div className={cn(LAYOUT.flexColumn, SPACING.nodeGap)}>
        {nodes.map((node, index) => (
          <div key={node.slug}>
            <div className={LAYOUT.flexRow}>
              {level > 0 && (
                <div className={LAYOUT.flexRow}>
                  {Array.from({ length: level }).map((_, i) => {
                    const connectionColors = getColorsForLevel(i);
                    return (
                      <div
                        key={i}
                        className={cn(
                          SPACING.indent,
                          LAYOUT.connectionHeight,
                          SPACING.connector,
                          LAYOUT.connectionLine,
                          connectionColors.connection,
                          index === nodes.length - 1 &&
                            i === level - 1 &&
                            LAYOUT.connectionShort
                        )}
                      />
                    );
                  })}
                  <div
                    className={cn(
                      LAYOUT.connectionHorizontal,
                      SPACING.connector,
                      levelColors.connection.replace('border-', 'bg-'),
                      index === nodes.length - 1 && LAYOUT.connectionShort
                    )}
                  />
                </div>
              )}
              {}
              <div
                className={cn(
                  LAYOUT.nodeBase,
                  LAYOUT.hover,
                  SPACING.nodePadding,
                  levelColors.background,
                  levelColors.border,
                  levelColors.text,
                  node.children.length > 0 ? LAYOUT.nodeParent : LAYOUT.nodeLeaf
                )}
              >
                <div className="flex items-center justify-between">
                  <span>{node.title}</span>
                  {node.children.length > 0 && (
                    <span
                      className={cn(
                        'ml-3 rounded-full px-2 py-1 text-xs',
                        'bg-white/20 dark:bg-black/20'
                      )}
                    >
                      {transliterate({
                        input: node.children.length,
                        mode: 'latin-numbers-to-arabic-digits',
                      })}
                    </span>
                  )}
                </div>
              </div>
            </div>
            {}
            {node.children.length > 0 && (
              <div className={SPACING.nodeMargin}>
                <TreeView nodes={node.children} level={level + 1} />
              </div>
            )}
          </div>
        ))}
      </div>
    );
  }
);

================
File: components/visualizations/renderers/tree/node-link-diagram-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as d3 from 'd3';
import { memo, useEffect, useRef, useState } from 'react';
type TreeNode = {
  id: string;
  name: string;
  children?: TreeNode[];
};
type TreeVisualizationProps = {
  nodes: SummaryNode[];
  height?: number;
};
export const NodeLinkDiagramRenderer = memo(
  ({ nodes, height = 600 }: TreeVisualizationProps) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [dimensions, setDimensions] = useState({ width: 0, height });
    useEffect(() => {
      if (!containerRef.current) return;
      const updateDimensions = () => {
        if (containerRef.current) {
          const { width } = containerRef.current.getBoundingClientRect();
          setDimensions({ width, height });
        }
      };
      updateDimensions();
      const resizeObserver = new ResizeObserver(updateDimensions);
      resizeObserver.observe(containerRef.current);
      return () => {
        if (containerRef.current) {
          resizeObserver.unobserve(containerRef.current);
        }
        resizeObserver.disconnect();
      };
    }, [height]);
    useEffect(() => {
      if (!containerRef.current || nodes.length === 0 || dimensions.width === 0)
        return;
      containerRef.current.innerHTML = '';
      const svg = d3
        .select(containerRef.current)
        .append('svg')
        .attr('width', '100%')
        .attr('height', dimensions.height)
        .attr('viewBox', `0 0 ${dimensions.width} ${dimensions.height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');
      const contentGroup = svg.append('g').attr('class', 'content');
      const transformNodes = (inputNodes: SummaryNode[]): TreeNode[] => {
        return inputNodes.map((node, index) => ({
          id: node.slug || `node-${index}`,
          name: node.title,
          children: node.children?.length
            ? transformNodes(node.children)
            : undefined,
        }));
      };
      const treeData: TreeNode[] = transformNodes(nodes);
      const root = d3.hierarchy(treeData[0]);
      const isMobile = window.innerWidth < 768;
      const treeLayout = d3
        .tree<TreeNode>()
        .size(
          isMobile
            ? [dimensions.height - 100, dimensions.width - 100]
            : [dimensions.height - 40, dimensions.width - 180]
        )
        .separation((a, b) => (a.parent === b.parent ? 1 : 1.2));
      treeLayout(root);
      contentGroup
        .selectAll('path.link')
        .data(root.links())
        .join('path')
        .attr('class', 'link')
        .attr(
          'd',
          d3
            .linkHorizontal<
              d3.HierarchyLink<TreeNode>,
              d3.HierarchyPointNode<TreeNode>
            >()
            .x((d) => d.y)
            .y((d) => d.x)
        )
        .style('fill', 'none')
        .style('stroke', '#555')
        .style('stroke-width', 1.5);
      const nodeGroups = contentGroup
        .selectAll('g.node')
        .data(root.descendants())
        .join('g')
        .attr('class', 'node')
        .attr('transform', (d) => `translate(${d.y},${d.x})`);
      nodeGroups
        .append('circle')
        .attr('r', 6)
        .style('fill', (d: d3.HierarchyNode<TreeNode>) =>
          d.children ? '#555' : '#999'
        )
        .style('stroke', '#fff')
        .style('stroke-width', 2);
      nodeGroups
        .append('text')
        .attr('dy', '-1.2em')
        .attr('x', 0)
        .style('text-anchor', 'middle')
        .text((d: d3.HierarchyNode<TreeNode>) => d.data.name)
        .style('font-size', isMobile ? '10px' : '12px')
        .style('font-family', 'sans-serif')
        .style('fill', '#333');
      nodeGroups
        .on(
          'mouseover',
          function (event: MouseEvent, d: d3.HierarchyNode<TreeNode>) {
            d3.select(this)
              .select('circle')
              .transition()
              .duration(200)
              .attr('r', 8)
              .style('fill', '#0066cc');
            d3.select(this).select('text').style('font-weight', 'bold');
          }
        )
        .on(
          'mouseout',
          function (event: MouseEvent, d: d3.HierarchyNode<TreeNode>) {
            d3.select(this)
              .select('circle')
              .transition()
              .duration(200)
              .attr('r', 6)
              .style('fill', d.children ? '#555' : '#999');
            d3.select(this).select('text').style('font-weight', 'normal');
          }
        );
      const zoom = d3
        .zoom()
        .scaleExtent([0.3, 3])
        .on('zoom', (event) => {
          contentGroup.attr('transform', event.transform);
        });
      svg.call(zoom as any);
      if (isMobile) {
        const rootNode = root;
        const rootX = rootNode.y || 0;
        const rootY = rootNode.x || 0;
        const scale = 1.0;
        const viewportCenterX = dimensions.width / 2;
        const viewportCenterY = dimensions.height / 2;
        const translateX = viewportCenterX - rootX * scale;
        const translateY = viewportCenterY - rootY * scale;
        svg.call(
          zoom.transform as any,
          d3.zoomIdentity.translate(translateX, translateY).scale(scale)
        );
      } else {
        const bounds = contentGroup.node()?.getBBox();
        if (bounds) {
          const scale = Math.min(
            dimensions.width / bounds.width,
            dimensions.height / bounds.height,
            0.9
          );
          const x = (dimensions.width - bounds.width * scale) / 2;
          const y = (dimensions.height - bounds.height * scale) / 2;
          svg.call(
            zoom.transform as any,
            d3.zoomIdentity.translate(x, y).scale(scale)
          );
        }
      }
    }, [nodes, dimensions.width, dimensions.height]);
    return (
      <div
        ref={containerRef}
        className="h-full w-full overflow-hidden rounded-lg bg-zinc-100 shadow ring-1 shadow-zinc-200 ring-zinc-200 dark:bg-zinc-900"
        style={{ minHeight: height }}
      />
    );
  }
);

================
File: components/visualizations/visualization-switcher.tsx
================
'use client';
import type React from 'react';
import type { SummaryNode } from '@/lib/content/types';
import {
  Boxes,
  GitBranch,
  Grid,
  Network,
  PieChart,
  Target,
  Terminal,
} from 'lucide-react';
import { memo, useMemo, useState } from 'react';
import { RadialSunburstRenderer } from './renderers/radial/radial-sunburst-renderer';
import { CirclePackRenderer } from './renderers/spatial/circle-pack-renderer';
import { GridLayoutRenderer } from './renderers/spatial/grid-layout-renderer';
import { NestedBoxesRenderer } from './renderers/spatial/nested-boxes-renderer';
import { ASCIITreeRenderer } from './renderers/tree/ascii-tree-renderer';
import { CollapsibleTreeRenderer } from './renderers/tree/collapsible-tree-renderer';
import { NodeLinkDiagramRenderer } from './renderers/tree/node-link-diagram-renderer';
type VisualizationType =
  | 'collapsible-tree'
  | 'ascii-tree'
  | 'nested-boxes'
  | 'grid-layout'
  | 'radial-sunburst'
  | 'node-diagram'
  | 'circle-pack';
interface VisualizationConfig {
  type: VisualizationType;
  label: string;
  icon: React.ReactNode;
  component: React.ComponentType<{ nodes: SummaryNode[] }>;
}
const VISUALIZATION_CONFIGS: VisualizationConfig[] = [
  {
    type: 'node-diagram',
    label: 'شبكة',
    icon: <Network className="h-4 w-4" />,
    component: NodeLinkDiagramRenderer,
  },
  {
    type: 'circle-pack',
    label: 'تراص',
    icon: <Target className="h-4 w-4" />,
    component: CirclePackRenderer,
  },
  {
    type: 'radial-sunburst',
    label: 'شعاع',
    icon: <PieChart className="h-4 w-4" />,
    component: RadialSunburstRenderer,
  },
  {
    type: 'ascii-tree',
    label: 'تفرع',
    icon: <Terminal className="h-4 w-4" />,
    component: ASCIITreeRenderer,
  },
  {
    type: 'collapsible-tree',
    label: 'سلسلة',
    icon: <GitBranch className="h-4 w-4" />,
    component: CollapsibleTreeRenderer,
  },
  {
    type: 'nested-boxes',
    label: 'وعاء',
    icon: <Boxes className="h-4 w-4" />,
    component: NestedBoxesRenderer,
  },
  {
    type: 'grid-layout',
    label: 'مصفوفة',
    icon: <Grid className="h-4 w-4" />,
    component: GridLayoutRenderer,
  },
];
export const VisualizationSwitcher = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    const [visualizationType, setVisualizationType] =
      useState<VisualizationType>(VISUALIZATION_CONFIGS[0].type);
    const currentVisualization = useMemo(() => {
      const config = VISUALIZATION_CONFIGS.find(
        (cfg) => cfg.type === visualizationType
      );
      if (config) {
        const Component = config.component;
        return <Component nodes={nodes} />;
      }
      return null;
    }, [visualizationType, nodes]);
    return (
      <>
        <VisualizationTypeSelector
          visualizationType={visualizationType}
          onVisualizationChange={setVisualizationType}
          configs={VISUALIZATION_CONFIGS}
        />
        <div className="transition-opacity duration-300">
          {currentVisualization}
        </div>
      </>
    );
  }
);
VisualizationSwitcher.displayName = 'VisualizationSwitcher';
const VisualizationTypeSelector = memo(
  ({
    visualizationType,
    onVisualizationChange,
    configs,
  }: {
    visualizationType: VisualizationType;
    onVisualizationChange: (type: VisualizationType) => void;
    configs: VisualizationConfig[];
  }) => {
    return (
      <div className="flex flex-wrap gap-2">
        {configs.map((config) => (
          <button
            key={config.type}
            onClick={() => onVisualizationChange(config.type)}
            className={`flex cursor-pointer items-center gap-2 rounded-md px-3 py-1.5 text-sm transition-colors ${
              visualizationType === config.type
                ? 'bg-zinc-200 text-zinc-900 dark:bg-zinc-700 dark:text-zinc-100'
                : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700'
            }`}
            aria-label={`تغيير إلى ${config.label}`}
            title={`تغيير إلى ${config.label}`}
          >
            {config.icon}
            <span className="hidden sm:inline">{config.label}</span>
          </button>
        ))}
      </div>
    );
  }
);
VisualizationTypeSelector.displayName = 'VisualizationTypeSelector';

================
File: config/env.ts
================
export const isDev = process.env.NODE_ENV === 'development';

================
File: config/site.ts
================
export const SITE_URL = 'https://usearabic.com';

================
File: constants/arabic-to-english-map.ts
================
export const arabicToEnglishMap: Record<string, string> = {
  ا: 'a',
  ب: 'b',
  ت: 't',
  ث: 'th',
  ج: 'j',
  ح: 'h',
  خ: 'kh',
  د: 'd',
  ذ: 'dh',
  ر: 'r',
  ز: 'z',
  س: 's',
  ش: 'sh',
  ص: 's',
  ض: 'd',
  ط: 't',
  ظ: 'z',
  ع: 'a',
  غ: 'gh',
  ف: 'f',
  ق: 'q',
  ك: 'k',
  ل: 'l',
  م: 'm',
  ن: 'n',
  ه: 'h',
  و: 'w',
  ي: 'y',
  ء: '',
  ى: 'a',
  ئ: 'y',
  ؤ: 'w',
  ة: 'h',
  إ: 'i',
  أ: 'a',
  آ: 'aa',
  'ٓ': '',
  // numbers
  '٠': '0',
  '١': '1',
  '٢': '2',
  '٣': '3',
  '٤': '4',
  '٥': '5',
  '٦': '6',
  '٧': '7',
  '٨': '8',
  '٩': '9',
};

================
File: hooks/use-mobile.ts
================
import * as React from 'react';
const MOBILE_BREAKPOINT = 768;
export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined
  );
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);
  return !!isMobile;
}

================
File: hooks/use-sidebar.tsx
================
import type { SummaryNode } from '@/lib/content/types';
import { usePathname } from 'next/navigation';
import { useCallback, useMemo, useState } from 'react';
export function useSidebar(summaryTree: SummaryNode[]) {
  const pathname = usePathname();
  const [expandedSections, setExpandedSections] = useState<
    Record<string, boolean>
  >(() => ({}));
  const toggleSection = useCallback((path: string) => {
    setExpandedSections((prev) => ({
      ...prev,
      [path]: !prev[path],
    }));
  }, []);
  const isCurrentPage = useCallback(
    (fullPath: string) => {
      if (fullPath === '__home') return pathname === '/';
      return pathname === `/learn/${fullPath}/`;
    },
    [pathname]
  );
  const flatItems = useMemo(() => {
    const walk = (
      nodes: SummaryNode[],
      level = 0
    ): { node: SummaryNode; level: number }[] => {
      let result: { node: SummaryNode; level: number }[] = [];
      for (const node of nodes) {
        result.push({ node, level });
        result = result.concat(walk(node.children, level + 1));
      }
      return result;
    };
    return walk(summaryTree);
  }, [summaryTree]);
  const getAllPaths = useCallback((nodes: SummaryNode[]): string[] => {
    let paths: string[] = [];
    for (const node of nodes) {
      const fullPath = [...node.parentPath, node.slug].join('/');
      if (node.children.length > 0) {
        paths.push(fullPath);
        paths = paths.concat(getAllPaths(node.children));
      }
    }
    return paths;
  }, []);
  const expandAll = useCallback(() => {
    const all = getAllPaths(summaryTree);
    const expanded: Record<string, boolean> = {};
    all.forEach((p) => (expanded[p] = true));
    setExpandedSections(expanded);
  }, [summaryTree, getAllPaths]);
  const collapseAll = useCallback(() => {
    setExpandedSections({});
  }, []);
  const toggleAll = useCallback(() => {
    const allPaths = getAllPaths(summaryTree);
    const someExpanded = allPaths.some((path) => expandedSections[path]);
    if (someExpanded) collapseAll();
    else expandAll();
  }, [expandedSections, collapseAll, expandAll, getAllPaths, summaryTree]);
  return useMemo(
    () => ({
      flatItems,
      expandedSections,
      toggleSection,
      isCurrentPage,
      toggleAll,
    }),
    [flatItems, expandedSections, toggleSection, isCurrentPage, toggleAll]
  );
}

================
File: lib/content/core/content-loader.ts
================
import fs from 'fs/promises';
import matter from 'gray-matter';
import path from 'path';
import { remark } from 'remark';
import html from 'remark-html';
import { normalizeTitle } from '../utils/path-utils';
export interface PageSpecificContent {
  pageTitle: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml: string;
  frontmatter: Record<string, any>;
}
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
export async function loadPageSpecificContent(
  slugPath: string[]
): Promise<PageSpecificContent | null> {
  if (slugPath.length === 0) return null;
  const markdownFilePath = path.join(
    CONTENT_BASE_PATH,
    ...slugPath,
    'index.md'
  );
  try {
    const rawMarkdown = await fs.readFile(markdownFilePath, 'utf-8');
    const { data: frontmatter, content: markdownContent } = matter(rawMarkdown);
    const processedHtml = await remark().use(html).process(markdownContent);
    const currentDirSlug = slugPath.at(-1)!;
    const title = frontmatter.title ?? normalizeTitle(currentDirSlug);
    return {
      pageTitle: title,
      pageOrder: frontmatter.order,
      excerpt: frontmatter.excerpt,
      contentHtml: processedHtml.toString(),
      frontmatter,
    };
  } catch (error) {
    return null;
  }
}

================
File: lib/content/core/landing-page-loader.ts
================
import { buildSync } from "esbuild";
import fs from "fs/promises";
import Module from "module";
import path from "path";
import type {
  BookLandingConfigFunction,
  BookLandingPageConfig,
  SummaryNode,
} from "../types";
const CONTENT_BASE_PATH = path.join(process.cwd(), "content");
const LANDING_CONFIG_FILENAME = "landing.ts";
function executeJavaScriptModule(jsCode: string, filename: string): unknown {
  const mod = new Module(filename, module.parent);
  mod._compile(jsCode, filename);
  return mod.exports;
}
export async function loadBookLandingPageConfigForBuild(
  bookNodeSlugPath: string[],
  bookChapters: SummaryNode[],
): Promise<BookLandingPageConfig | null> {
  if (bookNodeSlugPath.length === 0) {
    return null;
  }
  const landingConfigPath = path.join(
    CONTENT_BASE_PATH,
    ...bookNodeSlugPath,
    LANDING_CONFIG_FILENAME,
  );
  try {
    const tsCode = await fs.readFile(landingConfigPath, "utf-8");
    const result = buildSync({
      stdin: {
        contents: tsCode,
        resolveDir: path.dirname(landingConfigPath),
        loader: "ts",
      },
      bundle: false,
      format: "cjs",
      write: false,
      tsconfig: path.join(process.cwd(), "tsconfig.json"),
    });
    if (result.outputFiles && result.outputFiles.length > 0) {
      const jsCode = result.outputFiles[0].text;
      const exportedModule = executeJavaScriptModule(
        jsCode,
        landingConfigPath,
      );
      const configFunction =
        typeof exportedModule === "function"
          ? (exportedModule as BookLandingConfigFunction)
          :
            typeof exportedModule?.default === "function"
            ?
              (exportedModule.default as BookLandingConfigFunction)
            : null;
      if (configFunction) {
        const config = configFunction(bookChapters);
        if (config && Array.isArray(config.sections)) {
          return JSON.parse(JSON.stringify(config)) as BookLandingPageConfig;
        }
        console.warn(
          `Landing config function at ${landingConfigPath} (after transpilation) did not return a valid config object.`,
        );
      } else {
        console.warn(
          `Default export in landing config ${landingConfigPath} (after transpilation) is not a function.`,
        );
      }
    } else {
      console.warn(
        `esbuild failed to produce output for ${landingConfigPath}. Errors: ${result.errors.join(", ")}. Warnings: ${result.warnings.join(", ")}`,
      );
    }
    return null;
  } catch (error) {
    const err = error as NodeJS.ErrnoException & { errors?: any[] };
    if (err.code === "ENOENT") {
    } else if (err.errors && Array.isArray(err.errors)) {
      console.warn(
        `Error transpiling ${landingConfigPath} with esbuild: ${err.errors.map((e: any) => e.text).join("\n")}`,
      );
    } else {
      console.warn(
        `Could not load or parse ${LANDING_CONFIG_FILENAME} for book at ${bookNodeSlugPath.join("/")}. Path: ${landingConfigPath}. Error: ${err.message}`,
      );
    }
    return null;
  }
}

================
File: lib/content/core/tree-builder.ts
================
import fs from 'fs';
import path from 'path';
import type { SummaryNode } from '../types';
import {
  normalizeSlug,
  normalizeTitle,
  parseDirectoryName,
} from '../utils/path-utils';
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
let summaryTreeCache: SummaryNode[] | null = null;
function isPrefixMandatoryForDepth(depth: number): boolean {
  return depth >= 3;
}
async function scanContentDirectory(
  currentDirPath: string,
  parentSlugPath: string[] = [],
  currentDepth: number = 0
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(currentDirPath, {
    withFileTypes: true,
  });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue;
    const fullEntryPath = path.join(currentDirPath, entry.name);
    if (entry.isDirectory()) {
      const { order: dirOrder, name: unprefixedDirName } = parseDirectoryName({
        directoryName: entry.name,
        isDirectoryPrefixMandatory: isPrefixMandatoryForDepth(currentDepth),
      });
      const slug = normalizeSlug(unprefixedDirName);
      const title = normalizeTitle(unprefixedDirName);
      const children = await scanContentDirectory(
        fullEntryPath,
        [...parentSlugPath, slug],
        currentDepth + 1
      );
      items.push({
        title,
        slug,
        order: dirOrder,
        parentPath: parentSlugPath,
        children,
      });
    }
  }
  return items.sort((a, b) => {
    if (a.order !== b.order) {
      return a.order - b.order;
    }
    return a.title.localeCompare(b.title);
  });
}
export async function buildContentSummaryTree(): Promise<SummaryNode[]> {
  if (summaryTreeCache) return summaryTreeCache;
  summaryTreeCache = await scanContentDirectory(CONTENT_BASE_PATH);
  return summaryTreeCache;
}
export function clearSummaryTreeCache(): void {
  summaryTreeCache = null;
}

================
File: lib/content/query/find-node.ts
================
import type { SummaryNode } from '../types';
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[]
): SummaryNode | null {
  let currentNodes: SummaryNode[] = tree;
  let foundNode: SummaryNode | null = null;
  for (const slug of slugPath) {
    const nextNode = currentNodes.find((node) => node.slug === slug);
    if (!nextNode) return null;
    foundNode = nextNode;
    currentNodes = nextNode.children;
  }
  return foundNode;
}

================
File: lib/content/query/get-all-paths.ts
================
import { buildContentSummaryTree } from '../core/tree-builder';
import type { SummaryNode } from '../types';
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildContentSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, currentPath: string[] = []) {
    const newPath = [...currentPath, node.slug];
    slugs.push(newPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, newPath));
    }
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: lib/content/query/get-breadcrumbs.ts
================
import type { SummaryNode } from '../types';
import { findDeepestNode } from './find-node';
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[]
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  if (node.parentPath.length === 0) {
    return breadcrumbs;
  }
  let currentParentPath = node.parentPath;
  while (currentParentPath.length > 0) {
    const parentNode = findDeepestNode(tree, currentParentPath);
    if (parentNode) {
      breadcrumbs.unshift({ title: parentNode.title, slug: parentNode.slug });
    }
    currentParentPath = currentParentPath.slice(0, -1);
  }
  return breadcrumbs;
}

================
File: lib/content/query/get-leaf-nodes.ts
================
import type { LeafNodeInfo, SummaryNode } from '../types';
export function getLeafNodes(tree: SummaryNode[]): LeafNodeInfo[] {
  const leaves: LeafNodeInfo[] = [];
  function walk(node: SummaryNode, currentPath: string[] = []) {
    const fullPathSegments = [...currentPath, node.slug];
    if (node.children.length === 0) {
      leaves.push({
        title: node.title,
        fullSlugPath: fullPathSegments.join('/'),
      });
    } else {
      node.children.forEach((child) => walk(child, fullPathSegments));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: lib/content/query/get-node-path.ts
================
import type { SummaryNode } from '../types';
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join('/');
}

================
File: lib/content/utils/path-utils.ts
================
import { transliterate } from '../../text/transliteration';
export interface ParsedNameInfo {
  order: number;
  name: string;
  isPrefixed: boolean;
}
const DEFAULT_ORDER = 0;
export function parseDirectoryName({
  directoryName,
  isDirectoryPrefixMandatory,
}: {
  directoryName: string;
  isDirectoryPrefixMandatory: boolean;
}): ParsedNameInfo {
  if (/\.[a-z0-9]+$/i.test(directoryName)) {
    throw new Error(
      `Directory name "${directoryName}" must not contain a file extension.`
    );
  }
  const match = directoryName.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (match) {
    const [, numericPrefix, remainder] = match;
    const order = parseInt(
      transliterate({ input: numericPrefix, mode: 'arabic-to-latin' }),
      10
    );
    if (isNaN(order)) {
      throw new Error(
        `Invalid numeric prefix in directory name: "${directoryName}". Could not parse "${numericPrefix}" to a number.`
      );
    }
    return {
      order,
      name: remainder,
      isPrefixed: true,
    };
  }
  if (isDirectoryPrefixMandatory) {
    throw new Error(
      `Invalid directory name format: "${directoryName}". Expected format: <number>_<name> as prefix is mandatory at this level.`
    );
  }
  return {
    order: DEFAULT_ORDER,
    name: directoryName,
    isPrefixed: false,
  };
}
export function normalizeSlug(raw: string): string {
  const base = raw.replace(/\.md$/, '');
  const arabicOnly = base.replace(/[^\u0600-\u06FF_]/g, '');
  return transliterate({
    input: arabicOnly,
    mode: 'arabic-to-latin',
  }).replace(/_+/g, '-');
}
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, '');
  return arabicOnly.replace(/_+/g, ' ');
}

================
File: lib/content/utils/tree-utils.ts
================
import type { SummaryNode } from '../types';
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  currentPath: string[] = [],
  level: number = 0
): void {
  for (const node of nodes) {
    callback(node, currentPath, level);
    if (node.children && node.children.length > 0) {
      walkTree(node.children, callback, [...currentPath, node.slug], level + 1);
    }
  }
}
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: lib/content/api.ts
================
import { loadPageSpecificContent } from "./core/content-loader";
import { loadBookLandingPageConfig } from "./core/landing-page-loader";
import {
  buildContentSummaryTree,
  clearSummaryTreeCache as clearInternalSummaryTreeCache,
} from "./core/tree-builder";
import { findDeepestNode } from "./query/find-node";
import type { ContentNode, SummaryNode } from "./types";
export { getTreeSlugs as getAllContentPaths } from "./query/get-all-paths";
export { getBreadcrumbs } from "./query/get-breadcrumbs";
export { getLeafNodes } from "./query/get-leaf-nodes";
export { getNodeSlugPath } from "./query/get-node-path";
export { flattenTree, walkTree } from "./utils/tree-utils";
const BOOK_DEPTH = 2;
export async function getSummaryTree(): Promise<SummaryNode[]> {
  return buildContentSummaryTree();
}
export async function getContentNodeBySlugPath(
  slugPath: string[],
): Promise<ContentNode | null> {
  const tree = await getSummaryTree();
  const summaryNode = findDeepestNode(tree, slugPath);
  if (!summaryNode) {
    return null;
  }
  const pageContent = await loadPageSpecificContent(slugPath);
  const contentNode: ContentNode = {
    ...summaryNode,
  };
  if (pageContent) {
    contentNode.pageTitle = pageContent.pageTitle;
    contentNode.pageOrder = pageContent.pageOrder;
    contentNode.excerpt = pageContent.excerpt;
    contentNode.contentHtml = pageContent.contentHtml;
    contentNode.frontmatter = pageContent.frontmatter;
  }
  const nodeDepth = summaryNode.parentPath.length;
  if (nodeDepth === BOOK_DEPTH) {
    const landingConfig = await loadBookLandingPageConfig(
      slugPath,
      summaryNode.children,
    );
    if (landingConfig) {
      contentNode.landingPageConfig = landingConfig;
    }
  }
  return contentNode;
}
export function clearSummaryCache(): void {
  clearInternalSummaryTreeCache();
}

================
File: lib/content/types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type LeafNodeInfo = {
  title: string;
  fullSlugPath: string;
};
type BookLandingSectionBase = {
  title: string;
};
export type TextLandingSection = BookLandingSectionBase & {
  type: "text";
  content: string[];
};
export type VisualizationLandingSection = BookLandingSectionBase & {
  type: "visualization";
  nodes: SummaryNode[];
};
export type BookLandingSection =
  | TextLandingSection
  | VisualizationLandingSection;
export interface BookLandingPageConfig {
  sections: BookLandingSection[];
}
export type BookLandingConfigFunction = (
  bookChapters: SummaryNode[],
) => BookLandingPageConfig;
export type ContentNode = SummaryNode & {
  pageTitle?: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml?: string;
  frontmatter?: Record<string, any>;
  landingPageConfig?: BookLandingPageConfig;
};

================
File: lib/styles/tailwind-utils.ts
================
import clsx, { type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

================
File: lib/text/ascii-tree-generator.ts
================
import type { SummaryNode } from '../content/types';
export function generateASCIITree(
  docs: SummaryNode[],
  options: {
    indent?: string;
    splitLevel?: number;
    splitString?: string;
    currentLevel?: number;
  } = {}
): string {
  const {
    indent = '',
    splitLevel = Infinity,
    splitString = '',
    currentLevel = 0,
  } = options;
  return docs
    .map((node, index) => {
      const isLast = index === docs.length - 1;
      const branch = isLast ? '└── ' : '├── ';
      const nextIndent = indent + (isLast ? '    ' : '│   ');
      const label = node.title.replace(/_/g, ' ');
      let output = '';
      if (currentLevel === splitLevel && label !== splitString) {
        return '';
      }
      output += `${indent}${branch}${label}\n`;
      if (node.children.length > 0) {
        output += generateASCIITree(node.children, {
          indent: nextIndent,
          splitLevel,
          splitString,
          currentLevel: currentLevel + 1,
        });
      }
      return output;
    })
    .join('');
}

================
File: lib/text/transliteration.ts
================
type ArabicToLatinOptions = {
  mode: 'arabic-to-latin';
  input: string;
};
type LatinToArabicDigitsOptions = {
  mode: 'latin-to-arabic-digits';
  input: string;
};
type LatinNumbersToArabicDigitsOptions = {
  mode: 'latin-numbers-to-arabic-digits';
  input: string | number;
};
type LatinToArabicOptions = {
  mode: 'latin-to-arabic';
  input: string;
};
type Options =
  | ArabicToLatinOptions
  | LatinToArabicDigitsOptions
  | LatinNumbersToArabicDigitsOptions
  | LatinToArabicOptions;
const LATIN_TO_ARABIC_DIGITS: Record<string, string> = {
  '0': '٠',
  '1': '١',
  '2': '٢',
  '3': '٣',
  '4': '٤',
  '5': '٥',
  '6': '٦',
  '7': '٧',
  '8': '٨',
  '9': '٩',
};
const ARABIC_TO_LATIN_DIGITS: Record<string, string> = Object.fromEntries(
  Object.entries(LATIN_TO_ARABIC_DIGITS).map(([w, a]) => [a, w])
);
const digitSet = new Set(Object.keys(LATIN_TO_ARABIC_DIGITS));
const ARABIC_TO_LATIN_LETTERS: Record<string, string> = {
  ا: 'a',
  ب: 'b',
  ت: 't',
  ث: 'th',
  ج: 'j',
  ح: 'h',
  خ: 'kh',
  د: 'd',
  ذ: 'dh',
  ر: 'r',
  ز: 'z',
  س: 's',
  ش: 'sh',
  ص: 's',
  ض: 'd',
  ط: 't',
  ظ: 'z',
  ع: 'a',
  غ: 'gh',
  ف: 'f',
  ق: 'q',
  ك: 'k',
  ل: 'l',
  م: 'm',
  ن: 'n',
  ه: 'h',
  و: 'w',
  ي: 'y',
  ء: '',
  ى: 'a',
  ئ: 'y',
  ؤ: 'w',
  ة: 'h',
  إ: 'i',
  أ: 'a',
  آ: 'aa',
  'ٓ': '',
  'َ': 'a',
  'ُ': 'u',
  'ِ': 'i',
  'ّ': '',
  'ْ': '',
  'ً': 'an',
  'ٌ': 'un',
  'ٍ': 'in',
};
const ARABIC_TO_LATIN_MAP = {
  ...ARABIC_TO_LATIN_LETTERS,
  ...ARABIC_TO_LATIN_DIGITS,
};
const LATIN_TO_ARABIC_LETTERS: Record<string, string> = Object.fromEntries(
  Object.entries(ARABIC_TO_LATIN_LETTERS)
    .filter(([_arb, lat]) => lat.length > 0)
    .map(([arb, lat]) => [lat, arb])
);
const LATIN_LETTER_KEYS = Object.keys(LATIN_TO_ARABIC_LETTERS).sort(
  (a, b) => b.length - a.length
);
export function transliterate(options: Options): string {
  const { mode } = options;
  const inputStr = options.input.toString();
  switch (mode) {
    case 'arabic-to-latin':
      return [...inputStr].map((ch) => ARABIC_TO_LATIN_MAP[ch] ?? ch).join('');
    case 'latin-to-arabic-digits':
      return inputStr.replace(/[0-9]/g, (d) => LATIN_TO_ARABIC_DIGITS[d]);
    case 'latin-numbers-to-arabic-digits':
      if (!/^\d+$/.test(inputStr)) {
        throw new Error(
          "Mode 'latin-numbers-to-arabic-digits' requires digits only."
        );
      }
      return [...inputStr].map((d) => LATIN_TO_ARABIC_DIGITS[d]).join('');
    case 'latin-to-arabic':
      return transliterateLatinToArabic(inputStr);
    default:
      const _exhaustive: never = mode;
      throw new Error(`Unsupported mode: ${_exhaustive}`);
  }
}
function transliterateLatinToArabic(s: string): string {
  let result = '';
  let i = 0;
  const N = s.length;
  const lower = s.toLowerCase();
  while (i < N) {
    let matched = false;
    for (const key of LATIN_LETTER_KEYS) {
      if (lower.startsWith(key, i)) {
        result += LATIN_TO_ARABIC_LETTERS[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const ch = s[i];
    if (digitSet.has(ch)) {
      result += LATIN_TO_ARABIC_DIGITS[ch];
    } else {
      result += ch;
    }
    i++;
  }
  return result;
}

================
File: lib/output.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
content/
  core/
    build-summary-tree.ts
    get-content-node.ts
  query/
    find-node.ts
    get-all-paths.ts
    get-breadcrumbs.ts
    get-leaf-nodes.ts
    get-node-path.ts
  utils/
    normalize-slug.ts
    normalize-title.ts
    parse-filename-order.ts
    tree-flattener.ts
    tree-walker.ts
  types.ts
styles/
  tailwind.ts
text/
  ascii-generator.ts
  transliteration.ts

================================================================
Files
================================================================

================
File: content/core/build-summary-tree.ts
================
import fs from "fs";
import path from "path";
import type { SummaryNode } from "../types";
import { normalizeSlug } from "../utils/normalize-slug";
import { normalizeTitle } from "../utils/normalize-title";
import { parseFilenameOrder } from "../utils/parse-filename-order";
const MARKDOWN_BASE_PATH = path.join(process.cwd(), "content");
let _cache: SummaryNode[] | null = null;
async function walkDir(
  dir: string,
  parentPath: string[] = []
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(dir, { withFileTypes: true });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    const fullPath = path.join(dir, entry.name);
    const isMarkdownFile = entry.name.endsWith(".md");
    const filenameWithoutExtension = isMarkdownFile
      ? entry.name.replace(/\.md$/, "")
      : entry.name;
    const { fileOrder, rawUnprefixedFilename } = parseFilenameOrder({
      filename: filenameWithoutExtension,
    });
    if (entry.isDirectory()) {
      const children = await walkDir(fullPath, [
        ...parentPath,
        normalizeSlug(rawUnprefixedFilename),
      ]);
      items.push({
        title: normalizeTitle(rawUnprefixedFilename),
        slug: normalizeSlug(rawUnprefixedFilename),
        order: fileOrder,
        parentPath,
        children,
      });
    } else if (isMarkdownFile) {
      continue;
    }
  }
  return items.sort((a, b) => a.order - b.order);
}
export async function buildSummaryTree(): Promise<SummaryNode[]> {
  if (_cache) return _cache;
  _cache = await walkDir(MARKDOWN_BASE_PATH);
  return _cache;
}

================
File: content/core/get-content-node.ts
================
import fs from "fs/promises";
import matter from "gray-matter";
import path from "path";
import { remark } from "remark";
import html from "remark-html";
import type { ContentNode } from "../types";
import { normalizeSlug } from "../utils/normalize-slug";
import { normalizeTitle } from "../utils/normalize-title";
import { parseFilenameOrder } from "../utils/parse-filename-order";
const MARKDOWN_BASE_PATH = path.join(process.cwd(), "content");
export async function getContentNode(
  slugPath: string[]
): Promise<ContentNode | null> {
  if (slugPath.length === 0) return null;
  const normalizedSlugs = slugPath.map(normalizeSlug);
  const filename = `${normalizedSlugs.at(-1)}.md`;
  const filePath = path.join(
    MARKDOWN_BASE_PATH,
    ...normalizedSlugs.slice(0, -1),
    filename
  );
  try {
    const raw = await fs.readFile(filePath, "utf-8");
    const { data, content } = matter(raw);
    const processed = await remark().use(html).process(content);
    const slug = normalizedSlugs.at(-1)!;
    return {
      title: data.title ?? normalizeTitle(slug),
      slug,
      order: data.order ?? parseFilenameOrder({ filename: slug }).fileOrder,
      parentPath: normalizedSlugs.slice(0, -1),
      children: [],
      excerpt: data.excerpt,
      contentHtml: processed.toString(),
    };
  } catch (error) {
    return null;
  }
}

================
File: content/query/find-node.ts
================
import type { SummaryNode } from "../types";
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[]
): SummaryNode | null {
  let current: SummaryNode | undefined;
  for (const slug of slugPath) {
    current = (current?.children ?? tree).find((node) => node.slug === slug);
    if (!current) return null;
  }
  return current ?? null;
}

================
File: content/query/get-all-paths.ts
================
import { buildSummaryTree } from "../core/build-summary-tree";
import type { SummaryNode } from "../types";
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, path: string[] = []) {
    const currentPath = [...path, node.slug];
    slugs.push(currentPath);
    node.children.forEach((child) => traverse(child, currentPath));
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: content/query/get-breadcrumbs.ts
================
import type { SummaryNode } from "../types";
import { findDeepestNode } from "./find-node";
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[]
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  let current = findDeepestNode(tree, node.parentPath);
  while (current) {
    breadcrumbs.unshift({ title: current.title, slug: current.slug });
    current = findDeepestNode(tree, current.parentPath);
  }
  return breadcrumbs;
}

================
File: content/query/get-leaf-nodes.ts
================
import type { LeafNode, SummaryNode } from "../types";
export function getLeafNodes(tree: SummaryNode[]): LeafNode[] {
  const leaves: LeafNode[] = [];
  function walk(node: SummaryNode, path: string[] = []) {
    const fullPath = [...path, node.slug];
    if (node.children.length === 0) {
      leaves.push({ title: node.title, slug: fullPath.join("/") });
    } else {
      node.children.forEach((child) => walk(child, fullPath));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: content/query/get-node-path.ts
================
import { SummaryNode } from "../types";
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join("/");
}

================
File: content/utils/normalize-slug.ts
================
import { transliterate } from "@/lib/text/transliteration";
export function normalizeSlug(raw: string): string {
  const base = raw.replace(/\.md$/, "");
  const arabicOnly = base.replace(/[^\u0600-\u06FF_]/g, "");
  return transliterate({
    input: arabicOnly,
    mode: "arabic-to-latin",
  }).replace(/_+/g, "-");
}

================
File: content/utils/normalize-title.ts
================
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, "");
  return arabicOnly.replace(/_+/g, " ");
}

================
File: content/utils/parse-filename-order.ts
================
import { transliterate } from "@/lib/text/transliteration";
export function parseFilenameOrder({ filename }: { filename: string }): {
  fileOrder: number;
  rawUnprefixedFilename: string;
} {
  if (/\.[a-z0-9]+$/i.test(filename)) {
    throw new Error(
      `Filename "${filename}" must not contain a file extension.`
    );
  }
  const match = filename.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (!match) {
    throw new Error(
      `Invalid filename format: "${filename}". Expected format: <number>_<name>`
    );
  }
  const [, numericPrefix, remainder] = match;
  const fileOrder = parseInt(
    transliterate({ input: numericPrefix, mode: "arabic-to-latin" }),
    10
  );
  if (isNaN(fileOrder)) {
    throw new Error(
      `Invalid numeric prefix in filename: "${filename}". Could not parse "${numericPrefix}" to a number.`
    );
  }
  return {
    fileOrder,
    rawUnprefixedFilename: remainder,
  };
}

================
File: content/utils/tree-flattener.ts
================
import type { SummaryNode } from "../types";
import { walkTree } from "./tree-walker";
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: content/utils/tree-walker.ts
================
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  path: string[] = [],
  level: number = 0
): void {
  for (const node of nodes) {
    callback(node, path, level);
    if (node.children.length > 0) {
      walkTree(node.children, callback, [...path, node.slug], level + 1);
    }
  }
}

================
File: content/types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type ContentNode = SummaryNode & {
  excerpt?: string;
  contentHtml: string;
};
export type LeafNode = BaseNode;

================
File: styles/tailwind.ts
================
import clsx, { type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

================
File: text/ascii-generator.ts
================
import type { SummaryNode } from "../content/types";
export function generateASCIITree(
  docs: SummaryNode[],
  options: {
    indent?: string;
    splitLevel?: number;
    splitString?: string;
    currentLevel?: number;
  } = {}
): string {
  const {
    indent = "",
    splitLevel = Infinity,
    splitString = "",
    currentLevel = 0,
  } = options;
  return docs
    .map((node, index) => {
      const isLast = index === docs.length - 1;
      const branch = isLast ? "└── " : "├── ";
      const nextIndent = indent + (isLast ? "    " : "│   ");
      const label = node.title.replace(/_/g, " ");
      let output = "";
      if (currentLevel === splitLevel && label !== splitString) {
        return "";
      }
      output += `${indent}${branch}${label}\n`;
      if (node.children.length > 0) {
        output += generateASCIITree(node.children, {
          indent: nextIndent,
          splitLevel,
          splitString,
          currentLevel: currentLevel + 1,
        });
      }
      return output;
    })
    .join("");
}

================
File: text/transliteration.ts
================
type ArabicToLatinOptions = {
  mode: "arabic-to-latin";
  input: string;
};
type LatinToArabicDigitsOptions = {
  mode: "latin-to-arabic-digits";
  input: string;
};
type LatinNumbersToArabicDigitsOptions = {
  mode: "latin-numbers-to-arabic-digits";
  input: string | number;
};
type LatinToArabicOptions = {
  mode: "latin-to-arabic";
  input: string;
};
type Options =
  | ArabicToLatinOptions
  | LatinToArabicDigitsOptions
  | LatinNumbersToArabicDigitsOptions
  | LatinToArabicOptions;
const LATIN_TO_ARABIC_DIGITS: Record<string, string> = {
  "0": "٠",
  "1": "١",
  "2": "٢",
  "3": "٣",
  "4": "٤",
  "5": "٥",
  "6": "٦",
  "7": "٧",
  "8": "٨",
  "9": "٩",
};
const ARABIC_TO_LATIN_DIGITS: Record<string, string> = Object.fromEntries(
  Object.entries(LATIN_TO_ARABIC_DIGITS).map(([w, a]) => [a, w])
);
const digitSet = new Set(Object.keys(LATIN_TO_ARABIC_DIGITS));
const ARABIC_TO_LATIN_LETTERS: Record<string, string> = {
  ا: "a",
  ب: "b",
  ت: "t",
  ث: "th",
  ج: "j",
  ح: "h",
  خ: "kh",
  د: "d",
  ذ: "dh",
  ر: "r",
  ز: "z",
  س: "s",
  ش: "sh",
  ص: "s",
  ض: "d",
  ط: "t",
  ظ: "z",
  ع: "a",
  غ: "gh",
  ف: "f",
  ق: "q",
  ك: "k",
  ل: "l",
  م: "m",
  ن: "n",
  ه: "h",
  و: "w",
  ي: "y",
  ء: "",
  ى: "a",
  ئ: "y",
  ؤ: "w",
  ة: "h",
  إ: "i",
  أ: "a",
  آ: "aa",
  "ٓ": "",
  "َ": "a",
  "ُ": "u",
  "ِ": "i",
  "ّ": "",
  "ْ": "",
  "ً": "an",
  "ٌ": "un",
  "ٍ": "in",
};
const ARABIC_TO_LATIN_MAP = {
  ...ARABIC_TO_LATIN_LETTERS,
  ...ARABIC_TO_LATIN_DIGITS,
};
const LATIN_TO_ARABIC_LETTERS: Record<string, string> = Object.fromEntries(
  Object.entries(ARABIC_TO_LATIN_LETTERS)
    .filter(([_arb, lat]) => lat.length > 0)
    .map(([arb, lat]) => [lat, arb])
);
const LATIN_LETTER_KEYS = Object.keys(LATIN_TO_ARABIC_LETTERS).sort(
  (a, b) => b.length - a.length
);
export function transliterate(options: Options): string {
  const { mode } = options;
  const inputStr = options.input.toString();
  switch (mode) {
    case "arabic-to-latin":
      return [...inputStr].map((ch) => ARABIC_TO_LATIN_MAP[ch] ?? ch).join("");
    case "latin-to-arabic-digits":
      return inputStr.replace(/[0-9]/g, (d) => LATIN_TO_ARABIC_DIGITS[d]);
    case "latin-numbers-to-arabic-digits":
      if (!/^\d+$/.test(inputStr)) {
        throw new Error(
          "Mode 'latin-numbers-to-arabic-digits' requires digits only."
        );
      }
      return [...inputStr].map((d) => LATIN_TO_ARABIC_DIGITS[d]).join("");
    case "latin-to-arabic":
      return transliterateLatinToArabic(inputStr);
    default:
      const _exhaustive: never = mode;
      throw new Error(`Unsupported mode: ${_exhaustive}`);
  }
}
function transliterateLatinToArabic(s: string): string {
  let result = "";
  let i = 0;
  const N = s.length;
  const lower = s.toLowerCase();
  while (i < N) {
    let matched = false;
    for (const key of LATIN_LETTER_KEYS) {
      if (lower.startsWith(key, i)) {
        result += LATIN_TO_ARABIC_LETTERS[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const ch = s[i];
    if (digitSet.has(ch)) {
      result += LATIN_TO_ARABIC_DIGITS[ch];
    } else {
      result += ch;
    }
    i++;
  }
  return result;
}



================================================================
End of Codebase
================================================================

================
File: providers/theme-provider.tsx
================
'use client';
import { ThemeProvider as NextThemesProvider } from 'next-themes';
import * as React from 'react';
export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}



================================================================
End of Codebase
================================================================

================
File: .prettierignore
================
node_modules
.next
out
build
dist
coverage
*.log
package-lock.json
yarn.lock
pnpm-lock.yaml
public/

================
File: src/components/common/markdown-renderer.tsx
================
export function MarkdownRenderer({ content }: { content: string }) {
  return (
    <div
      className="prose-code:bg-gray-100 prose-code:p-1 prose-code:rounded"
      dangerouslySetInnerHTML={{ __html: content }}
    />
  );
}

================
File: src/components/common/section.tsx
================
import { ReactNode } from 'react';
type SectionProps = {
  children: ReactNode;
};
type SectionTitleProps = {
  children: ReactNode;
  level?: 1 | 2 | 3 | 4 | 5 | 6;
};
type SectionPProps = {
  children: ReactNode;
};
function Section({ children }: SectionProps) {
  return (
    <section className="flex flex-col gap-6">
      {children}
      <div className="h-2 w-full border-t border-zinc-200"></div>
    </section>
  );
}
Section.H = function SectionTitle({ children, level = 2 }: SectionTitleProps) {
  const Tag = `h${level}` as const;
  const sizeMap = {
    1: 'text-4xl',
    2: 'text-3xl',
    3: 'text-2xl',
    4: 'text-xl',
    5: 'text-lg',
    6: 'text-base',
  };
  return <Tag className={`${sizeMap[level]} font-bold`}>{children}</Tag>;
};
Section.P = function SectionParagraph({ children }: SectionPProps) {
  return <p className="text-lg">{children}</p>;
};
export { Section };

================
File: src/components/common/theme-mode-toggle.tsx
================
'use client';
import { Moon, Sun } from 'lucide-react';
import { useTheme } from 'next-themes';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
export function ThemeModeToggle() {
  const { setTheme } = useTheme();
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: src/components/ui/collapsible.tsx
================
'use client';
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';
function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />;
}
function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  );
}
function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  );
}
export { Collapsible, CollapsibleTrigger, CollapsibleContent };

================
File: src/config/env.ts
================
export const isDev = process.env.NODE_ENV === 'development';

================
File: src/config/site.ts
================
export const SITE_URL = 'https://usearabic.com';

================
File: src/constants/arabic-to-english-map.ts
================
export const arabicToEnglishMap: Record<string, string> = {
  ا: 'a',
  ب: 'b',
  ت: 't',
  ث: 'th',
  ج: 'j',
  ح: 'h',
  خ: 'kh',
  د: 'd',
  ذ: 'dh',
  ر: 'r',
  ز: 'z',
  س: 's',
  ش: 'sh',
  ص: 's',
  ض: 'd',
  ط: 't',
  ظ: 'z',
  ع: 'a',
  غ: 'gh',
  ف: 'f',
  ق: 'q',
  ك: 'k',
  ل: 'l',
  م: 'm',
  ن: 'n',
  ه: 'h',
  و: 'w',
  ي: 'y',
  ء: '',
  ى: 'a',
  ئ: 'y',
  ؤ: 'w',
  ة: 'h',
  إ: 'i',
  أ: 'a',
  آ: 'aa',
  'ٓ': '',
  // numbers
  '٠': '0',
  '١': '1',
  '٢': '2',
  '٣': '3',
  '٤': '4',
  '٥': '5',
  '٦': '6',
  '٧': '7',
  '٨': '8',
  '٩': '9',
};

================
File: src/hooks/use-mobile.ts
================
import * as React from 'react';
const MOBILE_BREAKPOINT = 768;
export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined
  );
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);
  return !!isMobile;
}

================
File: src/lib/content/core/content-loader.ts
================
import fs from "fs/promises";
import matter from "gray-matter";
import path from "path";
import { remark } from "remark";
import html from "remark-html";
import { normalizeTitle } from "../utils/path-utils";
export interface PageSpecificContent {
  pageTitle: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml: string;
  frontmatter: Record<string, any>;
}
const CONTENT_BASE_PATH = path.join(process.cwd(), "content");
export async function loadPageSpecificContent(
  slugPath: string[],
): Promise<PageSpecificContent | null> {
  if (slugPath.length === 0) return null;
  const markdownFilePath = path.join(
    CONTENT_BASE_PATH,
    ...slugPath,
    "index.md",
  );
  try {
    const rawMarkdown = await fs.readFile(markdownFilePath, "utf-8");
    const { data: frontmatter, content: markdownContent } = matter(rawMarkdown);
    const processedHtml = await remark().use(html).process(markdownContent);
    const currentDirSlug = slugPath.at(-1)!;
    const title = frontmatter.title ?? normalizeTitle(currentDirSlug);
    return {
      pageTitle: title,
      pageOrder: frontmatter.order,
      excerpt: frontmatter.excerpt,
      contentHtml: processedHtml.toString(),
      frontmatter,
    };
  } catch (error) {
    return null;
  }
}

================
File: src/lib/content/core/tree-builder.ts
================
import fs from 'fs';
import path from 'path';
import type { SummaryNode } from '../types';
import {
  normalizeSlug,
  normalizeTitle,
  parseDirectoryName,
} from '../utils/path-utils';
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
let summaryTreeCache: SummaryNode[] | null = null;
function isPrefixMandatoryForDepth(depth: number): boolean {
  return depth >= 3;
}
async function scanContentDirectory(
  currentDirPath: string,
  parentSlugPath: string[] = [],
  currentDepth: number = 0
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(currentDirPath, {
    withFileTypes: true,
  });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue;
    const fullEntryPath = path.join(currentDirPath, entry.name);
    if (entry.isDirectory()) {
      const { order: dirOrder, name: unprefixedDirName } = parseDirectoryName({
        directoryName: entry.name,
        isDirectoryPrefixMandatory: isPrefixMandatoryForDepth(currentDepth),
      });
      const slug = normalizeSlug(unprefixedDirName);
      const title = normalizeTitle(unprefixedDirName);
      const children = await scanContentDirectory(
        fullEntryPath,
        [...parentSlugPath, slug],
        currentDepth + 1
      );
      items.push({
        title,
        slug,
        order: dirOrder,
        parentPath: parentSlugPath,
        children,
      });
    }
  }
  return items.sort((a, b) => {
    if (a.order !== b.order) {
      return a.order - b.order;
    }
    return a.title.localeCompare(b.title);
  });
}
export async function buildContentSummaryTree(): Promise<SummaryNode[]> {
  if (summaryTreeCache) return summaryTreeCache;
  summaryTreeCache = await scanContentDirectory(CONTENT_BASE_PATH);
  return summaryTreeCache;
}
export function clearSummaryTreeCache(): void {
  summaryTreeCache = null;
}

================
File: src/lib/content/query/find-node.ts
================
import type { SummaryNode } from '../types';
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[]
): SummaryNode | null {
  let currentNodes: SummaryNode[] = tree;
  let foundNode: SummaryNode | null = null;
  for (const slug of slugPath) {
    const nextNode = currentNodes.find((node) => node.slug === slug);
    if (!nextNode) return null;
    foundNode = nextNode;
    currentNodes = nextNode.children;
  }
  return foundNode;
}

================
File: src/lib/content/query/get-all-paths.ts
================
import { buildContentSummaryTree } from '../core/tree-builder';
import type { SummaryNode } from '../types';
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildContentSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, currentPath: string[] = []) {
    const newPath = [...currentPath, node.slug];
    slugs.push(newPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, newPath));
    }
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: src/lib/content/query/get-breadcrumbs.ts
================
import type { SummaryNode } from '../types';
import { findDeepestNode } from './find-node';
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[]
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  if (node.parentPath.length === 0) {
    return breadcrumbs;
  }
  let currentParentPath = node.parentPath;
  while (currentParentPath.length > 0) {
    const parentNode = findDeepestNode(tree, currentParentPath);
    if (parentNode) {
      breadcrumbs.unshift({ title: parentNode.title, slug: parentNode.slug });
    }
    currentParentPath = currentParentPath.slice(0, -1);
  }
  return breadcrumbs;
}

================
File: src/lib/content/query/get-leaf-nodes.ts
================
import type { LeafNodeInfo, SummaryNode } from '../types';
export function getLeafNodes(tree: SummaryNode[]): LeafNodeInfo[] {
  const leaves: LeafNodeInfo[] = [];
  function walk(node: SummaryNode, currentPath: string[] = []) {
    const fullPathSegments = [...currentPath, node.slug];
    if (node.children.length === 0) {
      leaves.push({
        title: node.title,
        fullSlugPath: fullPathSegments.join('/'),
      });
    } else {
      node.children.forEach((child) => walk(child, fullPathSegments));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: src/lib/content/query/get-node-path.ts
================
import type { SummaryNode } from '../types';
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join('/');
}

================
File: src/lib/content/utils/path-utils.ts
================
import { transliterate } from '../../text/transliteration';
export interface ParsedNameInfo {
  order: number;
  name: string;
  isPrefixed: boolean;
}
const DEFAULT_ORDER = 0;
export function parseDirectoryName({
  directoryName,
  isDirectoryPrefixMandatory,
}: {
  directoryName: string;
  isDirectoryPrefixMandatory: boolean;
}): ParsedNameInfo {
  if (/\.[a-z0-9]+$/i.test(directoryName)) {
    throw new Error(
      `Directory name "${directoryName}" must not contain a file extension.`
    );
  }
  const match = directoryName.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (match) {
    const [, numericPrefix, remainder] = match;
    const order = parseInt(
      transliterate({ input: numericPrefix, mode: 'arabic-to-latin' }),
      10
    );
    if (isNaN(order)) {
      throw new Error(
        `Invalid numeric prefix in directory name: "${directoryName}". Could not parse "${numericPrefix}" to a number.`
      );
    }
    return {
      order,
      name: remainder,
      isPrefixed: true,
    };
  }
  if (isDirectoryPrefixMandatory) {
    throw new Error(
      `Invalid directory name format: "${directoryName}". Expected format: <number>_<name> as prefix is mandatory at this level.`
    );
  }
  return {
    order: DEFAULT_ORDER,
    name: directoryName,
    isPrefixed: false,
  };
}
export function normalizeSlug(raw: string): string {
  const base = raw.replace(/\.md$/, '');
  const arabicOnly = base.replace(/[^\u0600-\u06FF_]/g, '');
  return transliterate({
    input: arabicOnly,
    mode: 'arabic-to-latin',
  }).replace(/_+/g, '-');
}
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, '');
  return arabicOnly.replace(/_+/g, ' ');
}

================
File: src/lib/content/utils/tree-utils.ts
================
import type { SummaryNode } from '../types';
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  currentPath: string[] = [],
  level: number = 0
): void {
  for (const node of nodes) {
    callback(node, currentPath, level);
    if (node.children && node.children.length > 0) {
      walkTree(node.children, callback, [...currentPath, node.slug], level + 1);
    }
  }
}
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: src/lib/content/api.ts
================
import { loadPageSpecificContent } from "./core/content-loader";
import { loadBookLandingPageConfigForBuild } from "./core/landing-page-loader";
import {
  buildContentSummaryTree,
  clearSummaryTreeCache as clearInternalSummaryTreeCache,
} from "./core/tree-builder";
import { findDeepestNode } from "./query/find-node";
import type { ContentNode, SummaryNode } from "./types";
export { getTreeSlugs as getAllContentPaths } from "./query/get-all-paths";
export { getBreadcrumbs } from "./query/get-breadcrumbs";
export { getLeafNodes } from "./query/get-leaf-nodes";
export { getNodeSlugPath } from "./query/get-node-path";
export { flattenTree, walkTree } from "./utils/tree-utils";
const BOOK_DEPTH = 2;
export async function getSummaryTree(): Promise<SummaryNode[]> {
  return buildContentSummaryTree();
}
export async function getContentNodeBySlugPath(
  slugPath: string[],
): Promise<ContentNode | null> {
  const tree = await getSummaryTree();
  const summaryNode = findDeepestNode(tree, slugPath);
  if (!summaryNode) {
    return null;
  }
  const pageContent = await loadPageSpecificContent(slugPath);
  const contentNode: ContentNode = {
    ...summaryNode,
  };
  if (pageContent) {
    contentNode.pageTitle = pageContent.pageTitle;
    contentNode.pageOrder = pageContent.pageOrder;
    contentNode.excerpt = pageContent.excerpt;
    contentNode.contentHtml = pageContent.contentHtml;
    contentNode.frontmatter = pageContent.frontmatter;
  }
  const nodeDepth = summaryNode.parentPath.length;
  if (nodeDepth === BOOK_DEPTH) {
    const landingConfig = await loadBookLandingPageConfigForBuild(
      slugPath,
      summaryNode.children,
    );
    if (landingConfig) {
      contentNode.landingPageConfig = landingConfig;
    }
  }
  return contentNode;
}
export function clearSummaryCache(): void {
  clearInternalSummaryTreeCache();
}

================
File: src/lib/styles/tailwind-utils.ts
================
import clsx, { type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

================
File: src/lib/text/ascii-tree-generator.ts
================
import type { SummaryNode } from '../content/types';
export function generateASCIITree(
  docs: SummaryNode[],
  options: {
    indent?: string;
    splitLevel?: number;
    splitString?: string;
    currentLevel?: number;
  } = {}
): string {
  const {
    indent = '',
    splitLevel = Infinity,
    splitString = '',
    currentLevel = 0,
  } = options;
  return docs
    .map((node, index) => {
      const isLast = index === docs.length - 1;
      const branch = isLast ? '└── ' : '├── ';
      const nextIndent = indent + (isLast ? '    ' : '│   ');
      const label = node.title.replace(/_/g, ' ');
      let output = '';
      if (currentLevel === splitLevel && label !== splitString) {
        return '';
      }
      output += `${indent}${branch}${label}\n`;
      if (node.children.length > 0) {
        output += generateASCIITree(node.children, {
          indent: nextIndent,
          splitLevel,
          splitString,
          currentLevel: currentLevel + 1,
        });
      }
      return output;
    })
    .join('');
}

================
File: src/providers/theme-provider.tsx
================
'use client';
import { ThemeProvider as NextThemesProvider } from 'next-themes';
import * as React from 'react';
export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

================
File: .prettierrc.js
================
module.exports = {
  printWidth: 80,
  tabWidth: 2,
  useTabs: false,
  semi: true,
  singleQuote: true,
  quoteProps: 'as-needed',
  jsxSingleQuote: false,
  trailingComma: 'es5',
  bracketSpacing: true,
  bracketSameLine: false,
  arrowParens: 'always',
  endOfLine: 'lf',
  plugins: ['prettier-plugin-tailwindcss'],
};

================
File: env.d.ts
================
declare namespace Cloudflare {
  interface Env {}
}
interface CloudflareEnv extends Cloudflare.Env {}
declare var onmessage: never;
declare class DOMException extends Error {
  constructor(message?: string, name?: string);
  readonly message: string;
  readonly name: string;
  readonly code: number;
  static readonly INDEX_SIZE_ERR: number;
  static readonly DOMSTRING_SIZE_ERR: number;
  static readonly HIERARCHY_REQUEST_ERR: number;
  static readonly WRONG_DOCUMENT_ERR: number;
  static readonly INVALID_CHARACTER_ERR: number;
  static readonly NO_DATA_ALLOWED_ERR: number;
  static readonly NO_MODIFICATION_ALLOWED_ERR: number;
  static readonly NOT_FOUND_ERR: number;
  static readonly NOT_SUPPORTED_ERR: number;
  static readonly INUSE_ATTRIBUTE_ERR: number;
  static readonly INVALID_STATE_ERR: number;
  static readonly SYNTAX_ERR: number;
  static readonly INVALID_MODIFICATION_ERR: number;
  static readonly NAMESPACE_ERR: number;
  static readonly INVALID_ACCESS_ERR: number;
  static readonly VALIDATION_ERR: number;
  static readonly TYPE_MISMATCH_ERR: number;
  static readonly SECURITY_ERR: number;
  static readonly NETWORK_ERR: number;
  static readonly ABORT_ERR: number;
  static readonly URL_MISMATCH_ERR: number;
  static readonly QUOTA_EXCEEDED_ERR: number;
  static readonly TIMEOUT_ERR: number;
  static readonly INVALID_NODE_TYPE_ERR: number;
  static readonly DATA_CLONE_ERR: number;
  get stack(): any;
  set stack(value: any);
}
type WorkerGlobalScopeEventMap = {
  fetch: FetchEvent;
  scheduled: ScheduledEvent;
  queue: QueueEvent;
  unhandledrejection: PromiseRejectionEvent;
  rejectionhandled: PromiseRejectionEvent;
};
declare abstract class WorkerGlobalScope extends EventTarget<WorkerGlobalScopeEventMap> {
  EventTarget: typeof EventTarget;
}
interface Console {
  'assert'(condition?: boolean, ...data: any[]): void;
  clear(): void;
  count(label?: string): void;
  countReset(label?: string): void;
  debug(...data: any[]): void;
  dir(item?: any, options?: any): void;
  dirxml(...data: any[]): void;
  error(...data: any[]): void;
  group(...data: any[]): void;
  groupCollapsed(...data: any[]): void;
  groupEnd(): void;
  info(...data: any[]): void;
  log(...data: any[]): void;
  table(tabularData?: any, properties?: string[]): void;
  time(label?: string): void;
  timeEnd(label?: string): void;
  timeLog(label?: string, ...data: any[]): void;
  timeStamp(label?: string): void;
  trace(...data: any[]): void;
  warn(...data: any[]): void;
}
declare const console: Console;
type BufferSource = ArrayBufferView | ArrayBuffer;
type TypedArray =
  | Int8Array
  | Uint8Array
  | Uint8ClampedArray
  | Int16Array
  | Uint16Array
  | Int32Array
  | Uint32Array
  | Float32Array
  | Float64Array
  | BigInt64Array
  | BigUint64Array;
declare namespace WebAssembly {
  class CompileError extends Error {
    constructor(message?: string);
  }
  class RuntimeError extends Error {
    constructor(message?: string);
  }
  type ValueType =
    | 'anyfunc'
    | 'externref'
    | 'f32'
    | 'f64'
    | 'i32'
    | 'i64'
    | 'v128';
  interface GlobalDescriptor {
    value: ValueType;
    mutable?: boolean;
  }
  class Global {
    constructor(descriptor: GlobalDescriptor, value?: any);
    value: any;
    valueOf(): any;
  }
  type ImportValue = ExportValue | number;
  type ModuleImports = Record<string, ImportValue>;
  type Imports = Record<string, ModuleImports>;
  type ExportValue = Function | Global | Memory | Table;
  type Exports = Record<string, ExportValue>;
  class Instance {
    constructor(module: Module, imports?: Imports);
    readonly exports: Exports;
  }
  interface MemoryDescriptor {
    initial: number;
    maximum?: number;
    shared?: boolean;
  }
  class Memory {
    constructor(descriptor: MemoryDescriptor);
    readonly buffer: ArrayBuffer;
    grow(delta: number): number;
  }
  type ImportExportKind = 'function' | 'global' | 'memory' | 'table';
  interface ModuleExportDescriptor {
    kind: ImportExportKind;
    name: string;
  }
  interface ModuleImportDescriptor {
    kind: ImportExportKind;
    module: string;
    name: string;
  }
  abstract class Module {
    static customSections(module: Module, sectionName: string): ArrayBuffer[];
    static exports(module: Module): ModuleExportDescriptor[];
    static imports(module: Module): ModuleImportDescriptor[];
  }
  type TableKind = 'anyfunc' | 'externref';
  interface TableDescriptor {
    element: TableKind;
    initial: number;
    maximum?: number;
  }
  class Table {
    constructor(descriptor: TableDescriptor, value?: any);
    readonly length: number;
    get(index: number): any;
    grow(delta: number, value?: any): number;
    set(index: number, value?: any): void;
  }
  function instantiate(module: Module, imports?: Imports): Promise<Instance>;
  function validate(bytes: BufferSource): boolean;
}
interface ServiceWorkerGlobalScope extends WorkerGlobalScope {
  DOMException: typeof DOMException;
  WorkerGlobalScope: typeof WorkerGlobalScope;
  btoa(data: string): string;
  atob(data: string): string;
  setTimeout(callback: (...args: any[]) => void, msDelay?: number): number;
  setTimeout<Args extends any[]>(
    callback: (...args: Args) => void,
    msDelay?: number,
    ...args: Args
  ): number;
  clearTimeout(timeoutId: number | null): void;
  setInterval(callback: (...args: any[]) => void, msDelay?: number): number;
  setInterval<Args extends any[]>(
    callback: (...args: Args) => void,
    msDelay?: number,
    ...args: Args
  ): number;
  clearInterval(timeoutId: number | null): void;
  queueMicrotask(task: Function): void;
  structuredClone<T>(value: T, options?: StructuredSerializeOptions): T;
  reportError(error: any): void;
  fetch(
    input: RequestInfo | URL,
    init?: RequestInit<RequestInitCfProperties>
  ): Promise<Response>;
  self: ServiceWorkerGlobalScope;
  crypto: Crypto;
  caches: CacheStorage;
  scheduler: Scheduler;
  performance: Performance;
  Cloudflare: Cloudflare;
  readonly origin: string;
  Event: typeof Event;
  ExtendableEvent: typeof ExtendableEvent;
  CustomEvent: typeof CustomEvent;
  PromiseRejectionEvent: typeof PromiseRejectionEvent;
  FetchEvent: typeof FetchEvent;
  TailEvent: typeof TailEvent;
  TraceEvent: typeof TailEvent;
  ScheduledEvent: typeof ScheduledEvent;
  MessageEvent: typeof MessageEvent;
  CloseEvent: typeof CloseEvent;
  ReadableStreamDefaultReader: typeof ReadableStreamDefaultReader;
  ReadableStreamBYOBReader: typeof ReadableStreamBYOBReader;
  ReadableStream: typeof ReadableStream;
  WritableStream: typeof WritableStream;
  WritableStreamDefaultWriter: typeof WritableStreamDefaultWriter;
  TransformStream: typeof TransformStream;
  ByteLengthQueuingStrategy: typeof ByteLengthQueuingStrategy;
  CountQueuingStrategy: typeof CountQueuingStrategy;
  ErrorEvent: typeof ErrorEvent;
  EventSource: typeof EventSource;
  ReadableStreamBYOBRequest: typeof ReadableStreamBYOBRequest;
  ReadableStreamDefaultController: typeof ReadableStreamDefaultController;
  ReadableByteStreamController: typeof ReadableByteStreamController;
  WritableStreamDefaultController: typeof WritableStreamDefaultController;
  TransformStreamDefaultController: typeof TransformStreamDefaultController;
  CompressionStream: typeof CompressionStream;
  DecompressionStream: typeof DecompressionStream;
  TextEncoderStream: typeof TextEncoderStream;
  TextDecoderStream: typeof TextDecoderStream;
  Headers: typeof Headers;
  Body: typeof Body;
  Request: typeof Request;
  Response: typeof Response;
  WebSocket: typeof WebSocket;
  WebSocketPair: typeof WebSocketPair;
  WebSocketRequestResponsePair: typeof WebSocketRequestResponsePair;
  AbortController: typeof AbortController;
  AbortSignal: typeof AbortSignal;
  TextDecoder: typeof TextDecoder;
  TextEncoder: typeof TextEncoder;
  navigator: Navigator;
  Navigator: typeof Navigator;
  URL: typeof URL;
  URLSearchParams: typeof URLSearchParams;
  URLPattern: typeof URLPattern;
  Blob: typeof Blob;
  File: typeof File;
  FormData: typeof FormData;
  Crypto: typeof Crypto;
  SubtleCrypto: typeof SubtleCrypto;
  CryptoKey: typeof CryptoKey;
  CacheStorage: typeof CacheStorage;
  Cache: typeof Cache;
  FixedLengthStream: typeof FixedLengthStream;
  IdentityTransformStream: typeof IdentityTransformStream;
  HTMLRewriter: typeof HTMLRewriter;
}
declare function addEventListener<Type extends keyof WorkerGlobalScopeEventMap>(
  type: Type,
  handler: EventListenerOrEventListenerObject<WorkerGlobalScopeEventMap[Type]>,
  options?: EventTargetAddEventListenerOptions | boolean
): void;
declare function removeEventListener<
  Type extends keyof WorkerGlobalScopeEventMap,
>(
  type: Type,
  handler: EventListenerOrEventListenerObject<WorkerGlobalScopeEventMap[Type]>,
  options?: EventTargetEventListenerOptions | boolean
): void;
declare function dispatchEvent(
  event: WorkerGlobalScopeEventMap[keyof WorkerGlobalScopeEventMap]
): boolean;
declare function btoa(data: string): string;
declare function atob(data: string): string;
declare function setTimeout(
  callback: (...args: any[]) => void,
  msDelay?: number
): number;
declare function setTimeout<Args extends any[]>(
  callback: (...args: Args) => void,
  msDelay?: number,
  ...args: Args
): number;
declare function clearTimeout(timeoutId: number | null): void;
declare function setInterval(
  callback: (...args: any[]) => void,
  msDelay?: number
): number;
declare function setInterval<Args extends any[]>(
  callback: (...args: Args) => void,
  msDelay?: number,
  ...args: Args
): number;
declare function clearInterval(timeoutId: number | null): void;
declare function queueMicrotask(task: Function): void;
declare function structuredClone<T>(
  value: T,
  options?: StructuredSerializeOptions
): T;
declare function reportError(error: any): void;
declare function fetch(
  input: RequestInfo | URL,
  init?: RequestInit<RequestInitCfProperties>
): Promise<Response>;
declare const self: ServiceWorkerGlobalScope;
declare const crypto: Crypto;
declare const caches: CacheStorage;
declare const scheduler: Scheduler;
declare const performance: Performance;
declare const Cloudflare: Cloudflare;
declare const origin: string;
declare const navigator: Navigator;
interface TestController {}
interface ExecutionContext {
  waitUntil(promise: Promise<any>): void;
  passThroughOnException(): void;
  props: any;
}
type ExportedHandlerFetchHandler<Env = unknown, CfHostMetadata = unknown> = (
  request: Request<CfHostMetadata, IncomingRequestCfProperties<CfHostMetadata>>,
  env: Env,
  ctx: ExecutionContext
) => Response | Promise<Response>;
type ExportedHandlerTailHandler<Env = unknown> = (
  events: TraceItem[],
  env: Env,
  ctx: ExecutionContext
) => void | Promise<void>;
type ExportedHandlerTraceHandler<Env = unknown> = (
  traces: TraceItem[],
  env: Env,
  ctx: ExecutionContext
) => void | Promise<void>;
type ExportedHandlerTailStreamHandler<Env = unknown> = (
  event: TailStream.TailEvent,
  env: Env,
  ctx: ExecutionContext
) => TailStream.TailEventHandlerType | Promise<TailStream.TailEventHandlerType>;
type ExportedHandlerScheduledHandler<Env = unknown> = (
  controller: ScheduledController,
  env: Env,
  ctx: ExecutionContext
) => void | Promise<void>;
type ExportedHandlerQueueHandler<Env = unknown, Message = unknown> = (
  batch: MessageBatch<Message>,
  env: Env,
  ctx: ExecutionContext
) => void | Promise<void>;
type ExportedHandlerTestHandler<Env = unknown> = (
  controller: TestController,
  env: Env,
  ctx: ExecutionContext
) => void | Promise<void>;
interface ExportedHandler<
  Env = unknown,
  QueueHandlerMessage = unknown,
  CfHostMetadata = unknown,
> {
  fetch?: ExportedHandlerFetchHandler<Env, CfHostMetadata>;
  tail?: ExportedHandlerTailHandler<Env>;
  trace?: ExportedHandlerTraceHandler<Env>;
  tailStream?: ExportedHandlerTailStreamHandler<Env>;
  scheduled?: ExportedHandlerScheduledHandler<Env>;
  test?: ExportedHandlerTestHandler<Env>;
  email?: EmailExportedHandler<Env>;
  queue?: ExportedHandlerQueueHandler<Env, QueueHandlerMessage>;
}
interface StructuredSerializeOptions {
  transfer?: any[];
}
declare abstract class PromiseRejectionEvent extends Event {
  readonly promise: Promise<any>;
  readonly reason: any;
}
declare abstract class Navigator {
  sendBeacon(
    url: string,
    body?:
      | ReadableStream
      | string
      | (ArrayBuffer | ArrayBufferView)
      | Blob
      | FormData
      | URLSearchParams
      | URLSearchParams
  ): boolean;
  readonly userAgent: string;
  readonly hardwareConcurrency: number;
  readonly language: string;
  readonly languages: string[];
}
interface Performance {
  readonly timeOrigin: number;
  now(): number;
}
interface AlarmInvocationInfo {
  readonly isRetry: boolean;
  readonly retryCount: number;
}
interface Cloudflare {
  readonly compatibilityFlags: Record<string, boolean>;
}
interface DurableObject {
  fetch(request: Request): Response | Promise<Response>;
  alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise<void>;
  webSocketMessage?(
    ws: WebSocket,
    message: string | ArrayBuffer
  ): void | Promise<void>;
  webSocketClose?(
    ws: WebSocket,
    code: number,
    reason: string,
    wasClean: boolean
  ): void | Promise<void>;
  webSocketError?(ws: WebSocket, error: unknown): void | Promise<void>;
}
type DurableObjectStub<
  T extends Rpc.DurableObjectBranded | undefined = undefined,
> = Fetcher<
  T,
  'alarm' | 'webSocketMessage' | 'webSocketClose' | 'webSocketError'
> & {
  readonly id: DurableObjectId;
  readonly name?: string;
};
interface DurableObjectId {
  toString(): string;
  equals(other: DurableObjectId): boolean;
  readonly name?: string;
}
interface DurableObjectNamespace<
  T extends Rpc.DurableObjectBranded | undefined = undefined,
> {
  newUniqueId(
    options?: DurableObjectNamespaceNewUniqueIdOptions
  ): DurableObjectId;
  idFromName(name: string): DurableObjectId;
  idFromString(id: string): DurableObjectId;
  get(
    id: DurableObjectId,
    options?: DurableObjectNamespaceGetDurableObjectOptions
  ): DurableObjectStub<T>;
  jurisdiction(
    jurisdiction: DurableObjectJurisdiction
  ): DurableObjectNamespace<T>;
}
type DurableObjectJurisdiction = 'eu' | 'fedramp';
interface DurableObjectNamespaceNewUniqueIdOptions {
  jurisdiction?: DurableObjectJurisdiction;
}
type DurableObjectLocationHint =
  | 'wnam'
  | 'enam'
  | 'sam'
  | 'weur'
  | 'eeur'
  | 'apac'
  | 'oc'
  | 'afr'
  | 'me';
interface DurableObjectNamespaceGetDurableObjectOptions {
  locationHint?: DurableObjectLocationHint;
}
interface DurableObjectState {
  waitUntil(promise: Promise<any>): void;
  readonly id: DurableObjectId;
  readonly storage: DurableObjectStorage;
  container?: Container;
  blockConcurrencyWhile<T>(callback: () => Promise<T>): Promise<T>;
  acceptWebSocket(ws: WebSocket, tags?: string[]): void;
  getWebSockets(tag?: string): WebSocket[];
  setWebSocketAutoResponse(maybeReqResp?: WebSocketRequestResponsePair): void;
  getWebSocketAutoResponse(): WebSocketRequestResponsePair | null;
  getWebSocketAutoResponseTimestamp(ws: WebSocket): Date | null;
  setHibernatableWebSocketEventTimeout(timeoutMs?: number): void;
  getHibernatableWebSocketEventTimeout(): number | null;
  getTags(ws: WebSocket): string[];
  abort(reason?: string): void;
}
interface DurableObjectTransaction {
  get<T = unknown>(
    key: string,
    options?: DurableObjectGetOptions
  ): Promise<T | undefined>;
  get<T = unknown>(
    keys: string[],
    options?: DurableObjectGetOptions
  ): Promise<Map<string, T>>;
  list<T = unknown>(
    options?: DurableObjectListOptions
  ): Promise<Map<string, T>>;
  put<T>(
    key: string,
    value: T,
    options?: DurableObjectPutOptions
  ): Promise<void>;
  put<T>(
    entries: Record<string, T>,
    options?: DurableObjectPutOptions
  ): Promise<void>;
  delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;
  delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;
  rollback(): void;
  getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;
  setAlarm(
    scheduledTime: number | Date,
    options?: DurableObjectSetAlarmOptions
  ): Promise<void>;
  deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;
}
interface DurableObjectStorage {
  get<T = unknown>(
    key: string,
    options?: DurableObjectGetOptions
  ): Promise<T | undefined>;
  get<T = unknown>(
    keys: string[],
    options?: DurableObjectGetOptions
  ): Promise<Map<string, T>>;
  list<T = unknown>(
    options?: DurableObjectListOptions
  ): Promise<Map<string, T>>;
  put<T>(
    key: string,
    value: T,
    options?: DurableObjectPutOptions
  ): Promise<void>;
  put<T>(
    entries: Record<string, T>,
    options?: DurableObjectPutOptions
  ): Promise<void>;
  delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;
  delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;
  deleteAll(options?: DurableObjectPutOptions): Promise<void>;
  transaction<T>(
    closure: (txn: DurableObjectTransaction) => Promise<T>
  ): Promise<T>;
  getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;
  setAlarm(
    scheduledTime: number | Date,
    options?: DurableObjectSetAlarmOptions
  ): Promise<void>;
  deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;
  sync(): Promise<void>;
  sql: SqlStorage;
  transactionSync<T>(closure: () => T): T;
  getCurrentBookmark(): Promise<string>;
  getBookmarkForTime(timestamp: number | Date): Promise<string>;
  onNextSessionRestoreBookmark(bookmark: string): Promise<string>;
}
interface DurableObjectListOptions {
  start?: string;
  startAfter?: string;
  end?: string;
  prefix?: string;
  reverse?: boolean;
  limit?: number;
  allowConcurrency?: boolean;
  noCache?: boolean;
}
interface DurableObjectGetOptions {
  allowConcurrency?: boolean;
  noCache?: boolean;
}
interface DurableObjectGetAlarmOptions {
  allowConcurrency?: boolean;
}
interface DurableObjectPutOptions {
  allowConcurrency?: boolean;
  allowUnconfirmed?: boolean;
  noCache?: boolean;
}
interface DurableObjectSetAlarmOptions {
  allowConcurrency?: boolean;
  allowUnconfirmed?: boolean;
}
declare class WebSocketRequestResponsePair {
  constructor(request: string, response: string);
  get request(): string;
  get response(): string;
}
interface AnalyticsEngineDataset {
  writeDataPoint(event?: AnalyticsEngineDataPoint): void;
}
interface AnalyticsEngineDataPoint {
  indexes?: ((ArrayBuffer | string) | null)[];
  doubles?: number[];
  blobs?: ((ArrayBuffer | string) | null)[];
}
declare class Event {
  constructor(type: string, init?: EventInit);
  get type(): string;
  get eventPhase(): number;
  get composed(): boolean;
  get bubbles(): boolean;
  get cancelable(): boolean;
  get defaultPrevented(): boolean;
  get returnValue(): boolean;
  get currentTarget(): EventTarget | undefined;
  get target(): EventTarget | undefined;
  get srcElement(): EventTarget | undefined;
  get timeStamp(): number;
  get isTrusted(): boolean;
  get cancelBubble(): boolean;
  set cancelBubble(value: boolean);
  stopImmediatePropagation(): void;
  preventDefault(): void;
  stopPropagation(): void;
  composedPath(): EventTarget[];
  static readonly NONE: number;
  static readonly CAPTURING_PHASE: number;
  static readonly AT_TARGET: number;
  static readonly BUBBLING_PHASE: number;
}
interface EventInit {
  bubbles?: boolean;
  cancelable?: boolean;
  composed?: boolean;
}
type EventListener<EventType extends Event = Event> = (
  event: EventType
) => void;
interface EventListenerObject<EventType extends Event = Event> {
  handleEvent(event: EventType): void;
}
type EventListenerOrEventListenerObject<EventType extends Event = Event> =
  | EventListener<EventType>
  | EventListenerObject<EventType>;
declare class EventTarget<
  EventMap extends Record<string, Event> = Record<string, Event>,
> {
  constructor();
  addEventListener<Type extends keyof EventMap>(
    type: Type,
    handler: EventListenerOrEventListenerObject<EventMap[Type]>,
    options?: EventTargetAddEventListenerOptions | boolean
  ): void;
  removeEventListener<Type extends keyof EventMap>(
    type: Type,
    handler: EventListenerOrEventListenerObject<EventMap[Type]>,
    options?: EventTargetEventListenerOptions | boolean
  ): void;
  dispatchEvent(event: EventMap[keyof EventMap]): boolean;
}
interface EventTargetEventListenerOptions {
  capture?: boolean;
}
interface EventTargetAddEventListenerOptions {
  capture?: boolean;
  passive?: boolean;
  once?: boolean;
  signal?: AbortSignal;
}
interface EventTargetHandlerObject {
  handleEvent: (event: Event) => any | undefined;
}
declare class AbortController {
  constructor();
  get signal(): AbortSignal;
  abort(reason?: any): void;
}
declare abstract class AbortSignal extends EventTarget {
  static abort(reason?: any): AbortSignal;
  static timeout(delay: number): AbortSignal;
  static any(signals: AbortSignal[]): AbortSignal;
  get aborted(): boolean;
  get reason(): any;
  get onabort(): any | null;
  set onabort(value: any | null);
  throwIfAborted(): void;
}
interface Scheduler {
  wait(delay: number, maybeOptions?: SchedulerWaitOptions): Promise<void>;
}
interface SchedulerWaitOptions {
  signal?: AbortSignal;
}
declare abstract class ExtendableEvent extends Event {
  waitUntil(promise: Promise<any>): void;
}
declare class CustomEvent<T = any> extends Event {
  constructor(type: string, init?: CustomEventCustomEventInit);
  get detail(): T;
}
interface CustomEventCustomEventInit {
  bubbles?: boolean;
  cancelable?: boolean;
  composed?: boolean;
  detail?: any;
}
declare class Blob {
  constructor(
    type?: ((ArrayBuffer | ArrayBufferView) | string | Blob)[],
    options?: BlobOptions
  );
  get size(): number;
  get type(): string;
  slice(start?: number, end?: number, type?: string): Blob;
  arrayBuffer(): Promise<ArrayBuffer>;
  bytes(): Promise<Uint8Array>;
  text(): Promise<string>;
  stream(): ReadableStream;
}
interface BlobOptions {
  type?: string;
}
declare class File extends Blob {
  constructor(
    bits: ((ArrayBuffer | ArrayBufferView) | string | Blob)[] | undefined,
    name: string,
    options?: FileOptions
  );
  get name(): string;
  get lastModified(): number;
}
interface FileOptions {
  type?: string;
  lastModified?: number;
}
declare abstract class CacheStorage {
  open(cacheName: string): Promise<Cache>;
  readonly default: Cache;
}
declare abstract class Cache {
  delete(
    request: RequestInfo | URL,
    options?: CacheQueryOptions
  ): Promise<boolean>;
  match(
    request: RequestInfo | URL,
    options?: CacheQueryOptions
  ): Promise<Response | undefined>;
  put(request: RequestInfo | URL, response: Response): Promise<void>;
}
interface CacheQueryOptions {
  ignoreMethod?: boolean;
}
declare abstract class Crypto {
  get subtle(): SubtleCrypto;
  getRandomValues<
    T extends
      | Int8Array
      | Uint8Array
      | Int16Array
      | Uint16Array
      | Int32Array
      | Uint32Array
      | BigInt64Array
      | BigUint64Array,
  >(buffer: T): T;
  randomUUID(): string;
  DigestStream: typeof DigestStream;
}
declare abstract class SubtleCrypto {
  encrypt(
    algorithm: string | SubtleCryptoEncryptAlgorithm,
    key: CryptoKey,
    plainText: ArrayBuffer | ArrayBufferView
  ): Promise<ArrayBuffer>;
  decrypt(
    algorithm: string | SubtleCryptoEncryptAlgorithm,
    key: CryptoKey,
    cipherText: ArrayBuffer | ArrayBufferView
  ): Promise<ArrayBuffer>;
  sign(
    algorithm: string | SubtleCryptoSignAlgorithm,
    key: CryptoKey,
    data: ArrayBuffer | ArrayBufferView
  ): Promise<ArrayBuffer>;
  verify(
    algorithm: string | SubtleCryptoSignAlgorithm,
    key: CryptoKey,
    signature: ArrayBuffer | ArrayBufferView,
    data: ArrayBuffer | ArrayBufferView
  ): Promise<boolean>;
  digest(
    algorithm: string | SubtleCryptoHashAlgorithm,
    data: ArrayBuffer | ArrayBufferView
  ): Promise<ArrayBuffer>;
  generateKey(
    algorithm: string | SubtleCryptoGenerateKeyAlgorithm,
    extractable: boolean,
    keyUsages: string[]
  ): Promise<CryptoKey | CryptoKeyPair>;
  deriveKey(
    algorithm: string | SubtleCryptoDeriveKeyAlgorithm,
    baseKey: CryptoKey,
    derivedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm,
    extractable: boolean,
    keyUsages: string[]
  ): Promise<CryptoKey>;
  deriveBits(
    algorithm: string | SubtleCryptoDeriveKeyAlgorithm,
    baseKey: CryptoKey,
    length?: number | null
  ): Promise<ArrayBuffer>;
  importKey(
    format: string,
    keyData: (ArrayBuffer | ArrayBufferView) | JsonWebKey,
    algorithm: string | SubtleCryptoImportKeyAlgorithm,
    extractable: boolean,
    keyUsages: string[]
  ): Promise<CryptoKey>;
  exportKey(format: string, key: CryptoKey): Promise<ArrayBuffer | JsonWebKey>;
  wrapKey(
    format: string,
    key: CryptoKey,
    wrappingKey: CryptoKey,
    wrapAlgorithm: string | SubtleCryptoEncryptAlgorithm
  ): Promise<ArrayBuffer>;
  unwrapKey(
    format: string,
    wrappedKey: ArrayBuffer | ArrayBufferView,
    unwrappingKey: CryptoKey,
    unwrapAlgorithm: string | SubtleCryptoEncryptAlgorithm,
    unwrappedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm,
    extractable: boolean,
    keyUsages: string[]
  ): Promise<CryptoKey>;
  timingSafeEqual(
    a: ArrayBuffer | ArrayBufferView,
    b: ArrayBuffer | ArrayBufferView
  ): boolean;
}
declare abstract class CryptoKey {
  readonly type: string;
  readonly extractable: boolean;
  readonly algorithm:
    | CryptoKeyKeyAlgorithm
    | CryptoKeyAesKeyAlgorithm
    | CryptoKeyHmacKeyAlgorithm
    | CryptoKeyRsaKeyAlgorithm
    | CryptoKeyEllipticKeyAlgorithm
    | CryptoKeyArbitraryKeyAlgorithm;
  readonly usages: string[];
}
interface CryptoKeyPair {
  publicKey: CryptoKey;
  privateKey: CryptoKey;
}
interface JsonWebKey {
  kty: string;
  use?: string;
  key_ops?: string[];
  alg?: string;
  ext?: boolean;
  crv?: string;
  x?: string;
  y?: string;
  d?: string;
  n?: string;
  e?: string;
  p?: string;
  q?: string;
  dp?: string;
  dq?: string;
  qi?: string;
  oth?: RsaOtherPrimesInfo[];
  k?: string;
}
interface RsaOtherPrimesInfo {
  r?: string;
  d?: string;
  t?: string;
}
interface SubtleCryptoDeriveKeyAlgorithm {
  name: string;
  salt?: ArrayBuffer | ArrayBufferView;
  iterations?: number;
  hash?: string | SubtleCryptoHashAlgorithm;
  $public?: CryptoKey;
  info?: ArrayBuffer | ArrayBufferView;
}
interface SubtleCryptoEncryptAlgorithm {
  name: string;
  iv?: ArrayBuffer | ArrayBufferView;
  additionalData?: ArrayBuffer | ArrayBufferView;
  tagLength?: number;
  counter?: ArrayBuffer | ArrayBufferView;
  length?: number;
  label?: ArrayBuffer | ArrayBufferView;
}
interface SubtleCryptoGenerateKeyAlgorithm {
  name: string;
  hash?: string | SubtleCryptoHashAlgorithm;
  modulusLength?: number;
  publicExponent?: ArrayBuffer | ArrayBufferView;
  length?: number;
  namedCurve?: string;
}
interface SubtleCryptoHashAlgorithm {
  name: string;
}
interface SubtleCryptoImportKeyAlgorithm {
  name: string;
  hash?: string | SubtleCryptoHashAlgorithm;
  length?: number;
  namedCurve?: string;
  compressed?: boolean;
}
interface SubtleCryptoSignAlgorithm {
  name: string;
  hash?: string | SubtleCryptoHashAlgorithm;
  dataLength?: number;
  saltLength?: number;
}
interface CryptoKeyKeyAlgorithm {
  name: string;
}
interface CryptoKeyAesKeyAlgorithm {
  name: string;
  length: number;
}
interface CryptoKeyHmacKeyAlgorithm {
  name: string;
  hash: CryptoKeyKeyAlgorithm;
  length: number;
}
interface CryptoKeyRsaKeyAlgorithm {
  name: string;
  modulusLength: number;
  publicExponent: ArrayBuffer | ArrayBufferView;
  hash?: CryptoKeyKeyAlgorithm;
}
interface CryptoKeyEllipticKeyAlgorithm {
  name: string;
  namedCurve: string;
}
interface CryptoKeyArbitraryKeyAlgorithm {
  name: string;
  hash?: CryptoKeyKeyAlgorithm;
  namedCurve?: string;
  length?: number;
}
declare class DigestStream extends WritableStream<
  ArrayBuffer | ArrayBufferView
> {
  constructor(algorithm: string | SubtleCryptoHashAlgorithm);
  readonly digest: Promise<ArrayBuffer>;
  get bytesWritten(): number | bigint;
}
declare class TextDecoder {
  constructor(label?: string, options?: TextDecoderConstructorOptions);
  decode(
    input?: ArrayBuffer | ArrayBufferView,
    options?: TextDecoderDecodeOptions
  ): string;
  get encoding(): string;
  get fatal(): boolean;
  get ignoreBOM(): boolean;
}
declare class TextEncoder {
  constructor();
  encode(input?: string): Uint8Array;
  encodeInto(
    input: string,
    buffer: ArrayBuffer | ArrayBufferView
  ): TextEncoderEncodeIntoResult;
  get encoding(): string;
}
interface TextDecoderConstructorOptions {
  fatal: boolean;
  ignoreBOM: boolean;
}
interface TextDecoderDecodeOptions {
  stream: boolean;
}
interface TextEncoderEncodeIntoResult {
  read: number;
  written: number;
}
declare class ErrorEvent extends Event {
  constructor(type: string, init?: ErrorEventErrorEventInit);
  get filename(): string;
  get message(): string;
  get lineno(): number;
  get colno(): number;
  get error(): any;
}
interface ErrorEventErrorEventInit {
  message?: string;
  filename?: string;
  lineno?: number;
  colno?: number;
  error?: any;
}
declare class FormData {
  constructor();
  append(name: string, value: string): void;
  append(name: string, value: Blob, filename?: string): void;
  delete(name: string): void;
  get(name: string): (File | string) | null;
  getAll(name: string): (File | string)[];
  has(name: string): boolean;
  set(name: string, value: string): void;
  set(name: string, value: Blob, filename?: string): void;
  entries(): IterableIterator<[key: string, value: File | string]>;
  keys(): IterableIterator<string>;
  values(): IterableIterator<File | string>;
  forEach<This = unknown>(
    callback: (
      this: This,
      value: File | string,
      key: string,
      parent: FormData
    ) => void,
    thisArg?: This
  ): void;
  [Symbol.iterator](): IterableIterator<[key: string, value: File | string]>;
}
interface ContentOptions {
  html?: boolean;
}
declare class HTMLRewriter {
  constructor();
  on(
    selector: string,
    handlers: HTMLRewriterElementContentHandlers
  ): HTMLRewriter;
  onDocument(handlers: HTMLRewriterDocumentContentHandlers): HTMLRewriter;
  transform(response: Response): Response;
}
interface HTMLRewriterElementContentHandlers {
  element?(element: Element): void | Promise<void>;
  comments?(comment: Comment): void | Promise<void>;
  text?(element: Text): void | Promise<void>;
}
interface HTMLRewriterDocumentContentHandlers {
  doctype?(doctype: Doctype): void | Promise<void>;
  comments?(comment: Comment): void | Promise<void>;
  text?(text: Text): void | Promise<void>;
  end?(end: DocumentEnd): void | Promise<void>;
}
interface Doctype {
  readonly name: string | null;
  readonly publicId: string | null;
  readonly systemId: string | null;
}
interface Element {
  tagName: string;
  readonly attributes: IterableIterator<string[]>;
  readonly removed: boolean;
  readonly namespaceURI: string;
  getAttribute(name: string): string | null;
  hasAttribute(name: string): boolean;
  setAttribute(name: string, value: string): Element;
  removeAttribute(name: string): Element;
  before(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Element;
  after(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Element;
  prepend(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Element;
  append(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Element;
  replace(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Element;
  remove(): Element;
  removeAndKeepContent(): Element;
  setInnerContent(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Element;
  onEndTag(handler: (tag: EndTag) => void | Promise<void>): void;
}
interface EndTag {
  name: string;
  before(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): EndTag;
  after(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): EndTag;
  remove(): EndTag;
}
interface Comment {
  text: string;
  readonly removed: boolean;
  before(content: string, options?: ContentOptions): Comment;
  after(content: string, options?: ContentOptions): Comment;
  replace(content: string, options?: ContentOptions): Comment;
  remove(): Comment;
}
interface Text {
  readonly text: string;
  readonly lastInTextNode: boolean;
  readonly removed: boolean;
  before(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Text;
  after(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Text;
  replace(
    content: string | ReadableStream | Response,
    options?: ContentOptions
  ): Text;
  remove(): Text;
}
interface DocumentEnd {
  append(content: string, options?: ContentOptions): DocumentEnd;
}
declare abstract class FetchEvent extends ExtendableEvent {
  readonly request: Request;
  respondWith(promise: Response | Promise<Response>): void;
  passThroughOnException(): void;
}
type HeadersInit =
  | Headers
  | Iterable<Iterable<string>>
  | Record<string, string>;
declare class Headers {
  constructor(init?: HeadersInit);
  get(name: string): string | null;
  getAll(name: string): string[];
  getSetCookie(): string[];
  has(name: string): boolean;
  set(name: string, value: string): void;
  append(name: string, value: string): void;
  delete(name: string): void;
  forEach<This = unknown>(
    callback: (this: This, value: string, key: string, parent: Headers) => void,
    thisArg?: This
  ): void;
  entries(): IterableIterator<[key: string, value: string]>;
  keys(): IterableIterator<string>;
  values(): IterableIterator<string>;
  [Symbol.iterator](): IterableIterator<[key: string, value: string]>;
}
type BodyInit =
  | ReadableStream<Uint8Array>
  | string
  | ArrayBuffer
  | ArrayBufferView
  | Blob
  | URLSearchParams
  | FormData;
declare abstract class Body {
  get body(): ReadableStream | null;
  get bodyUsed(): boolean;
  arrayBuffer(): Promise<ArrayBuffer>;
  bytes(): Promise<Uint8Array>;
  text(): Promise<string>;
  json<T>(): Promise<T>;
  formData(): Promise<FormData>;
  blob(): Promise<Blob>;
}
declare var Response: {
  prototype: Response;
  new (body?: BodyInit | null, init?: ResponseInit): Response;
  error(): Response;
  redirect(url: string, status?: number): Response;
  json(any: any, maybeInit?: ResponseInit | Response): Response;
};
interface Response extends Body {
  clone(): Response;
  status: number;
  statusText: string;
  headers: Headers;
  ok: boolean;
  redirected: boolean;
  url: string;
  webSocket: WebSocket | null;
  cf: any | undefined;
  type: 'default' | 'error';
}
interface ResponseInit {
  status?: number;
  statusText?: string;
  headers?: HeadersInit;
  cf?: any;
  webSocket?: WebSocket | null;
  encodeBody?: 'automatic' | 'manual';
}
type RequestInfo<CfHostMetadata = unknown, Cf = CfProperties<CfHostMetadata>> =
  | Request<CfHostMetadata, Cf>
  | string;
declare var Request: {
  prototype: Request;
  new <CfHostMetadata = unknown, Cf = CfProperties<CfHostMetadata>>(
    input: RequestInfo<CfProperties> | URL,
    init?: RequestInit<Cf>
  ): Request<CfHostMetadata, Cf>;
};
interface Request<CfHostMetadata = unknown, Cf = CfProperties<CfHostMetadata>>
  extends Body {
  clone(): Request<CfHostMetadata, Cf>;
  method: string;
  url: string;
  headers: Headers;
  redirect: string;
  fetcher: Fetcher | null;
  signal: AbortSignal;
  cf: Cf | undefined;
  integrity: string;
  keepalive: boolean;
  cache?: 'no-store';
}
interface RequestInit<Cf = CfProperties> {
  method?: string;
  headers?: HeadersInit;
  body?: BodyInit | null;
  redirect?: string;
  fetcher?: Fetcher | null;
  cf?: Cf;
  cache?: 'no-store';
  integrity?: string;
  signal?: AbortSignal | null;
  encodeResponseBody?: 'automatic' | 'manual';
}
type Service<T extends Rpc.WorkerEntrypointBranded | undefined = undefined> =
  Fetcher<T>;
type Fetcher<
  T extends Rpc.EntrypointBranded | undefined = undefined,
  Reserved extends string = never,
> = (T extends Rpc.EntrypointBranded
  ? Rpc.Provider<T, Reserved | 'fetch' | 'connect'>
  : unknown) & {
  fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
  connect(address: SocketAddress | string, options?: SocketOptions): Socket;
};
interface KVNamespaceListKey<Metadata, Key extends string = string> {
  name: Key;
  expiration?: number;
  metadata?: Metadata;
}
type KVNamespaceListResult<Metadata, Key extends string = string> =
  | {
      list_complete: false;
      keys: KVNamespaceListKey<Metadata, Key>[];
      cursor: string;
      cacheStatus: string | null;
    }
  | {
      list_complete: true;
      keys: KVNamespaceListKey<Metadata, Key>[];
      cacheStatus: string | null;
    };
interface KVNamespace<Key extends string = string> {
  get(
    key: Key,
    options?: Partial<KVNamespaceGetOptions<undefined>>
  ): Promise<string | null>;
  get(key: Key, type: 'text'): Promise<string | null>;
  get<ExpectedValue = unknown>(
    key: Key,
    type: 'json'
  ): Promise<ExpectedValue | null>;
  get(key: Key, type: 'arrayBuffer'): Promise<ArrayBuffer | null>;
  get(key: Key, type: 'stream'): Promise<ReadableStream | null>;
  get(
    key: Key,
    options?: KVNamespaceGetOptions<'text'>
  ): Promise<string | null>;
  get<ExpectedValue = unknown>(
    key: Key,
    options?: KVNamespaceGetOptions<'json'>
  ): Promise<ExpectedValue | null>;
  get(
    key: Key,
    options?: KVNamespaceGetOptions<'arrayBuffer'>
  ): Promise<ArrayBuffer | null>;
  get(
    key: Key,
    options?: KVNamespaceGetOptions<'stream'>
  ): Promise<ReadableStream | null>;
  get(key: Array<Key>, type: 'text'): Promise<Map<string, string | null>>;
  get<ExpectedValue = unknown>(
    key: Array<Key>,
    type: 'json'
  ): Promise<Map<string, ExpectedValue | null>>;
  get(
    key: Array<Key>,
    options?: Partial<KVNamespaceGetOptions<undefined>>
  ): Promise<Map<string, string | null>>;
  get(
    key: Array<Key>,
    options?: KVNamespaceGetOptions<'text'>
  ): Promise<Map<string, string | null>>;
  get<ExpectedValue = unknown>(
    key: Array<Key>,
    options?: KVNamespaceGetOptions<'json'>
  ): Promise<Map<string, ExpectedValue | null>>;
  list<Metadata = unknown>(
    options?: KVNamespaceListOptions
  ): Promise<KVNamespaceListResult<Metadata, Key>>;
  put(
    key: Key,
    value: string | ArrayBuffer | ArrayBufferView | ReadableStream,
    options?: KVNamespacePutOptions
  ): Promise<void>;
  getWithMetadata<Metadata = unknown>(
    key: Key,
    options?: Partial<KVNamespaceGetOptions<undefined>>
  ): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;
  getWithMetadata<Metadata = unknown>(
    key: Key,
    type: 'text'
  ): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;
  getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(
    key: Key,
    type: 'json'
  ): Promise<KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>;
  getWithMetadata<Metadata = unknown>(
    key: Key,
    type: 'arrayBuffer'
  ): Promise<KVNamespaceGetWithMetadataResult<ArrayBuffer, Metadata>>;
  getWithMetadata<Metadata = unknown>(
    key: Key,
    type: 'stream'
  ): Promise<KVNamespaceGetWithMetadataResult<ReadableStream, Metadata>>;
  getWithMetadata<Metadata = unknown>(
    key: Key,
    options: KVNamespaceGetOptions<'text'>
  ): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;
  getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(
    key: Key,
    options: KVNamespaceGetOptions<'json'>
  ): Promise<KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>;
  getWithMetadata<Metadata = unknown>(
    key: Key,
    options: KVNamespaceGetOptions<'arrayBuffer'>
  ): Promise<KVNamespaceGetWithMetadataResult<ArrayBuffer, Metadata>>;
  getWithMetadata<Metadata = unknown>(
    key: Key,
    options: KVNamespaceGetOptions<'stream'>
  ): Promise<KVNamespaceGetWithMetadataResult<ReadableStream, Metadata>>;
  getWithMetadata<Metadata = unknown>(
    key: Array<Key>,
    type: 'text'
  ): Promise<Map<string, KVNamespaceGetWithMetadataResult<string, Metadata>>>;
  getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(
    key: Array<Key>,
    type: 'json'
  ): Promise<
    Map<string, KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>
  >;
  getWithMetadata<Metadata = unknown>(
    key: Array<Key>,
    options?: Partial<KVNamespaceGetOptions<undefined>>
  ): Promise<Map<string, KVNamespaceGetWithMetadataResult<string, Metadata>>>;
  getWithMetadata<Metadata = unknown>(
    key: Array<Key>,
    options?: KVNamespaceGetOptions<'text'>
  ): Promise<Map<string, KVNamespaceGetWithMetadataResult<string, Metadata>>>;
  getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(
    key: Array<Key>,
    options?: KVNamespaceGetOptions<'json'>
  ): Promise<
    Map<string, KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>
  >;
  delete(key: Key): Promise<void>;
}
interface KVNamespaceListOptions {
  limit?: number;
  prefix?: string | null;
  cursor?: string | null;
}
interface KVNamespaceGetOptions<Type> {
  type: Type;
  cacheTtl?: number;
}
interface KVNamespacePutOptions {
  expiration?: number;
  expirationTtl?: number;
  metadata?: any | null;
}
interface KVNamespaceGetWithMetadataResult<Value, Metadata> {
  value: Value | null;
  metadata: Metadata | null;
  cacheStatus: string | null;
}
type QueueContentType = 'text' | 'bytes' | 'json' | 'v8';
interface Queue<Body = unknown> {
  send(message: Body, options?: QueueSendOptions): Promise<void>;
  sendBatch(
    messages: Iterable<MessageSendRequest<Body>>,
    options?: QueueSendBatchOptions
  ): Promise<void>;
}
interface QueueSendOptions {
  contentType?: QueueContentType;
  delaySeconds?: number;
}
interface QueueSendBatchOptions {
  delaySeconds?: number;
}
interface MessageSendRequest<Body = unknown> {
  body: Body;
  contentType?: QueueContentType;
  delaySeconds?: number;
}
interface QueueRetryOptions {
  delaySeconds?: number;
}
interface Message<Body = unknown> {
  readonly id: string;
  readonly timestamp: Date;
  readonly body: Body;
  readonly attempts: number;
  retry(options?: QueueRetryOptions): void;
  ack(): void;
}
interface QueueEvent<Body = unknown> extends ExtendableEvent {
  readonly messages: readonly Message<Body>[];
  readonly queue: string;
  retryAll(options?: QueueRetryOptions): void;
  ackAll(): void;
}
interface MessageBatch<Body = unknown> {
  readonly messages: readonly Message<Body>[];
  readonly queue: string;
  retryAll(options?: QueueRetryOptions): void;
  ackAll(): void;
}
interface R2Error extends Error {
  readonly name: string;
  readonly code: number;
  readonly message: string;
  readonly action: string;
  readonly stack: any;
}
interface R2ListOptions {
  limit?: number;
  prefix?: string;
  cursor?: string;
  delimiter?: string;
  startAfter?: string;
  include?: ('httpMetadata' | 'customMetadata')[];
}
declare abstract class R2Bucket {
  head(key: string): Promise<R2Object | null>;
  get(
    key: string,
    options: R2GetOptions & {
      onlyIf: R2Conditional | Headers;
    }
  ): Promise<R2ObjectBody | R2Object | null>;
  get(key: string, options?: R2GetOptions): Promise<R2ObjectBody | null>;
  put(
    key: string,
    value:
      | ReadableStream
      | ArrayBuffer
      | ArrayBufferView
      | string
      | null
      | Blob,
    options?: R2PutOptions & {
      onlyIf: R2Conditional | Headers;
    }
  ): Promise<R2Object | null>;
  put(
    key: string,
    value:
      | ReadableStream
      | ArrayBuffer
      | ArrayBufferView
      | string
      | null
      | Blob,
    options?: R2PutOptions
  ): Promise<R2Object>;
  createMultipartUpload(
    key: string,
    options?: R2MultipartOptions
  ): Promise<R2MultipartUpload>;
  resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;
  delete(keys: string | string[]): Promise<void>;
  list(options?: R2ListOptions): Promise<R2Objects>;
}
interface R2MultipartUpload {
  readonly key: string;
  readonly uploadId: string;
  uploadPart(
    partNumber: number,
    value: ReadableStream | (ArrayBuffer | ArrayBufferView) | string | Blob,
    options?: R2UploadPartOptions
  ): Promise<R2UploadedPart>;
  abort(): Promise<void>;
  complete(uploadedParts: R2UploadedPart[]): Promise<R2Object>;
}
interface R2UploadedPart {
  partNumber: number;
  etag: string;
}
declare abstract class R2Object {
  readonly key: string;
  readonly version: string;
  readonly size: number;
  readonly etag: string;
  readonly httpEtag: string;
  readonly checksums: R2Checksums;
  readonly uploaded: Date;
  readonly httpMetadata?: R2HTTPMetadata;
  readonly customMetadata?: Record<string, string>;
  readonly range?: R2Range;
  readonly storageClass: string;
  readonly ssecKeyMd5?: string;
  writeHttpMetadata(headers: Headers): void;
}
interface R2ObjectBody extends R2Object {
  get body(): ReadableStream;
  get bodyUsed(): boolean;
  arrayBuffer(): Promise<ArrayBuffer>;
  text(): Promise<string>;
  json<T>(): Promise<T>;
  blob(): Promise<Blob>;
}
type R2Range =
  | {
      offset: number;
      length?: number;
    }
  | {
      offset?: number;
      length: number;
    }
  | {
      suffix: number;
    };
interface R2Conditional {
  etagMatches?: string;
  etagDoesNotMatch?: string;
  uploadedBefore?: Date;
  uploadedAfter?: Date;
  secondsGranularity?: boolean;
}
interface R2GetOptions {
  onlyIf?: R2Conditional | Headers;
  range?: R2Range | Headers;
  ssecKey?: ArrayBuffer | string;
}
interface R2PutOptions {
  onlyIf?: R2Conditional | Headers;
  httpMetadata?: R2HTTPMetadata | Headers;
  customMetadata?: Record<string, string>;
  md5?: (ArrayBuffer | ArrayBufferView) | string;
  sha1?: (ArrayBuffer | ArrayBufferView) | string;
  sha256?: (ArrayBuffer | ArrayBufferView) | string;
  sha384?: (ArrayBuffer | ArrayBufferView) | string;
  sha512?: (ArrayBuffer | ArrayBufferView) | string;
  storageClass?: string;
  ssecKey?: ArrayBuffer | string;
}
interface R2MultipartOptions {
  httpMetadata?: R2HTTPMetadata | Headers;
  customMetadata?: Record<string, string>;
  storageClass?: string;
  ssecKey?: ArrayBuffer | string;
}
interface R2Checksums {
  readonly md5?: ArrayBuffer;
  readonly sha1?: ArrayBuffer;
  readonly sha256?: ArrayBuffer;
  readonly sha384?: ArrayBuffer;
  readonly sha512?: ArrayBuffer;
  toJSON(): R2StringChecksums;
}
interface R2StringChecksums {
  md5?: string;
  sha1?: string;
  sha256?: string;
  sha384?: string;
  sha512?: string;
}
interface R2HTTPMetadata {
  contentType?: string;
  contentLanguage?: string;
  contentDisposition?: string;
  contentEncoding?: string;
  cacheControl?: string;
  cacheExpiry?: Date;
}
type R2Objects = {
  objects: R2Object[];
  delimitedPrefixes: string[];
} & (
  | {
      truncated: true;
      cursor: string;
    }
  | {
      truncated: false;
    }
);
interface R2UploadPartOptions {
  ssecKey?: ArrayBuffer | string;
}
declare abstract class ScheduledEvent extends ExtendableEvent {
  readonly scheduledTime: number;
  readonly cron: string;
  noRetry(): void;
}
interface ScheduledController {
  readonly scheduledTime: number;
  readonly cron: string;
  noRetry(): void;
}
interface QueuingStrategy<T = any> {
  highWaterMark?: number | bigint;
  size?: (chunk: T) => number | bigint;
}
interface UnderlyingSink<W = any> {
  type?: string;
  start?: (controller: WritableStreamDefaultController) => void | Promise<void>;
  write?: (
    chunk: W,
    controller: WritableStreamDefaultController
  ) => void | Promise<void>;
  abort?: (reason: any) => void | Promise<void>;
  close?: () => void | Promise<void>;
}
interface UnderlyingByteSource {
  type: 'bytes';
  autoAllocateChunkSize?: number;
  start?: (controller: ReadableByteStreamController) => void | Promise<void>;
  pull?: (controller: ReadableByteStreamController) => void | Promise<void>;
  cancel?: (reason: any) => void | Promise<void>;
}
interface UnderlyingSource<R = any> {
  type?: '' | undefined;
  start?: (
    controller: ReadableStreamDefaultController<R>
  ) => void | Promise<void>;
  pull?: (
    controller: ReadableStreamDefaultController<R>
  ) => void | Promise<void>;
  cancel?: (reason: any) => void | Promise<void>;
  expectedLength?: number | bigint;
}
interface Transformer<I = any, O = any> {
  readableType?: string;
  writableType?: string;
  start?: (
    controller: TransformStreamDefaultController<O>
  ) => void | Promise<void>;
  transform?: (
    chunk: I,
    controller: TransformStreamDefaultController<O>
  ) => void | Promise<void>;
  flush?: (
    controller: TransformStreamDefaultController<O>
  ) => void | Promise<void>;
  cancel?: (reason: any) => void | Promise<void>;
  expectedLength?: number;
}
interface StreamPipeOptions {
  /**
   * Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.
   *
   * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
   *
   * Errors and closures of the source and destination streams propagate as follows:
   *
   * An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source's error, or with any error that occurs during aborting the destination.
   *
   * An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination's error, or with any error that occurs during canceling the source.
   *
   * When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.
   *
   * If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.
   *
   * The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.
   */
  preventClose?: boolean;
  preventAbort?: boolean;
  preventCancel?: boolean;
  signal?: AbortSignal;
}
type ReadableStreamReadResult<R = any> =
  | {
      done: false;
      value: R;
    }
  | {
      done: true;
      value?: undefined;
    };
interface ReadableStream<R = any> {
  get locked(): boolean;
  cancel(reason?: any): Promise<void>;
  getReader(): ReadableStreamDefaultReader<R>;
  getReader(options: ReadableStreamGetReaderOptions): ReadableStreamBYOBReader;
  pipeThrough<T>(
    transform: ReadableWritablePair<T, R>,
    options?: StreamPipeOptions
  ): ReadableStream<T>;
  pipeTo(
    destination: WritableStream<R>,
    options?: StreamPipeOptions
  ): Promise<void>;
  tee(): [ReadableStream<R>, ReadableStream<R>];
  values(options?: ReadableStreamValuesOptions): AsyncIterableIterator<R>;
  [Symbol.asyncIterator](
    options?: ReadableStreamValuesOptions
  ): AsyncIterableIterator<R>;
}
declare const ReadableStream: {
  prototype: ReadableStream;
  new (
    underlyingSource: UnderlyingByteSource,
    strategy?: QueuingStrategy<Uint8Array>
  ): ReadableStream<Uint8Array>;
  new <R = any>(
    underlyingSource?: UnderlyingSource<R>,
    strategy?: QueuingStrategy<R>
  ): ReadableStream<R>;
};
declare class ReadableStreamDefaultReader<R = any> {
  constructor(stream: ReadableStream);
  get closed(): Promise<void>;
  cancel(reason?: any): Promise<void>;
  read(): Promise<ReadableStreamReadResult<R>>;
  releaseLock(): void;
}
declare class ReadableStreamBYOBReader {
  constructor(stream: ReadableStream);
  get closed(): Promise<void>;
  cancel(reason?: any): Promise<void>;
  read<T extends ArrayBufferView>(
    view: T
  ): Promise<ReadableStreamReadResult<T>>;
  releaseLock(): void;
  readAtLeast<T extends ArrayBufferView>(
    minElements: number,
    view: T
  ): Promise<ReadableStreamReadResult<T>>;
}
interface ReadableStreamBYOBReaderReadableStreamBYOBReaderReadOptions {
  min?: number;
}
interface ReadableStreamGetReaderOptions {
  mode: 'byob';
}
declare abstract class ReadableStreamBYOBRequest {
  get view(): Uint8Array | null;
  respond(bytesWritten: number): void;
  respondWithNewView(view: ArrayBuffer | ArrayBufferView): void;
  get atLeast(): number | null;
}
declare abstract class ReadableStreamDefaultController<R = any> {
  get desiredSize(): number | null;
  close(): void;
  enqueue(chunk?: R): void;
  error(reason: any): void;
}
declare abstract class ReadableByteStreamController {
  get byobRequest(): ReadableStreamBYOBRequest | null;
  get desiredSize(): number | null;
  close(): void;
  enqueue(chunk: ArrayBuffer | ArrayBufferView): void;
  error(reason: any): void;
}
declare abstract class WritableStreamDefaultController {
  get signal(): AbortSignal;
  error(reason?: any): void;
}
declare abstract class TransformStreamDefaultController<O = any> {
  get desiredSize(): number | null;
  enqueue(chunk?: O): void;
  error(reason: any): void;
  terminate(): void;
}
interface ReadableWritablePair<R = any, W = any> {
  writable: WritableStream<W>;
  readable: ReadableStream<R>;
}
declare class WritableStream<W = any> {
  constructor(
    underlyingSink?: UnderlyingSink,
    queuingStrategy?: QueuingStrategy
  );
  get locked(): boolean;
  abort(reason?: any): Promise<void>;
  close(): Promise<void>;
  getWriter(): WritableStreamDefaultWriter<W>;
}
declare class WritableStreamDefaultWriter<W = any> {
  constructor(stream: WritableStream);
  get closed(): Promise<void>;
  get ready(): Promise<void>;
  get desiredSize(): number | null;
  abort(reason?: any): Promise<void>;
  close(): Promise<void>;
  write(chunk?: W): Promise<void>;
  releaseLock(): void;
}
declare class TransformStream<I = any, O = any> {
  constructor(
    transformer?: Transformer<I, O>,
    writableStrategy?: QueuingStrategy<I>,
    readableStrategy?: QueuingStrategy<O>
  );
  get readable(): ReadableStream<O>;
  get writable(): WritableStream<I>;
}
declare class FixedLengthStream extends IdentityTransformStream {
  constructor(
    expectedLength: number | bigint,
    queuingStrategy?: IdentityTransformStreamQueuingStrategy
  );
}
declare class IdentityTransformStream extends TransformStream<
  ArrayBuffer | ArrayBufferView,
  Uint8Array
> {
  constructor(queuingStrategy?: IdentityTransformStreamQueuingStrategy);
}
interface IdentityTransformStreamQueuingStrategy {
  highWaterMark?: number | bigint;
}
interface ReadableStreamValuesOptions {
  preventCancel?: boolean;
}
declare class CompressionStream extends TransformStream<
  ArrayBuffer | ArrayBufferView,
  Uint8Array
> {
  constructor(format: 'gzip' | 'deflate' | 'deflate-raw');
}
declare class DecompressionStream extends TransformStream<
  ArrayBuffer | ArrayBufferView,
  Uint8Array
> {
  constructor(format: 'gzip' | 'deflate' | 'deflate-raw');
}
declare class TextEncoderStream extends TransformStream<string, Uint8Array> {
  constructor();
  get encoding(): string;
}
declare class TextDecoderStream extends TransformStream<
  ArrayBuffer | ArrayBufferView,
  string
> {
  constructor(label?: string, options?: TextDecoderStreamTextDecoderStreamInit);
  get encoding(): string;
  get fatal(): boolean;
  get ignoreBOM(): boolean;
}
interface TextDecoderStreamTextDecoderStreamInit {
  fatal?: boolean;
  ignoreBOM?: boolean;
}
declare class ByteLengthQueuingStrategy
  implements QueuingStrategy<ArrayBufferView>
{
  constructor(init: QueuingStrategyInit);
  get highWaterMark(): number;
  get size(): (chunk?: any) => number;
}
declare class CountQueuingStrategy implements QueuingStrategy {
  constructor(init: QueuingStrategyInit);
  get highWaterMark(): number;
  get size(): (chunk?: any) => number;
}
interface QueuingStrategyInit {
  highWaterMark: number;
}
interface ScriptVersion {
  id?: string;
  tag?: string;
  message?: string;
}
declare abstract class TailEvent extends ExtendableEvent {
  readonly events: TraceItem[];
  readonly traces: TraceItem[];
}
interface TraceItem {
  readonly event:
    | (
        | TraceItemFetchEventInfo
        | TraceItemJsRpcEventInfo
        | TraceItemScheduledEventInfo
        | TraceItemAlarmEventInfo
        | TraceItemQueueEventInfo
        | TraceItemEmailEventInfo
        | TraceItemTailEventInfo
        | TraceItemCustomEventInfo
        | TraceItemHibernatableWebSocketEventInfo
      )
    | null;
  readonly eventTimestamp: number | null;
  readonly logs: TraceLog[];
  readonly exceptions: TraceException[];
  readonly diagnosticsChannelEvents: TraceDiagnosticChannelEvent[];
  readonly scriptName: string | null;
  readonly entrypoint?: string;
  readonly scriptVersion?: ScriptVersion;
  readonly dispatchNamespace?: string;
  readonly scriptTags?: string[];
  readonly outcome: string;
  readonly executionModel: string;
  readonly truncated: boolean;
  readonly cpuTime: number;
  readonly wallTime: number;
}
interface TraceItemAlarmEventInfo {
  readonly scheduledTime: Date;
}
interface TraceItemCustomEventInfo {}
interface TraceItemScheduledEventInfo {
  readonly scheduledTime: number;
  readonly cron: string;
}
interface TraceItemQueueEventInfo {
  readonly queue: string;
  readonly batchSize: number;
}
interface TraceItemEmailEventInfo {
  readonly mailFrom: string;
  readonly rcptTo: string;
  readonly rawSize: number;
}
interface TraceItemTailEventInfo {
  readonly consumedEvents: TraceItemTailEventInfoTailItem[];
}
interface TraceItemTailEventInfoTailItem {
  readonly scriptName: string | null;
}
interface TraceItemFetchEventInfo {
  readonly response?: TraceItemFetchEventInfoResponse;
  readonly request: TraceItemFetchEventInfoRequest;
}
interface TraceItemFetchEventInfoRequest {
  readonly cf?: any;
  readonly headers: Record<string, string>;
  readonly method: string;
  readonly url: string;
  getUnredacted(): TraceItemFetchEventInfoRequest;
}
interface TraceItemFetchEventInfoResponse {
  readonly status: number;
}
interface TraceItemJsRpcEventInfo {
  readonly rpcMethod: string;
}
interface TraceItemHibernatableWebSocketEventInfo {
  readonly getWebSocketEvent:
    | TraceItemHibernatableWebSocketEventInfoMessage
    | TraceItemHibernatableWebSocketEventInfoClose
    | TraceItemHibernatableWebSocketEventInfoError;
}
interface TraceItemHibernatableWebSocketEventInfoMessage {
  readonly webSocketEventType: string;
}
interface TraceItemHibernatableWebSocketEventInfoClose {
  readonly webSocketEventType: string;
  readonly code: number;
  readonly wasClean: boolean;
}
interface TraceItemHibernatableWebSocketEventInfoError {
  readonly webSocketEventType: string;
}
interface TraceLog {
  readonly timestamp: number;
  readonly level: string;
  readonly message: any;
}
interface TraceException {
  readonly timestamp: number;
  readonly message: string;
  readonly name: string;
  readonly stack?: string;
}
interface TraceDiagnosticChannelEvent {
  readonly timestamp: number;
  readonly channel: string;
  readonly message: any;
}
interface TraceMetrics {
  readonly cpuTime: number;
  readonly wallTime: number;
}
interface UnsafeTraceMetrics {
  fromTrace(item: TraceItem): TraceMetrics;
}
declare class URL {
  constructor(url: string | URL, base?: string | URL);
  get origin(): string;
  get href(): string;
  set href(value: string);
  get protocol(): string;
  set protocol(value: string);
  get username(): string;
  set username(value: string);
  get password(): string;
  set password(value: string);
  get host(): string;
  set host(value: string);
  get hostname(): string;
  set hostname(value: string);
  get port(): string;
  set port(value: string);
  get pathname(): string;
  set pathname(value: string);
  get search(): string;
  set search(value: string);
  get hash(): string;
  set hash(value: string);
  get searchParams(): URLSearchParams;
  toJSON(): string;
  toString(): string;
  static canParse(url: string, base?: string): boolean;
  static parse(url: string, base?: string): URL | null;
  static createObjectURL(object: File | Blob): string;
  static revokeObjectURL(object_url: string): void;
}
declare class URLSearchParams {
  constructor(
    init?: Iterable<Iterable<string>> | Record<string, string> | string
  );
  get size(): number;
  append(name: string, value: string): void;
  delete(name: string, value?: string): void;
  get(name: string): string | null;
  getAll(name: string): string[];
  has(name: string, value?: string): boolean;
  set(name: string, value: string): void;
  sort(): void;
  entries(): IterableIterator<[key: string, value: string]>;
  keys(): IterableIterator<string>;
  values(): IterableIterator<string>;
  forEach<This = unknown>(
    callback: (
      this: This,
      value: string,
      key: string,
      parent: URLSearchParams
    ) => void,
    thisArg?: This
  ): void;
  toString(): string;
  [Symbol.iterator](): IterableIterator<[key: string, value: string]>;
}
declare class URLPattern {
  constructor(
    input?: string | URLPatternInit,
    baseURL?: string | URLPatternOptions,
    patternOptions?: URLPatternOptions
  );
  get protocol(): string;
  get username(): string;
  get password(): string;
  get hostname(): string;
  get port(): string;
  get pathname(): string;
  get search(): string;
  get hash(): string;
  get hasRegExpGroups(): boolean;
  test(input?: string | URLPatternInit, baseURL?: string): boolean;
  exec(
    input?: string | URLPatternInit,
    baseURL?: string
  ): URLPatternResult | null;
}
interface URLPatternInit {
  protocol?: string;
  username?: string;
  password?: string;
  hostname?: string;
  port?: string;
  pathname?: string;
  search?: string;
  hash?: string;
  baseURL?: string;
}
interface URLPatternComponentResult {
  input: string;
  groups: Record<string, string>;
}
interface URLPatternResult {
  inputs: (string | URLPatternInit)[];
  protocol: URLPatternComponentResult;
  username: URLPatternComponentResult;
  password: URLPatternComponentResult;
  hostname: URLPatternComponentResult;
  port: URLPatternComponentResult;
  pathname: URLPatternComponentResult;
  search: URLPatternComponentResult;
  hash: URLPatternComponentResult;
}
interface URLPatternOptions {
  ignoreCase?: boolean;
}
declare class CloseEvent extends Event {
  constructor(type: string, initializer?: CloseEventInit);
  readonly code: number;
  readonly reason: string;
  readonly wasClean: boolean;
}
interface CloseEventInit {
  code?: number;
  reason?: string;
  wasClean?: boolean;
}
declare class MessageEvent extends Event {
  constructor(type: string, initializer: MessageEventInit);
  readonly data: ArrayBuffer | string;
}
interface MessageEventInit {
  data: ArrayBuffer | string;
}
type WebSocketEventMap = {
  close: CloseEvent;
  message: MessageEvent;
  open: Event;
  error: ErrorEvent;
};
declare var WebSocket: {
  prototype: WebSocket;
  new (url: string, protocols?: string[] | string): WebSocket;
  readonly READY_STATE_CONNECTING: number;
  readonly CONNECTING: number;
  readonly READY_STATE_OPEN: number;
  readonly OPEN: number;
  readonly READY_STATE_CLOSING: number;
  readonly CLOSING: number;
  readonly READY_STATE_CLOSED: number;
  readonly CLOSED: number;
};
interface WebSocket extends EventTarget<WebSocketEventMap> {
  accept(): void;
  send(message: (ArrayBuffer | ArrayBufferView) | string): void;
  close(code?: number, reason?: string): void;
  serializeAttachment(attachment: any): void;
  deserializeAttachment(): any | null;
  readyState: number;
  url: string | null;
  protocol: string | null;
  extensions: string | null;
}
declare const WebSocketPair: {
  new (): {
    0: WebSocket;
    1: WebSocket;
  };
};
interface SqlStorage {
  exec<T extends Record<string, SqlStorageValue>>(
    query: string,
    ...bindings: any[]
  ): SqlStorageCursor<T>;
  get databaseSize(): number;
  Cursor: typeof SqlStorageCursor;
  Statement: typeof SqlStorageStatement;
}
declare abstract class SqlStorageStatement {}
type SqlStorageValue = ArrayBuffer | string | number | null;
declare abstract class SqlStorageCursor<
  T extends Record<string, SqlStorageValue>,
> {
  next():
    | {
        done?: false;
        value: T;
      }
    | {
        done: true;
        value?: never;
      };
  toArray(): T[];
  one(): T;
  raw<U extends SqlStorageValue[]>(): IterableIterator<U>;
  columnNames: string[];
  get rowsRead(): number;
  get rowsWritten(): number;
  [Symbol.iterator](): IterableIterator<T>;
}
interface Socket {
  get readable(): ReadableStream;
  get writable(): WritableStream;
  get closed(): Promise<void>;
  get opened(): Promise<SocketInfo>;
  get upgraded(): boolean;
  get secureTransport(): 'on' | 'off' | 'starttls';
  close(): Promise<void>;
  startTls(options?: TlsOptions): Socket;
}
interface SocketOptions {
  secureTransport?: string;
  allowHalfOpen: boolean;
  highWaterMark?: number | bigint;
}
interface SocketAddress {
  hostname: string;
  port: number;
}
interface TlsOptions {
  expectedServerHostname?: string;
}
interface SocketInfo {
  remoteAddress?: string;
  localAddress?: string;
}
declare class EventSource extends EventTarget {
  constructor(url: string, init?: EventSourceEventSourceInit);
  close(): void;
  get url(): string;
  get withCredentials(): boolean;
  get readyState(): number;
  get onopen(): any | null;
  set onopen(value: any | null);
  get onmessage(): any | null;
  set onmessage(value: any | null);
  get onerror(): any | null;
  set onerror(value: any | null);
  static readonly CONNECTING: number;
  static readonly OPEN: number;
  static readonly CLOSED: number;
  static from(stream: ReadableStream): EventSource;
}
interface EventSourceEventSourceInit {
  withCredentials?: boolean;
  fetcher?: Fetcher;
}
interface Container {
  get running(): boolean;
  start(options?: ContainerStartupOptions): void;
  monitor(): Promise<void>;
  destroy(error?: any): Promise<void>;
  signal(signo: number): void;
  getTcpPort(port: number): Fetcher;
}
interface ContainerStartupOptions {
  entrypoint?: string[];
  enableInternet: boolean;
  env?: Record<string, string>;
}
type AiImageClassificationInput = {
  image: number[];
};
type AiImageClassificationOutput = {
  score?: number;
  label?: string;
}[];
declare abstract class BaseAiImageClassification {
  inputs: AiImageClassificationInput;
  postProcessedOutputs: AiImageClassificationOutput;
}
type AiImageToTextInput = {
  image: number[];
  prompt?: string;
  max_tokens?: number;
  temperature?: number;
  top_p?: number;
  top_k?: number;
  seed?: number;
  repetition_penalty?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  raw?: boolean;
  messages?: RoleScopedChatInput[];
};
type AiImageToTextOutput = {
  description: string;
};
declare abstract class BaseAiImageToText {
  inputs: AiImageToTextInput;
  postProcessedOutputs: AiImageToTextOutput;
}
type AiImageTextToTextInput = {
  image: string;
  prompt?: string;
  max_tokens?: number;
  temperature?: number;
  ignore_eos?: boolean;
  top_p?: number;
  top_k?: number;
  seed?: number;
  repetition_penalty?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  raw?: boolean;
  messages?: RoleScopedChatInput[];
};
type AiImageTextToTextOutput = {
  description: string;
};
declare abstract class BaseAiImageTextToText {
  inputs: AiImageTextToTextInput;
  postProcessedOutputs: AiImageTextToTextOutput;
}
type AiObjectDetectionInput = {
  image: number[];
};
type AiObjectDetectionOutput = {
  score?: number;
  label?: string;
}[];
declare abstract class BaseAiObjectDetection {
  inputs: AiObjectDetectionInput;
  postProcessedOutputs: AiObjectDetectionOutput;
}
type AiSentenceSimilarityInput = {
  source: string;
  sentences: string[];
};
type AiSentenceSimilarityOutput = number[];
declare abstract class BaseAiSentenceSimilarity {
  inputs: AiSentenceSimilarityInput;
  postProcessedOutputs: AiSentenceSimilarityOutput;
}
type AiAutomaticSpeechRecognitionInput = {
  audio: number[];
};
type AiAutomaticSpeechRecognitionOutput = {
  text?: string;
  words?: {
    word: string;
    start: number;
    end: number;
  }[];
  vtt?: string;
};
declare abstract class BaseAiAutomaticSpeechRecognition {
  inputs: AiAutomaticSpeechRecognitionInput;
  postProcessedOutputs: AiAutomaticSpeechRecognitionOutput;
}
type AiSummarizationInput = {
  input_text: string;
  max_length?: number;
};
type AiSummarizationOutput = {
  summary: string;
};
declare abstract class BaseAiSummarization {
  inputs: AiSummarizationInput;
  postProcessedOutputs: AiSummarizationOutput;
}
type AiTextClassificationInput = {
  text: string;
};
type AiTextClassificationOutput = {
  score?: number;
  label?: string;
}[];
declare abstract class BaseAiTextClassification {
  inputs: AiTextClassificationInput;
  postProcessedOutputs: AiTextClassificationOutput;
}
type AiTextEmbeddingsInput = {
  text: string | string[];
};
type AiTextEmbeddingsOutput = {
  shape: number[];
  data: number[][];
};
declare abstract class BaseAiTextEmbeddings {
  inputs: AiTextEmbeddingsInput;
  postProcessedOutputs: AiTextEmbeddingsOutput;
}
type RoleScopedChatInput = {
  role:
    | 'user'
    | 'assistant'
    | 'system'
    | 'tool'
    | (string & NonNullable<unknown>);
  content: string;
  name?: string;
};
type AiTextGenerationToolLegacyInput = {
  name: string;
  description: string;
  parameters?: {
    type: 'object' | (string & NonNullable<unknown>);
    properties: {
      [key: string]: {
        type: string;
        description?: string;
      };
    };
    required: string[];
  };
};
type AiTextGenerationToolInput = {
  type: 'function' | (string & NonNullable<unknown>);
  function: {
    name: string;
    description: string;
    parameters?: {
      type: 'object' | (string & NonNullable<unknown>);
      properties: {
        [key: string]: {
          type: string;
          description?: string;
        };
      };
      required: string[];
    };
  };
};
type AiTextGenerationFunctionsInput = {
  name: string;
  code: string;
};
type AiTextGenerationResponseFormat = {
  type: string;
  json_schema?: any;
};
type AiTextGenerationInput = {
  prompt?: string;
  raw?: boolean;
  stream?: boolean;
  max_tokens?: number;
  temperature?: number;
  top_p?: number;
  top_k?: number;
  seed?: number;
  repetition_penalty?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  messages?: RoleScopedChatInput[];
  response_format?: AiTextGenerationResponseFormat;
  tools?:
    | AiTextGenerationToolInput[]
    | AiTextGenerationToolLegacyInput[]
    | (object & NonNullable<unknown>);
  functions?: AiTextGenerationFunctionsInput[];
};
type AiTextGenerationOutput =
  | {
      response?: string;
      tool_calls?: {
        name: string;
        arguments: unknown;
      }[];
    }
  | ReadableStream;
declare abstract class BaseAiTextGeneration {
  inputs: AiTextGenerationInput;
  postProcessedOutputs: AiTextGenerationOutput;
}
type AiTextToSpeechInput = {
  prompt: string;
  lang?: string;
};
type AiTextToSpeechOutput =
  | Uint8Array
  | {
      audio: string;
    };
declare abstract class BaseAiTextToSpeech {
  inputs: AiTextToSpeechInput;
  postProcessedOutputs: AiTextToSpeechOutput;
}
type AiTextToImageInput = {
  prompt: string;
  negative_prompt?: string;
  height?: number;
  width?: number;
  image?: number[];
  image_b64?: string;
  mask?: number[];
  num_steps?: number;
  strength?: number;
  guidance?: number;
  seed?: number;
};
type AiTextToImageOutput = ReadableStream<Uint8Array>;
declare abstract class BaseAiTextToImage {
  inputs: AiTextToImageInput;
  postProcessedOutputs: AiTextToImageOutput;
}
type AiTranslationInput = {
  text: string;
  target_lang: string;
  source_lang?: string;
};
type AiTranslationOutput = {
  translated_text?: string;
};
declare abstract class BaseAiTranslation {
  inputs: AiTranslationInput;
  postProcessedOutputs: AiTranslationOutput;
}
type Ai_Cf_Openai_Whisper_Input =
  | string
  | {
      audio: number[];
    };
interface Ai_Cf_Openai_Whisper_Output {
  text: string;
  word_count?: number;
  words?: {
    word?: string;
    start?: number;
    end?: number;
  }[];
  vtt?: string;
}
declare abstract class Base_Ai_Cf_Openai_Whisper {
  inputs: Ai_Cf_Openai_Whisper_Input;
  postProcessedOutputs: Ai_Cf_Openai_Whisper_Output;
}
type Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Input =
  | string
  | {
      prompt?: string;
      raw?: boolean;
      top_p?: number;
      top_k?: number;
      seed?: number;
      repetition_penalty?: number;
      frequency_penalty?: number;
      presence_penalty?: number;
      image: number[] | (string & NonNullable<unknown>);
      max_tokens?: number;
    };
interface Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Output {
  description?: string;
}
declare abstract class Base_Ai_Cf_Unum_Uform_Gen2_Qwen_500M {
  inputs: Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Input;
  postProcessedOutputs: Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Output;
}
type Ai_Cf_Openai_Whisper_Tiny_En_Input =
  | string
  | {
      audio: number[];
    };
interface Ai_Cf_Openai_Whisper_Tiny_En_Output {
  text: string;
  word_count?: number;
  words?: {
    word?: string;
    start?: number;
    end?: number;
  }[];
  vtt?: string;
}
declare abstract class Base_Ai_Cf_Openai_Whisper_Tiny_En {
  inputs: Ai_Cf_Openai_Whisper_Tiny_En_Input;
  postProcessedOutputs: Ai_Cf_Openai_Whisper_Tiny_En_Output;
}
interface Ai_Cf_Openai_Whisper_Large_V3_Turbo_Input {
  audio: string;
  task?: string;
  language?: string;
  vad_filter?: string;
  initial_prompt?: string;
  prefix?: string;
}
interface Ai_Cf_Openai_Whisper_Large_V3_Turbo_Output {
  transcription_info?: {
    language?: string;
    language_probability?: number;
    duration?: number;
    duration_after_vad?: number;
  };
  text: string;
  word_count?: number;
  segments?: {
    start?: number;
    end?: number;
    text?: string;
    temperature?: number;
    avg_logprob?: number;
    compression_ratio?: number;
    no_speech_prob?: number;
    words?: {
      word?: string;
      start?: number;
      end?: number;
    }[];
  }[];
  vtt?: string;
}
declare abstract class Base_Ai_Cf_Openai_Whisper_Large_V3_Turbo {
  inputs: Ai_Cf_Openai_Whisper_Large_V3_Turbo_Input;
  postProcessedOutputs: Ai_Cf_Openai_Whisper_Large_V3_Turbo_Output;
}
type Ai_Cf_Baai_Bge_M3_Input = BGEM3InputQueryAndContexts | BGEM3InputEmbedding;
interface BGEM3InputQueryAndContexts {
  query?: string;
  contexts: {
    text?: string;
  }[];
  truncate_inputs?: boolean;
}
interface BGEM3InputEmbedding {
  text: string | string[];
  truncate_inputs?: boolean;
}
type Ai_Cf_Baai_Bge_M3_Output =
  | BGEM3OuputQuery
  | BGEM3OutputEmbeddingForContexts
  | BGEM3OuputEmbedding;
interface BGEM3OuputQuery {
  response?: {
    id?: number;
    score?: number;
  }[];
}
interface BGEM3OutputEmbeddingForContexts {
  response?: number[][];
  shape?: number[];
  pooling?: 'mean' | 'cls';
}
interface BGEM3OuputEmbedding {
  shape?: number[];
  data?: number[][];
  pooling?: 'mean' | 'cls';
}
declare abstract class Base_Ai_Cf_Baai_Bge_M3 {
  inputs: Ai_Cf_Baai_Bge_M3_Input;
  postProcessedOutputs: Ai_Cf_Baai_Bge_M3_Output;
}
interface Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Input {
  prompt: string;
  steps?: number;
}
interface Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Output {
  image?: string;
}
declare abstract class Base_Ai_Cf_Black_Forest_Labs_Flux_1_Schnell {
  inputs: Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Input;
  postProcessedOutputs: Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Output;
}
type Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Input = Prompt | Messages;
interface Prompt {
  prompt: string;
  image?: number[] | (string & NonNullable<unknown>);
  raw?: boolean;
  stream?: boolean;
  max_tokens?: number;
  temperature?: number;
  top_p?: number;
  top_k?: number;
  seed?: number;
  repetition_penalty?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
  lora?: string;
}
interface Messages {
  messages: {
    role: string;
    content: string;
  }[];
  image?: number[] | string;
  functions?: {
    name: string;
    code: string;
  }[];
  tools?: (
    | {
        name: string;
        description: string;
        parameters: {
          type: string;
          required?: string[];
          properties: {
            [k: string]: {
              type: string;
              description: string;
            };
          };
        };
      }
    | {
        type: string;
        function: {
          name: string;
          description: string;
          parameters: {
            type: string;
            required?: string[];
            properties: {
              [k: string]: {
                type: string;
                description: string;
              };
            };
          };
        };
      }
  )[];
  stream?: boolean;
  max_tokens?: number;
  temperature?: number;
  top_p?: number;
  top_k?: number;
  seed?: number;
  repetition_penalty?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
}
type Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Output =
  | {
      response?: string;
      tool_calls?: {
        arguments?: object;
        name?: string;
      }[];
    }
  | ReadableStream;
declare abstract class Base_Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct {
  inputs: Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Input;
  postProcessedOutputs: Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Output;
}
interface Ai_Cf_Meta_Llama_Guard_3_8B_Input {
  messages: {
    role: 'user' | 'assistant';
    content: string;
  }[];
  max_tokens?: number;
  temperature?: number;
  response_format?: {
    type?: string;
  };
}
interface Ai_Cf_Meta_Llama_Guard_3_8B_Output {
  response?:
    | string
    | {
        safe?: boolean;
        categories?: string[];
      };
  usage?: {
    prompt_tokens?: number;
    completion_tokens?: number;
    total_tokens?: number;
  };
}
declare abstract class Base_Ai_Cf_Meta_Llama_Guard_3_8B {
  inputs: Ai_Cf_Meta_Llama_Guard_3_8B_Input;
  postProcessedOutputs: Ai_Cf_Meta_Llama_Guard_3_8B_Output;
}
interface Ai_Cf_Baai_Bge_Reranker_Base_Input {
  top_k?: number;
  contexts: {
    text?: string;
  }[];
}
interface Ai_Cf_Baai_Bge_Reranker_Base_Output {
  response?: {
    id?: number;
    score?: number;
  }[];
}
declare abstract class Base_Ai_Cf_Baai_Bge_Reranker_Base {
  inputs: Ai_Cf_Baai_Bge_Reranker_Base_Input;
  postProcessedOutputs: Ai_Cf_Baai_Bge_Reranker_Base_Output;
}
type Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Input =
  | Ai_Cf_Meta_Llama_4_Prompt
  | Ai_Cf_Meta_Llama_4_Messages;
interface Ai_Cf_Meta_Llama_4_Prompt {
  prompt: string;
  guided_json?: object;
  raw?: boolean;
  stream?: boolean;
  max_tokens?: number;
  temperature?: number;
  top_p?: number;
  top_k?: number;
  seed?: number;
  repetition_penalty?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
}
interface Ai_Cf_Meta_Llama_4_Messages {
  messages: {
    role?: string;
    tool_call_id?: string;
    content?:
      | string
      | {
          type?: string;
          text?: string;
          image_url?: {
            url?: string;
          };
        }[]
      | {
          type?: string;
          text?: string;
          image_url?: {
            url?: string;
          };
        };
  }[];
  functions?: {
    name: string;
    code: string;
  }[];
  tools?: (
    | {
        name: string;
        description: string;
        parameters: {
          type: string;
          required?: string[];
          properties: {
            [k: string]: {
              type: string;
              description: string;
            };
          };
        };
      }
    | {
        type: string;
        function: {
          name: string;
          description: string;
          parameters: {
            type: string;
            required?: string[];
            properties: {
              [k: string]: {
                type: string;
                description: string;
              };
            };
          };
        };
      }
  )[];
  guided_json?: object;
  raw?: boolean;
  stream?: boolean;
  max_tokens?: number;
  temperature?: number;
  top_p?: number;
  top_k?: number;
  seed?: number;
  repetition_penalty?: number;
  frequency_penalty?: number;
  presence_penalty?: number;
}
type Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Output =
  | {
      response: string;
      usage?: {
        prompt_tokens?: number;
        completion_tokens?: number;
        total_tokens?: number;
      };
      tool_calls?: {
        arguments?: object;
        name?: string;
      }[];
    }
  | string;
declare abstract class Base_Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct {
  inputs: Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Input;
  postProcessedOutputs: Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Output;
}
interface AiModels {
  '@cf/huggingface/distilbert-sst-2-int8': BaseAiTextClassification;
  '@cf/stabilityai/stable-diffusion-xl-base-1.0': BaseAiTextToImage;
  '@cf/runwayml/stable-diffusion-v1-5-inpainting': BaseAiTextToImage;
  '@cf/runwayml/stable-diffusion-v1-5-img2img': BaseAiTextToImage;
  '@cf/lykon/dreamshaper-8-lcm': BaseAiTextToImage;
  '@cf/bytedance/stable-diffusion-xl-lightning': BaseAiTextToImage;
  '@cf/myshell-ai/melotts': BaseAiTextToSpeech;
  '@cf/baai/bge-base-en-v1.5': BaseAiTextEmbeddings;
  '@cf/baai/bge-small-en-v1.5': BaseAiTextEmbeddings;
  '@cf/baai/bge-large-en-v1.5': BaseAiTextEmbeddings;
  '@cf/microsoft/resnet-50': BaseAiImageClassification;
  '@cf/facebook/detr-resnet-50': BaseAiObjectDetection;
  '@cf/meta/llama-2-7b-chat-int8': BaseAiTextGeneration;
  '@cf/mistral/mistral-7b-instruct-v0.1': BaseAiTextGeneration;
  '@cf/meta/llama-2-7b-chat-fp16': BaseAiTextGeneration;
  '@hf/thebloke/llama-2-13b-chat-awq': BaseAiTextGeneration;
  '@hf/thebloke/mistral-7b-instruct-v0.1-awq': BaseAiTextGeneration;
  '@hf/thebloke/zephyr-7b-beta-awq': BaseAiTextGeneration;
  '@hf/thebloke/openhermes-2.5-mistral-7b-awq': BaseAiTextGeneration;
  '@hf/thebloke/neural-chat-7b-v3-1-awq': BaseAiTextGeneration;
  '@hf/thebloke/llamaguard-7b-awq': BaseAiTextGeneration;
  '@hf/thebloke/deepseek-coder-6.7b-base-awq': BaseAiTextGeneration;
  '@hf/thebloke/deepseek-coder-6.7b-instruct-awq': BaseAiTextGeneration;
  '@cf/deepseek-ai/deepseek-math-7b-instruct': BaseAiTextGeneration;
  '@cf/defog/sqlcoder-7b-2': BaseAiTextGeneration;
  '@cf/openchat/openchat-3.5-0106': BaseAiTextGeneration;
  '@cf/tiiuae/falcon-7b-instruct': BaseAiTextGeneration;
  '@cf/thebloke/discolm-german-7b-v1-awq': BaseAiTextGeneration;
  '@cf/qwen/qwen1.5-0.5b-chat': BaseAiTextGeneration;
  '@cf/qwen/qwen1.5-7b-chat-awq': BaseAiTextGeneration;
  '@cf/qwen/qwen1.5-14b-chat-awq': BaseAiTextGeneration;
  '@cf/tinyllama/tinyllama-1.1b-chat-v1.0': BaseAiTextGeneration;
  '@cf/microsoft/phi-2': BaseAiTextGeneration;
  '@cf/qwen/qwen1.5-1.8b-chat': BaseAiTextGeneration;
  '@cf/mistral/mistral-7b-instruct-v0.2-lora': BaseAiTextGeneration;
  '@hf/nousresearch/hermes-2-pro-mistral-7b': BaseAiTextGeneration;
  '@hf/nexusflow/starling-lm-7b-beta': BaseAiTextGeneration;
  '@hf/google/gemma-7b-it': BaseAiTextGeneration;
  '@cf/meta-llama/llama-2-7b-chat-hf-lora': BaseAiTextGeneration;
  '@cf/google/gemma-2b-it-lora': BaseAiTextGeneration;
  '@cf/google/gemma-7b-it-lora': BaseAiTextGeneration;
  '@hf/mistral/mistral-7b-instruct-v0.2': BaseAiTextGeneration;
  '@cf/meta/llama-3-8b-instruct': BaseAiTextGeneration;
  '@cf/fblgit/una-cybertron-7b-v2-bf16': BaseAiTextGeneration;
  '@cf/meta/llama-3-8b-instruct-awq': BaseAiTextGeneration;
  '@hf/meta-llama/meta-llama-3-8b-instruct': BaseAiTextGeneration;
  '@cf/meta/llama-3.1-8b-instruct': BaseAiTextGeneration;
  '@cf/meta/llama-3.1-8b-instruct-fp8': BaseAiTextGeneration;
  '@cf/meta/llama-3.1-8b-instruct-awq': BaseAiTextGeneration;
  '@cf/meta/llama-3.2-3b-instruct': BaseAiTextGeneration;
  '@cf/meta/llama-3.2-1b-instruct': BaseAiTextGeneration;
  '@cf/meta/llama-3.3-70b-instruct-fp8-fast': BaseAiTextGeneration;
  '@cf/deepseek-ai/deepseek-r1-distill-qwen-32b': BaseAiTextGeneration;
  '@cf/meta/m2m100-1.2b': BaseAiTranslation;
  '@cf/facebook/bart-large-cnn': BaseAiSummarization;
  '@cf/llava-hf/llava-1.5-7b-hf': BaseAiImageToText;
  '@cf/openai/whisper': Base_Ai_Cf_Openai_Whisper;
  '@cf/unum/uform-gen2-qwen-500m': Base_Ai_Cf_Unum_Uform_Gen2_Qwen_500M;
  '@cf/openai/whisper-tiny-en': Base_Ai_Cf_Openai_Whisper_Tiny_En;
  '@cf/openai/whisper-large-v3-turbo': Base_Ai_Cf_Openai_Whisper_Large_V3_Turbo;
  '@cf/baai/bge-m3': Base_Ai_Cf_Baai_Bge_M3;
  '@cf/black-forest-labs/flux-1-schnell': Base_Ai_Cf_Black_Forest_Labs_Flux_1_Schnell;
  '@cf/meta/llama-3.2-11b-vision-instruct': Base_Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct;
  '@cf/meta/llama-guard-3-8b': Base_Ai_Cf_Meta_Llama_Guard_3_8B;
  '@cf/baai/bge-reranker-base': Base_Ai_Cf_Baai_Bge_Reranker_Base;
  '@cf/meta/llama-4-scout-17b-16e-instruct': Base_Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct;
}
type AiOptions = {
  gateway?: GatewayOptions;
  returnRawResponse?: boolean;
  prefix?: string;
  extraHeaders?: object;
};
type ConversionResponse = {
  name: string;
  mimeType: string;
  format: 'markdown';
  tokens: number;
  data: string;
};
type AiModelsSearchParams = {
  author?: string;
  hide_experimental?: boolean;
  page?: number;
  per_page?: number;
  search?: string;
  source?: number;
  task?: string;
};
type AiModelsSearchObject = {
  id: string;
  source: number;
  name: string;
  description: string;
  task: {
    id: string;
    name: string;
    description: string;
  };
  tags: string[];
  properties: {
    property_id: string;
    value: string;
  }[];
};
interface InferenceUpstreamError extends Error {}
interface AiInternalError extends Error {}
type AiModelListType = Record<string, any>;
declare abstract class Ai<AiModelList extends AiModelListType = AiModels> {
  aiGatewayLogId: string | null;
  gateway(gatewayId: string): AiGateway;
  autorag(autoragId: string): AutoRAG;
  run<Name extends keyof AiModelList, Options extends AiOptions>(
    model: Name,
    inputs: AiModelList[Name]['inputs'],
    options?: Options
  ): Promise<
    Options extends {
      returnRawResponse: true;
    }
      ? Response
      : AiModelList[Name]['postProcessedOutputs']
  >;
  models(params?: AiModelsSearchParams): Promise<AiModelsSearchObject[]>;
  toMarkdown(
    files: {
      name: string;
      blob: Blob;
    }[],
    options?: {
      gateway?: GatewayOptions;
      extraHeaders?: object;
    }
  ): Promise<ConversionResponse[]>;
  toMarkdown(
    files: {
      name: string;
      blob: Blob;
    },
    options?: {
      gateway?: GatewayOptions;
      extraHeaders?: object;
    }
  ): Promise<ConversionResponse>;
}
type GatewayRetries = {
  maxAttempts?: 1 | 2 | 3 | 4 | 5;
  retryDelayMs?: number;
  backoff?: 'constant' | 'linear' | 'exponential';
};
type GatewayOptions = {
  id: string;
  cacheKey?: string;
  cacheTtl?: number;
  skipCache?: boolean;
  metadata?: Record<string, number | string | boolean | null | bigint>;
  collectLog?: boolean;
  eventId?: string;
  requestTimeoutMs?: number;
  retries?: GatewayRetries;
};
type AiGatewayPatchLog = {
  score?: number | null;
  feedback?: -1 | 1 | null;
  metadata?: Record<string, number | string | boolean | null | bigint> | null;
};
type AiGatewayLog = {
  id: string;
  provider: string;
  model: string;
  model_type?: string;
  path: string;
  duration: number;
  request_type?: string;
  request_content_type?: string;
  status_code: number;
  response_content_type?: string;
  success: boolean;
  cached: boolean;
  tokens_in?: number;
  tokens_out?: number;
  metadata?: Record<string, number | string | boolean | null | bigint>;
  step?: number;
  cost?: number;
  custom_cost?: boolean;
  request_size: number;
  request_head?: string;
  request_head_complete: boolean;
  response_size: number;
  response_head?: string;
  response_head_complete: boolean;
  created_at: Date;
};
type AIGatewayProviders =
  | 'workers-ai'
  | 'anthropic'
  | 'aws-bedrock'
  | 'azure-openai'
  | 'google-vertex-ai'
  | 'huggingface'
  | 'openai'
  | 'perplexity-ai'
  | 'replicate'
  | 'groq'
  | 'cohere'
  | 'google-ai-studio'
  | 'mistral'
  | 'grok'
  | 'openrouter'
  | 'deepseek'
  | 'cerebras'
  | 'cartesia'
  | 'elevenlabs'
  | 'adobe-firefly';
type AIGatewayHeaders = {
  'cf-aig-metadata':
    | Record<string, number | string | boolean | null | bigint>
    | string;
  'cf-aig-custom-cost':
    | {
        per_token_in?: number;
        per_token_out?: number;
      }
    | {
        total_cost?: number;
      }
    | string;
  'cf-aig-cache-ttl': number | string;
  'cf-aig-skip-cache': boolean | string;
  'cf-aig-cache-key': string;
  'cf-aig-event-id': string;
  'cf-aig-request-timeout': number | string;
  'cf-aig-max-attempts': number | string;
  'cf-aig-retry-delay': number | string;
  'cf-aig-backoff': string;
  'cf-aig-collect-log': boolean | string;
  Authorization: string;
  'Content-Type': string;
  [key: string]: string | number | boolean | object;
};
type AIGatewayUniversalRequest = {
  provider: AIGatewayProviders | string;
  endpoint: string;
  headers: Partial<AIGatewayHeaders>;
  query: unknown;
};
interface AiGatewayInternalError extends Error {}
interface AiGatewayLogNotFound extends Error {}
declare abstract class AiGateway {
  patchLog(logId: string, data: AiGatewayPatchLog): Promise<void>;
  getLog(logId: string): Promise<AiGatewayLog>;
  run(
    data: AIGatewayUniversalRequest | AIGatewayUniversalRequest[],
    options?: {
      gateway?: GatewayOptions;
      extraHeaders?: object;
    }
  ): Promise<Response>;
  getUrl(provider?: AIGatewayProviders | string): Promise<string>;
}
interface AutoRAGInternalError extends Error {}
interface AutoRAGNotFoundError extends Error {}
interface AutoRAGUnauthorizedError extends Error {}
type ComparisonFilter = {
  key: string;
  type: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
  value: string | number | boolean;
};
type CompoundFilter = {
  type: 'and' | 'or';
  filters: ComparisonFilter[];
};
type AutoRagSearchRequest = {
  query: string;
  filters?: CompoundFilter | ComparisonFilter;
  max_num_results?: number;
  ranking_options?: {
    ranker?: string;
    score_threshold?: number;
  };
  rewrite_query?: boolean;
};
type AutoRagAiSearchRequest = AutoRagSearchRequest & {
  stream?: boolean;
};
type AutoRagAiSearchRequestStreaming = Omit<
  AutoRagAiSearchRequest,
  'stream'
> & {
  stream: true;
};
type AutoRagSearchResponse = {
  object: 'vector_store.search_results.page';
  search_query: string;
  data: {
    file_id: string;
    filename: string;
    score: number;
    attributes: Record<string, string | number | boolean | null>;
    content: {
      type: 'text';
      text: string;
    }[];
  }[];
  has_more: boolean;
  next_page: string | null;
};
type AutoRagAiSearchResponse = AutoRagSearchResponse & {
  response: string;
};
declare abstract class AutoRAG {
  search(params: AutoRagSearchRequest): Promise<AutoRagSearchResponse>;
  aiSearch(params: AutoRagAiSearchRequestStreaming): Promise<Response>;
  aiSearch(params: AutoRagAiSearchRequest): Promise<AutoRagAiSearchResponse>;
  aiSearch(
    params: AutoRagAiSearchRequest
  ): Promise<AutoRagAiSearchResponse | Response>;
}
interface BasicImageTransformations {
  width?: number;
  height?: number;
  fit?: 'scale-down' | 'contain' | 'cover' | 'crop' | 'pad' | 'squeeze';
  gravity?:
    | 'left'
    | 'right'
    | 'top'
    | 'bottom'
    | 'center'
    | 'auto'
    | 'entropy'
    | BasicImageTransformationsGravityCoordinates;
  background?: string;
  rotate?: 0 | 90 | 180 | 270 | 360;
}
interface BasicImageTransformationsGravityCoordinates {
  x?: number;
  y?: number;
  mode?: 'remainder' | 'box-center';
}
interface RequestInitCfProperties extends Record<string, unknown> {
  cacheEverything?: boolean;
  cacheKey?: string;
  cacheTags?: string[];
  cacheTtl?: number;
  cacheTtlByStatus?: Record<string, number>;
  scrapeShield?: boolean;
  apps?: boolean;
  image?: RequestInitCfPropertiesImage;
  minify?: RequestInitCfPropertiesImageMinify;
  mirage?: boolean;
  polish?: 'lossy' | 'lossless' | 'off';
  r2?: RequestInitCfPropertiesR2;
  resolveOverride?: string;
}
interface RequestInitCfPropertiesImageDraw extends BasicImageTransformations {
  url: string;
  opacity?: number;
  repeat?: true | 'x' | 'y';
  top?: number;
  left?: number;
  bottom?: number;
  right?: number;
}
interface RequestInitCfPropertiesImage extends BasicImageTransformations {
  dpr?: number;
  trim?:
    | 'border'
    | {
        top?: number;
        bottom?: number;
        left?: number;
        right?: number;
        width?: number;
        height?: number;
        border?:
          | boolean
          | {
              color?: string;
              tolerance?: number;
              keep?: number;
            };
      };
  quality?: number | 'low' | 'medium-low' | 'medium-high' | 'high';
  format?:
    | 'avif'
    | 'webp'
    | 'json'
    | 'jpeg'
    | 'png'
    | 'baseline-jpeg'
    | 'png-force'
    | 'svg';
  anim?: boolean;
  metadata?: 'keep' | 'copyright' | 'none';
  sharpen?: number;
  blur?: number;
  draw?: RequestInitCfPropertiesImageDraw[];
  'origin-auth'?: 'share-publicly';
  border?:
    | {
        color: string;
        width: number;
      }
    | {
        color: string;
        top: number;
        right: number;
        bottom: number;
        left: number;
      };
  brightness?: number;
  contrast?: number;
  gamma?: number;
  saturation?: number;
  flip?: 'h' | 'v' | 'hv';
  compression?: 'fast';
}
interface RequestInitCfPropertiesImageMinify {
  javascript?: boolean;
  css?: boolean;
  html?: boolean;
}
interface RequestInitCfPropertiesR2 {
  bucketColoId?: number;
}
type IncomingRequestCfProperties<HostMetadata = unknown> =
  IncomingRequestCfPropertiesBase &
    IncomingRequestCfPropertiesBotManagementEnterprise &
    IncomingRequestCfPropertiesCloudflareForSaaSEnterprise<HostMetadata> &
    IncomingRequestCfPropertiesGeographicInformation &
    IncomingRequestCfPropertiesCloudflareAccessOrApiShield;
interface IncomingRequestCfPropertiesBase extends Record<string, unknown> {
  asn: number;
  asOrganization: string;
  clientAcceptEncoding?: string;
  clientTcpRtt?: number;
  colo: string;
  edgeRequestKeepAliveStatus: IncomingRequestCfPropertiesEdgeRequestKeepAliveStatus;
  httpProtocol: string;
  requestPriority: string;
  tlsVersion: string;
  tlsCipher: string;
  tlsExportedAuthenticator?: IncomingRequestCfPropertiesExportedAuthenticatorMetadata;
}
interface IncomingRequestCfPropertiesBotManagementBase {
  score: number;
  verifiedBot: boolean;
  corporateProxy: boolean;
  staticResource: boolean;
  detectionIds: number[];
}
interface IncomingRequestCfPropertiesBotManagement {
  botManagement: IncomingRequestCfPropertiesBotManagementBase;
  clientTrustScore: number;
}
interface IncomingRequestCfPropertiesBotManagementEnterprise
  extends IncomingRequestCfPropertiesBotManagement {
  botManagement: IncomingRequestCfPropertiesBotManagementBase & {
    ja3Hash: string;
  };
}
interface IncomingRequestCfPropertiesCloudflareForSaaSEnterprise<HostMetadata> {
  hostMetadata: HostMetadata;
}
interface IncomingRequestCfPropertiesCloudflareAccessOrApiShield {
  tlsClientAuth:
    | IncomingRequestCfPropertiesTLSClientAuth
    | IncomingRequestCfPropertiesTLSClientAuthPlaceholder;
}
interface IncomingRequestCfPropertiesExportedAuthenticatorMetadata {
  clientHandshake: string;
  serverHandshake: string;
  clientFinished: string;
  serverFinished: string;
}
interface IncomingRequestCfPropertiesGeographicInformation {
  country?: Iso3166Alpha2Code | 'T1';
  isEUCountry?: '1';
  continent?: ContinentCode;
  city?: string;
  postalCode?: string;
  latitude?: string;
  longitude?: string;
  timezone?: string;
  region?: string;
  regionCode?: string;
  metroCode?: string;
}
interface IncomingRequestCfPropertiesTLSClientAuth {
  certPresented: '1';
  certVerified: Exclude<CertVerificationStatus, 'NONE'>;
  certRevoked: '1' | '0';
  certIssuerDN: string;
  certSubjectDN: string;
  certIssuerDNRFC2253: string;
  certSubjectDNRFC2253: string;
  certIssuerDNLegacy: string;
  certSubjectDNLegacy: string;
  certSerial: string;
  certIssuerSerial: string;
  certSKI: string;
  certIssuerSKI: string;
  certFingerprintSHA1: string;
  certFingerprintSHA256: string;
  certNotBefore: string;
  certNotAfter: string;
}
interface IncomingRequestCfPropertiesTLSClientAuthPlaceholder {
  certPresented: '0';
  certVerified: 'NONE';
  certRevoked: '0';
  certIssuerDN: '';
  certSubjectDN: '';
  certIssuerDNRFC2253: '';
  certSubjectDNRFC2253: '';
  certIssuerDNLegacy: '';
  certSubjectDNLegacy: '';
  certSerial: '';
  certIssuerSerial: '';
  certSKI: '';
  certIssuerSKI: '';
  certFingerprintSHA1: '';
  certFingerprintSHA256: '';
  certNotBefore: '';
  certNotAfter: '';
}
/** Possible outcomes of TLS verification */
declare type CertVerificationStatus =
  /** Authentication succeeded */
  | 'SUCCESS'
  | 'NONE'
  | 'FAILED:self signed certificate'
  | 'FAILED:unable to verify the first certificate'
  | 'FAILED:certificate is not yet valid'
  | 'FAILED:certificate has expired'
  | 'FAILED';
declare type IncomingRequestCfPropertiesEdgeRequestKeepAliveStatus =
  | 0
  | 1
  | 2
  | 3
  | 4
  | 5;
declare type Iso3166Alpha2Code =
  | 'AD'
  | 'AE'
  | 'AF'
  | 'AG'
  | 'AI'
  | 'AL'
  | 'AM'
  | 'AO'
  | 'AQ'
  | 'AR'
  | 'AS'
  | 'AT'
  | 'AU'
  | 'AW'
  | 'AX'
  | 'AZ'
  | 'BA'
  | 'BB'
  | 'BD'
  | 'BE'
  | 'BF'
  | 'BG'
  | 'BH'
  | 'BI'
  | 'BJ'
  | 'BL'
  | 'BM'
  | 'BN'
  | 'BO'
  | 'BQ'
  | 'BR'
  | 'BS'
  | 'BT'
  | 'BV'
  | 'BW'
  | 'BY'
  | 'BZ'
  | 'CA'
  | 'CC'
  | 'CD'
  | 'CF'
  | 'CG'
  | 'CH'
  | 'CI'
  | 'CK'
  | 'CL'
  | 'CM'
  | 'CN'
  | 'CO'
  | 'CR'
  | 'CU'
  | 'CV'
  | 'CW'
  | 'CX'
  | 'CY'
  | 'CZ'
  | 'DE'
  | 'DJ'
  | 'DK'
  | 'DM'
  | 'DO'
  | 'DZ'
  | 'EC'
  | 'EE'
  | 'EG'
  | 'EH'
  | 'ER'
  | 'ES'
  | 'ET'
  | 'FI'
  | 'FJ'
  | 'FK'
  | 'FM'
  | 'FO'
  | 'FR'
  | 'GA'
  | 'GB'
  | 'GD'
  | 'GE'
  | 'GF'
  | 'GG'
  | 'GH'
  | 'GI'
  | 'GL'
  | 'GM'
  | 'GN'
  | 'GP'
  | 'GQ'
  | 'GR'
  | 'GS'
  | 'GT'
  | 'GU'
  | 'GW'
  | 'GY'
  | 'HK'
  | 'HM'
  | 'HN'
  | 'HR'
  | 'HT'
  | 'HU'
  | 'ID'
  | 'IE'
  | 'IL'
  | 'IM'
  | 'IN'
  | 'IO'
  | 'IQ'
  | 'IR'
  | 'IS'
  | 'IT'
  | 'JE'
  | 'JM'
  | 'JO'
  | 'JP'
  | 'KE'
  | 'KG'
  | 'KH'
  | 'KI'
  | 'KM'
  | 'KN'
  | 'KP'
  | 'KR'
  | 'KW'
  | 'KY'
  | 'KZ'
  | 'LA'
  | 'LB'
  | 'LC'
  | 'LI'
  | 'LK'
  | 'LR'
  | 'LS'
  | 'LT'
  | 'LU'
  | 'LV'
  | 'LY'
  | 'MA'
  | 'MC'
  | 'MD'
  | 'ME'
  | 'MF'
  | 'MG'
  | 'MH'
  | 'MK'
  | 'ML'
  | 'MM'
  | 'MN'
  | 'MO'
  | 'MP'
  | 'MQ'
  | 'MR'
  | 'MS'
  | 'MT'
  | 'MU'
  | 'MV'
  | 'MW'
  | 'MX'
  | 'MY'
  | 'MZ'
  | 'NA'
  | 'NC'
  | 'NE'
  | 'NF'
  | 'NG'
  | 'NI'
  | 'NL'
  | 'NO'
  | 'NP'
  | 'NR'
  | 'NU'
  | 'NZ'
  | 'OM'
  | 'PA'
  | 'PE'
  | 'PF'
  | 'PG'
  | 'PH'
  | 'PK'
  | 'PL'
  | 'PM'
  | 'PN'
  | 'PR'
  | 'PS'
  | 'PT'
  | 'PW'
  | 'PY'
  | 'QA'
  | 'RE'
  | 'RO'
  | 'RS'
  | 'RU'
  | 'RW'
  | 'SA'
  | 'SB'
  | 'SC'
  | 'SD'
  | 'SE'
  | 'SG'
  | 'SH'
  | 'SI'
  | 'SJ'
  | 'SK'
  | 'SL'
  | 'SM'
  | 'SN'
  | 'SO'
  | 'SR'
  | 'SS'
  | 'ST'
  | 'SV'
  | 'SX'
  | 'SY'
  | 'SZ'
  | 'TC'
  | 'TD'
  | 'TF'
  | 'TG'
  | 'TH'
  | 'TJ'
  | 'TK'
  | 'TL'
  | 'TM'
  | 'TN'
  | 'TO'
  | 'TR'
  | 'TT'
  | 'TV'
  | 'TW'
  | 'TZ'
  | 'UA'
  | 'UG'
  | 'UM'
  | 'US'
  | 'UY'
  | 'UZ'
  | 'VA'
  | 'VC'
  | 'VE'
  | 'VG'
  | 'VI'
  | 'VN'
  | 'VU'
  | 'WF'
  | 'WS'
  | 'YE'
  | 'YT'
  | 'ZA'
  | 'ZM'
  | 'ZW';
declare type ContinentCode = 'AF' | 'AN' | 'AS' | 'EU' | 'NA' | 'OC' | 'SA';
type CfProperties<HostMetadata = unknown> =
  | IncomingRequestCfProperties<HostMetadata>
  | RequestInitCfProperties;
interface D1Meta {
  duration: number;
  size_after: number;
  rows_read: number;
  rows_written: number;
  last_row_id: number;
  changed_db: boolean;
  changes: number;
  served_by_region?: string;
  served_by_primary?: boolean;
  timings?: {
    sql_duration_ms: number;
  };
}
interface D1Response {
  success: true;
  meta: D1Meta & Record<string, unknown>;
  error?: never;
}
type D1Result<T = unknown> = D1Response & {
  results: T[];
};
interface D1ExecResult {
  count: number;
  duration: number;
}
type D1SessionConstraint =
  | 'first-primary'
  | 'first-unconstrained';
type D1SessionBookmark = string;
declare abstract class D1Database {
  prepare(query: string): D1PreparedStatement;
  batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
  exec(query: string): Promise<D1ExecResult>;
  withSession(
    constraintOrBookmark?: D1SessionBookmark | D1SessionConstraint
  ): D1DatabaseSession;
  dump(): Promise<ArrayBuffer>;
}
declare abstract class D1DatabaseSession {
  prepare(query: string): D1PreparedStatement;
  batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
  getBookmark(): D1SessionBookmark | null;
}
declare abstract class D1PreparedStatement {
  bind(...values: unknown[]): D1PreparedStatement;
  first<T = unknown>(colName: string): Promise<T | null>;
  first<T = Record<string, unknown>>(): Promise<T | null>;
  run<T = Record<string, unknown>>(): Promise<D1Result<T>>;
  all<T = Record<string, unknown>>(): Promise<D1Result<T>>;
  raw<T = unknown[]>(options: {
    columnNames: true;
  }): Promise<[string[], ...T[]]>;
  raw<T = unknown[]>(options?: { columnNames?: false }): Promise<T[]>;
}
interface Disposable {}
interface EmailMessage {
  readonly from: string;
  readonly to: string;
}
interface ForwardableEmailMessage extends EmailMessage {
  readonly raw: ReadableStream<Uint8Array>;
  readonly headers: Headers;
  readonly rawSize: number;
  setReject(reason: string): void;
  forward(rcptTo: string, headers?: Headers): Promise<void>;
  reply(message: EmailMessage): Promise<void>;
}
interface SendEmail {
  send(message: EmailMessage): Promise<void>;
}
declare abstract class EmailEvent extends ExtendableEvent {
  readonly message: ForwardableEmailMessage;
}
declare type EmailExportedHandler<Env = unknown> = (
  message: ForwardableEmailMessage,
  env: Env,
  ctx: ExecutionContext
) => void | Promise<void>;
declare module 'cloudflare:email' {
  let _EmailMessage: {
    prototype: EmailMessage;
    new (from: string, to: string, raw: ReadableStream | string): EmailMessage;
  };
  export { _EmailMessage as EmailMessage };
}
interface Hyperdrive {
  connect(): Socket;
  readonly connectionString: string;
  readonly host: string;
  readonly port: number;
  readonly user: string;
  readonly password: string;
  readonly database: string;
}
type ImageInfoResponse =
  | {
      format: 'image/svg+xml';
    }
  | {
      format: string;
      fileSize: number;
      width: number;
      height: number;
    };
type ImageTransform = {
  width?: number;
  height?: number;
  background?: string;
  blur?: number;
  border?:
    | {
        color?: string;
        width?: number;
      }
    | {
        top?: number;
        bottom?: number;
        left?: number;
        right?: number;
      };
  brightness?: number;
  contrast?: number;
  fit?: 'scale-down' | 'contain' | 'pad' | 'squeeze' | 'cover' | 'crop';
  flip?: 'h' | 'v' | 'hv';
  gamma?: number;
  gravity?:
    | 'left'
    | 'right'
    | 'top'
    | 'bottom'
    | 'center'
    | 'auto'
    | 'entropy'
    | {
        x?: number;
        y?: number;
        mode: 'remainder' | 'box-center';
      };
  rotate?: 0 | 90 | 180 | 270;
  saturation?: number;
  sharpen?: number;
  trim?:
    | 'border'
    | {
        top?: number;
        bottom?: number;
        left?: number;
        right?: number;
        width?: number;
        height?: number;
        border?:
          | boolean
          | {
              color?: string;
              tolerance?: number;
              keep?: number;
            };
      };
};
type ImageDrawOptions = {
  opacity?: number;
  repeat?: boolean | string;
  top?: number;
  left?: number;
  bottom?: number;
  right?: number;
};
type ImageOutputOptions = {
  format:
    | 'image/jpeg'
    | 'image/png'
    | 'image/gif'
    | 'image/webp'
    | 'image/avif'
    | 'rgb'
    | 'rgba';
  quality?: number;
  background?: string;
};
interface ImagesBinding {
  info(stream: ReadableStream<Uint8Array>): Promise<ImageInfoResponse>;
  input(stream: ReadableStream<Uint8Array>): ImageTransformer;
}
interface ImageTransformer {
  transform(transform: ImageTransform): ImageTransformer;
  draw(
    image: ReadableStream<Uint8Array> | ImageTransformer,
    options?: ImageDrawOptions
  ): ImageTransformer;
  output(options: ImageOutputOptions): Promise<ImageTransformationResult>;
}
interface ImageTransformationResult {
  response(): Response;
  contentType(): string;
  image(): ReadableStream<Uint8Array>;
}
interface ImagesError extends Error {
  readonly code: number;
  readonly message: string;
  readonly stack?: string;
}
type Params<P extends string = any> = Record<P, string | string[]>;
type EventContext<Env, P extends string, Data> = {
  request: Request<unknown, IncomingRequestCfProperties<unknown>>;
  functionPath: string;
  waitUntil: (promise: Promise<any>) => void;
  passThroughOnException: () => void;
  next: (input?: Request | string, init?: RequestInit) => Promise<Response>;
  env: Env & {
    ASSETS: {
      fetch: typeof fetch;
    };
  };
  params: Params<P>;
  data: Data;
};
type PagesFunction<
  Env = unknown,
  Params extends string = any,
  Data extends Record<string, unknown> = Record<string, unknown>,
> = (context: EventContext<Env, Params, Data>) => Response | Promise<Response>;
type EventPluginContext<Env, P extends string, Data, PluginArgs> = {
  request: Request<unknown, IncomingRequestCfProperties<unknown>>;
  functionPath: string;
  waitUntil: (promise: Promise<any>) => void;
  passThroughOnException: () => void;
  next: (input?: Request | string, init?: RequestInit) => Promise<Response>;
  env: Env & {
    ASSETS: {
      fetch: typeof fetch;
    };
  };
  params: Params<P>;
  data: Data;
  pluginArgs: PluginArgs;
};
type PagesPluginFunction<
  Env = unknown,
  Params extends string = any,
  Data extends Record<string, unknown> = Record<string, unknown>,
  PluginArgs = unknown,
> = (
  context: EventPluginContext<Env, Params, Data, PluginArgs>
) => Response | Promise<Response>;
declare module 'assets:*' {
  export const onRequest: PagesFunction;
}
declare module 'cloudflare:pipelines' {
  export abstract class PipelineTransformationEntrypoint<
    Env = unknown,
    I extends PipelineRecord = PipelineRecord,
    O extends PipelineRecord = PipelineRecord,
  > {
    protected env: Env;
    protected ctx: ExecutionContext;
    constructor(ctx: ExecutionContext, env: Env);
    public run(records: I[], metadata: PipelineBatchMetadata): Promise<O[]>;
  }
  export type PipelineRecord = Record<string, unknown>;
  export type PipelineBatchMetadata = {
    pipelineId: string;
    pipelineName: string;
  };
  export interface Pipeline<T extends PipelineRecord = PipelineRecord> {
    send(records: T[]): Promise<void>;
  }
}
interface PubSubMessage {
  readonly mid: number;
  readonly broker: string;
  readonly topic: string;
  readonly clientId: string;
  readonly jti?: string;
  readonly receivedAt: number;
  readonly contentType: string;
  readonly payloadFormatIndicator: number;
  payload: string | Uint8Array;
}
interface JsonWebKeyWithKid extends JsonWebKey {
  readonly kid: string;
}
interface RateLimitOptions {
  key: string;
}
interface RateLimitOutcome {
  success: boolean;
}
interface RateLimit {
  limit(options: RateLimitOptions): Promise<RateLimitOutcome>;
}
declare namespace Rpc {
  export const __RPC_STUB_BRAND: '__RPC_STUB_BRAND';
  export const __RPC_TARGET_BRAND: '__RPC_TARGET_BRAND';
  export const __WORKER_ENTRYPOINT_BRAND: '__WORKER_ENTRYPOINT_BRAND';
  export const __DURABLE_OBJECT_BRAND: '__DURABLE_OBJECT_BRAND';
  export const __WORKFLOW_ENTRYPOINT_BRAND: '__WORKFLOW_ENTRYPOINT_BRAND';
  export interface RpcTargetBranded {
    [__RPC_TARGET_BRAND]: never;
  }
  export interface WorkerEntrypointBranded {
    [__WORKER_ENTRYPOINT_BRAND]: never;
  }
  export interface DurableObjectBranded {
    [__DURABLE_OBJECT_BRAND]: never;
  }
  export interface WorkflowEntrypointBranded {
    [__WORKFLOW_ENTRYPOINT_BRAND]: never;
  }
  export type EntrypointBranded =
    | WorkerEntrypointBranded
    | DurableObjectBranded
    | WorkflowEntrypointBranded;
  export type Stubable = RpcTargetBranded | ((...args: any[]) => any);
  type Serializable<T> =
    | BaseType
    | Map<
        T extends Map<infer U, unknown> ? Serializable<U> : never,
        T extends Map<unknown, infer U> ? Serializable<U> : never
      >
    | Set<T extends Set<infer U> ? Serializable<U> : never>
    | ReadonlyArray<T extends ReadonlyArray<infer U> ? Serializable<U> : never>
    | {
        [K in keyof T]: K extends number | string ? Serializable<T[K]> : never;
      }
    | Stub<Stubable>
    | Stubable;
  interface StubBase<T extends Stubable> extends Disposable {
    [__RPC_STUB_BRAND]: T;
    dup(): this;
  }
  export type Stub<T extends Stubable> = Provider<T> & StubBase<T>;
  type BaseType =
    | void
    | undefined
    | null
    | boolean
    | number
    | bigint
    | string
    | TypedArray
    | ArrayBuffer
    | DataView
    | Date
    | Error
    | RegExp
    | ReadableStream<Uint8Array>
    | WritableStream<Uint8Array>
    | Request
    | Response
    | Headers;
  type Stubify<T> = T extends Stubable ? Stub<T> : T extends Map<infer K, infer V> ? Map<Stubify<K>, Stubify<V>> : T extends Set<infer V> ? Set<Stubify<V>> : T extends Array<infer V> ? Array<Stubify<V>> : T extends ReadonlyArray<infer V> ? ReadonlyArray<Stubify<V>> : T extends BaseType ? T : T extends {
        [key: string | number]: any;
    } ? {
        [K in keyof T]: Stubify<T[K]>;
    } : T;
  type Unstubify<T> = T extends StubBase<infer V> ? V : T extends Map<infer K, infer V> ? Map<Unstubify<K>, Unstubify<V>> : T extends Set<infer V> ? Set<Unstubify<V>> : T extends Array<infer V> ? Array<Unstubify<V>> : T extends ReadonlyArray<infer V> ? ReadonlyArray<Unstubify<V>> : T extends BaseType ? T : T extends {
        [key: string | number]: unknown;
    } ? {
        [K in keyof T]: Unstubify<T[K]>;
    } : T;
  type UnstubifyAll<A extends any[]> = {
    [I in keyof A]: Unstubify<A[I]>;
  };
  type MaybeProvider<T> = T extends object ? Provider<T> : unknown;
  type MaybeDisposable<T> = T extends object ? Disposable : unknown;
  type Result<R> = R extends Stubable ? Promise<Stub<R>> & Provider<R> : R extends Serializable<R> ? Promise<Stubify<R> & MaybeDisposable<R>> & MaybeProvider<R> : never;
  type MethodOrProperty<V> = V extends (...args: infer P) => infer R
    ? (...args: UnstubifyAll<P>) => Result<Awaited<R>>
    : Result<Awaited<V>>;
  type MaybeCallableProvider<T> = T extends (...args: any[]) => any
    ? MethodOrProperty<T>
    : unknown;
  export type Provider<
    T extends object,
    Reserved extends string = never,
  > = MaybeCallableProvider<T> & {
    [K in Exclude<
      keyof T,
      Reserved | symbol | keyof StubBase<never>
    >]: MethodOrProperty<T[K]>;
  };
}
declare namespace Cloudflare {
  interface Env {}
}
declare module 'cloudflare:workers' {
  export type RpcStub<T extends Rpc.Stubable> = Rpc.Stub<T>;
  export const RpcStub: {
    new <T extends Rpc.Stubable>(value: T): Rpc.Stub<T>;
  };
  export abstract class RpcTarget implements Rpc.RpcTargetBranded {
    [Rpc.__RPC_TARGET_BRAND]: never;
  }
  export abstract class WorkerEntrypoint<Env = unknown>
    implements Rpc.WorkerEntrypointBranded
  {
    [Rpc.__WORKER_ENTRYPOINT_BRAND]: never;
    protected ctx: ExecutionContext;
    protected env: Env;
    constructor(ctx: ExecutionContext, env: Env);
    fetch?(request: Request): Response | Promise<Response>;
    tail?(events: TraceItem[]): void | Promise<void>;
    trace?(traces: TraceItem[]): void | Promise<void>;
    scheduled?(controller: ScheduledController): void | Promise<void>;
    queue?(batch: MessageBatch<unknown>): void | Promise<void>;
    test?(controller: TestController): void | Promise<void>;
  }
  export abstract class DurableObject<Env = unknown>
    implements Rpc.DurableObjectBranded
  {
    [Rpc.__DURABLE_OBJECT_BRAND]: never;
    protected ctx: DurableObjectState;
    protected env: Env;
    constructor(ctx: DurableObjectState, env: Env);
    fetch?(request: Request): Response | Promise<Response>;
    alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise<void>;
    webSocketMessage?(
      ws: WebSocket,
      message: string | ArrayBuffer
    ): void | Promise<void>;
    webSocketClose?(
      ws: WebSocket,
      code: number,
      reason: string,
      wasClean: boolean
    ): void | Promise<void>;
    webSocketError?(ws: WebSocket, error: unknown): void | Promise<void>;
  }
  export type WorkflowDurationLabel =
    | 'second'
    | 'minute'
    | 'hour'
    | 'day'
    | 'week'
    | 'month'
    | 'year';
  export type WorkflowSleepDuration =
    | `${number} ${WorkflowDurationLabel}${'s' | ''}`
    | number;
  export type WorkflowDelayDuration = WorkflowSleepDuration;
  export type WorkflowTimeoutDuration = WorkflowSleepDuration;
  export type WorkflowBackoff = 'constant' | 'linear' | 'exponential';
  export type WorkflowStepConfig = {
    retries?: {
      limit: number;
      delay: WorkflowDelayDuration | number;
      backoff?: WorkflowBackoff;
    };
    timeout?: WorkflowTimeoutDuration | number;
  };
  export type WorkflowEvent<T> = {
    payload: Readonly<T>;
    timestamp: Date;
    instanceId: string;
  };
  export type WorkflowStepEvent<T> = {
    payload: Readonly<T>;
    timestamp: Date;
    type: string;
  };
  export abstract class WorkflowStep {
    do<T extends Rpc.Serializable<T>>(
      name: string,
      callback: () => Promise<T>
    ): Promise<T>;
    do<T extends Rpc.Serializable<T>>(
      name: string,
      config: WorkflowStepConfig,
      callback: () => Promise<T>
    ): Promise<T>;
    sleep: (name: string, duration: WorkflowSleepDuration) => Promise<void>;
    sleepUntil: (name: string, timestamp: Date | number) => Promise<void>;
    waitForEvent<T extends Rpc.Serializable<T>>(
      name: string,
      options: {
        type: string;
        timeout?: WorkflowTimeoutDuration | number;
      }
    ): Promise<WorkflowStepEvent<T>>;
  }
  export abstract class WorkflowEntrypoint<
    Env = unknown,
    T extends Rpc.Serializable<T> | unknown = unknown,
  > implements Rpc.WorkflowEntrypointBranded
  {
    [Rpc.__WORKFLOW_ENTRYPOINT_BRAND]: never;
    protected ctx: ExecutionContext;
    protected env: Env;
    constructor(ctx: ExecutionContext, env: Env);
    run(
      event: Readonly<WorkflowEvent<T>>,
      step: WorkflowStep
    ): Promise<unknown>;
  }
  export const env: Cloudflare.Env;
}
interface SecretsStoreSecret {
  get(): Promise<string>;
}
declare module 'cloudflare:sockets' {
  function _connect(
    address: string | SocketAddress,
    options?: SocketOptions
  ): Socket;
  export { _connect as connect };
}
declare namespace TailStream {
  interface Header {
    readonly name: string;
    readonly value: string;
  }
  interface FetchEventInfo {
    readonly type: 'fetch';
    readonly method: string;
    readonly url: string;
    readonly cfJson: string;
    readonly headers: Header[];
  }
  interface JsRpcEventInfo {
    readonly type: 'jsrpc';
    readonly methodName: string;
  }
  interface ScheduledEventInfo {
    readonly type: 'scheduled';
    readonly scheduledTime: Date;
    readonly cron: string;
  }
  interface AlarmEventInfo {
    readonly type: 'alarm';
    readonly scheduledTime: Date;
  }
  interface QueueEventInfo {
    readonly type: 'queue';
    readonly queueName: string;
    readonly batchSize: number;
  }
  interface EmailEventInfo {
    readonly type: 'email';
    readonly mailFrom: string;
    readonly rcptTo: string;
    readonly rawSize: number;
  }
  interface TraceEventInfo {
    readonly type: 'trace';
    readonly traces: (string | null)[];
  }
  interface HibernatableWebSocketEventInfoMessage {
    readonly type: 'message';
  }
  interface HibernatableWebSocketEventInfoError {
    readonly type: 'error';
  }
  interface HibernatableWebSocketEventInfoClose {
    readonly type: 'close';
    readonly code: number;
    readonly wasClean: boolean;
  }
  interface HibernatableWebSocketEventInfo {
    readonly type: 'hibernatableWebSocket';
    readonly info:
      | HibernatableWebSocketEventInfoClose
      | HibernatableWebSocketEventInfoError
      | HibernatableWebSocketEventInfoMessage;
  }
  interface Resume {
    readonly type: 'resume';
    readonly attachment?: any;
  }
  interface CustomEventInfo {
    readonly type: 'custom';
  }
  interface FetchResponseInfo {
    readonly type: 'fetch';
    readonly statusCode: number;
  }
  type EventOutcome =
    | 'ok'
    | 'canceled'
    | 'exception'
    | 'unknown'
    | 'killSwitch'
    | 'daemonDown'
    | 'exceededCpu'
    | 'exceededMemory'
    | 'loadShed'
    | 'responseStreamDisconnected'
    | 'scriptNotFound';
  interface ScriptVersion {
    readonly id: string;
    readonly tag?: string;
    readonly message?: string;
  }
  interface Trigger {
    readonly traceId: string;
    readonly invocationId: string;
    readonly spanId: string;
  }
  interface Onset {
    readonly type: 'onset';
    readonly dispatchNamespace?: string;
    readonly entrypoint?: string;
    readonly scriptName?: string;
    readonly scriptTags?: string[];
    readonly scriptVersion?: ScriptVersion;
    readonly trigger?: Trigger;
    readonly info:
      | FetchEventInfo
      | JsRpcEventInfo
      | ScheduledEventInfo
      | AlarmEventInfo
      | QueueEventInfo
      | EmailEventInfo
      | TraceEventInfo
      | HibernatableWebSocketEventInfo
      | Resume
      | CustomEventInfo;
  }
  interface Outcome {
    readonly type: 'outcome';
    readonly outcome: EventOutcome;
    readonly cpuTime: number;
    readonly wallTime: number;
  }
  interface Hibernate {
    readonly type: 'hibernate';
  }
  interface SpanOpen {
    readonly type: 'spanOpen';
    readonly name: string;
    readonly info?: FetchEventInfo | JsRpcEventInfo | Attributes;
  }
  interface SpanClose {
    readonly type: 'spanClose';
    readonly outcome: EventOutcome;
  }
  interface DiagnosticChannelEvent {
    readonly type: 'diagnosticChannel';
    readonly channel: string;
    readonly message: any;
  }
  interface Exception {
    readonly type: 'exception';
    readonly name: string;
    readonly message: string;
    readonly stack?: string;
  }
  interface Log {
    readonly type: 'log';
    readonly level: 'debug' | 'error' | 'info' | 'log' | 'warn';
    readonly message: string;
  }
  interface Return {
    readonly type: 'return';
    readonly info?: FetchResponseInfo | Attributes;
  }
  interface Link {
    readonly type: 'link';
    readonly label?: string;
    readonly traceId: string;
    readonly invocationId: string;
    readonly spanId: string;
  }
  interface Attribute {
    readonly name: string;
    readonly value:
      | string
      | string[]
      | boolean
      | boolean[]
      | number
      | number[]
      | bigint
      | bigint[];
  }
  interface Attributes {
    readonly type: 'attributes';
    readonly info: Attribute[];
  }
  interface TailEvent {
    readonly traceId: string;
    readonly invocationId: string;
    readonly spanId: string;
    readonly timestamp: Date;
    readonly sequence: number;
    readonly event:
      | Onset
      | Outcome
      | Hibernate
      | SpanOpen
      | SpanClose
      | DiagnosticChannelEvent
      | Exception
      | Log
      | Return
      | Link
      | Attributes;
  }
  type TailEventHandler = (event: TailEvent) => void | Promise<void>;
  type TailEventHandlerName =
    | 'outcome'
    | 'hibernate'
    | 'spanOpen'
    | 'spanClose'
    | 'diagnosticChannel'
    | 'exception'
    | 'log'
    | 'return'
    | 'link'
    | 'attributes';
  type TailEventHandlerObject = Record<TailEventHandlerName, TailEventHandler>;
  type TailEventHandlerType = TailEventHandler | TailEventHandlerObject;
}
type VectorizeVectorMetadataValue = string | number | boolean | string[];
type VectorizeVectorMetadata =
  | VectorizeVectorMetadataValue
  | Record<string, VectorizeVectorMetadataValue>;
type VectorFloatArray = Float32Array | Float64Array;
interface VectorizeError {
  code?: number;
  error: string;
}
type VectorizeVectorMetadataFilterOp = '$eq' | '$ne';
type VectorizeVectorMetadataFilter = {
  [field: string]:
    | Exclude<VectorizeVectorMetadataValue, string[]>
    | null
    | {
        [Op in VectorizeVectorMetadataFilterOp]?: Exclude<
          VectorizeVectorMetadataValue,
          string[]
        > | null;
      };
};
type VectorizeDistanceMetric = 'euclidean' | 'cosine' | 'dot-product';
type VectorizeMetadataRetrievalLevel = 'all' | 'indexed' | 'none';
interface VectorizeQueryOptions {
  topK?: number;
  namespace?: string;
  returnValues?: boolean;
  returnMetadata?: boolean | VectorizeMetadataRetrievalLevel;
  filter?: VectorizeVectorMetadataFilter;
}
type VectorizeIndexConfig =
  | {
      dimensions: number;
      metric: VectorizeDistanceMetric;
    }
  | {
      preset: string;
    };
interface VectorizeIndexDetails {
  readonly id: string;
  name: string;
  description?: string;
  config: VectorizeIndexConfig;
  vectorsCount: number;
}
interface VectorizeIndexInfo {
  vectorCount: number;
  dimensions: number;
  processedUpToDatetime: number;
  processedUpToMutation: number;
}
interface VectorizeVector {
  id: string;
  values: VectorFloatArray | number[];
  namespace?: string;
  metadata?: Record<string, VectorizeVectorMetadata>;
}
type VectorizeMatch = Pick<Partial<VectorizeVector>, 'values'> &
  Omit<VectorizeVector, 'values'> & {
    score: number;
  };
interface VectorizeMatches {
  matches: VectorizeMatch[];
  count: number;
}
interface VectorizeVectorMutation {
  ids: string[];
  count: number;
}
interface VectorizeAsyncMutation {
  mutationId: string;
}
declare abstract class VectorizeIndex {
  public describe(): Promise<VectorizeIndexDetails>;
  public query(
    vector: VectorFloatArray | number[],
    options?: VectorizeQueryOptions
  ): Promise<VectorizeMatches>;
  public insert(vectors: VectorizeVector[]): Promise<VectorizeVectorMutation>;
  public upsert(vectors: VectorizeVector[]): Promise<VectorizeVectorMutation>;
  public deleteByIds(ids: string[]): Promise<VectorizeVectorMutation>;
  public getByIds(ids: string[]): Promise<VectorizeVector[]>;
}
declare abstract class Vectorize {
  public describe(): Promise<VectorizeIndexInfo>;
  public query(
    vector: VectorFloatArray | number[],
    options?: VectorizeQueryOptions
  ): Promise<VectorizeMatches>;
  public queryById(
    vectorId: string,
    options?: VectorizeQueryOptions
  ): Promise<VectorizeMatches>;
  public insert(vectors: VectorizeVector[]): Promise<VectorizeAsyncMutation>;
  public upsert(vectors: VectorizeVector[]): Promise<VectorizeAsyncMutation>;
  public deleteByIds(ids: string[]): Promise<VectorizeAsyncMutation>;
  public getByIds(ids: string[]): Promise<VectorizeVector[]>;
}
type WorkerVersionMetadata = {
  id: string;
  tag: string;
  timestamp: string;
};
interface DynamicDispatchLimits {
  cpuMs?: number;
  subRequests?: number;
}
interface DynamicDispatchOptions {
  limits?: DynamicDispatchLimits;
  outbound?: {
    [key: string]: any;
  };
}
interface DispatchNamespace {
  get(
    name: string,
    args?: {
      [key: string]: any;
    },
    options?: DynamicDispatchOptions
  ): Fetcher;
}
declare module 'cloudflare:workflows' {
  export class NonRetryableError extends Error {
    public constructor(message: string, name?: string);
  }
}
declare abstract class Workflow<PARAMS = unknown> {
  public get(id: string): Promise<WorkflowInstance>;
  public create(
    options?: WorkflowInstanceCreateOptions<PARAMS>
  ): Promise<WorkflowInstance>;
  public createBatch(
    batch: WorkflowInstanceCreateOptions<PARAMS>[]
  ): Promise<WorkflowInstance[]>;
}
interface WorkflowInstanceCreateOptions<PARAMS = unknown> {
  id?: string;
  params?: PARAMS;
}
type InstanceStatus = {
  status:
    | 'queued'
    | 'running'
    | 'paused'
    | 'errored'
    | 'terminated'
    | 'complete'
    | 'waiting'
    | 'waitingForPause'
    | 'unknown';
  error?: string;
  output?: object;
};
interface WorkflowError {
  code?: number;
  message: string;
}
declare abstract class WorkflowInstance {
  public id: string;
  public pause(): Promise<void>;
  public resume(): Promise<void>;
  public terminate(): Promise<void>;
  public restart(): Promise<void>;
  public status(): Promise<InstanceStatus>;
  public sendEvent({
    type,
    payload,
  }: {
    type: string;
    payload: unknown;
  }): Promise<void>;
}

================
File: eslint.config.mjs
================
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends('next/core-web-vitals', 'next/typescript'),
];

export default eslintConfig;

================
File: postcss.config.mjs
================
const config = {
  plugins: ['@tailwindcss/postcss'],
};

export default config;

================
File: src/components/debug/index.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import { memo } from 'react';
import { TreeStructureDebugger } from './tree-structure.view';
function DevDebuggersComponent({
  summaryTree,
}: {
  summaryTree: SummaryNode[];
}) {
  return (
    <>
      <TreeStructureDebugger summaryTree={summaryTree} />
    </>
  );
}
export const DevDebuggers = memo(DevDebuggersComponent);

================
File: src/components/debug/tree-structure.hook.ts
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as React from 'react';
export interface TreeDebuggerState {
  open: boolean;
  copied: boolean;
  searchTerm: string;
  expandedNodes: string[];
  expandAll: boolean;
  activeTab: string;
}
export interface TreeDebuggerActions {
  setOpen: (open: boolean) => void;
  handleCopy: () => void;
  toggleNode: (path: string) => void;
  toggleExpandAll: () => void;
  setSearchTerm: (term: string) => void;
  setActiveTab: (tab: string) => void;
}
export interface TreeDebuggerHelpers {
  formattedTree: string;
  countNodes: (nodes: SummaryNode[]) => number;
  calculateMaxDepth: (nodes: SummaryNode[], currentDepth?: number) => number;
  matchesSearch: (node: SummaryNode, term: string) => boolean;
}
export interface UseTreeDebuggerResult {
  state: TreeDebuggerState;
  actions: TreeDebuggerActions;
  helpers: TreeDebuggerHelpers;
}
export function useTreeStructureDebugger(
  tree: SummaryNode[]
): UseTreeDebuggerResult {
  const [open, setOpen] = React.useState(false);
  const [copied, setCopied] = React.useState(false);
  const [searchTerm, setSearchTerm] = React.useState('');
  const [expandedNodes, setExpandedNodes] = React.useState<string[]>([]);
  const [expandAll, setExpandAll] = React.useState(false);
  const [activeTab, setActiveTab] = React.useState('visual');
  const formattedTree = React.useMemo(
    () => JSON.stringify(tree, null, 2),
    [tree]
  );
  const handleCopy = React.useCallback(() => {
    navigator.clipboard.writeText(formattedTree).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    });
  }, [formattedTree]);
  const toggleNode = React.useCallback((path: string) => {
    setExpandedNodes((prev) =>
      prev.includes(path) ? prev.filter((p) => p !== path) : [...prev, path]
    );
  }, []);
  const toggleExpandAll = React.useCallback(() => {
    setExpandAll((prev) => !prev);
    if (!expandAll) {
      const allPaths: string[] = [];
      const collectPaths = (nodes: SummaryNode[], currentPath = '') => {
        nodes.forEach((node) => {
          const nodePath = currentPath
            ? `${currentPath}.${node.slug}`
            : node.slug;
          allPaths.push(nodePath);
          if (node.children.length) {
            collectPaths(node.children, nodePath);
          }
        });
      };
      collectPaths(tree);
      setExpandedNodes(allPaths);
    } else {
      setExpandedNodes([]);
    }
  }, [expandAll, tree]);
  const countNodes = React.useCallback((nodes: SummaryNode[]): number => {
    let count = nodes.length;
    for (const node of nodes) {
      count += countNodes(node.children);
    }
    return count;
  }, []);
  const calculateMaxDepth = React.useCallback(
    (nodes: SummaryNode[], currentDepth = 1): number => {
      if (nodes.length === 0) return currentDepth - 1;
      let maxDepth = currentDepth;
      for (const node of nodes) {
        if (node.children.length > 0) {
          const childDepth = calculateMaxDepth(node.children, currentDepth + 1);
          maxDepth = Math.max(maxDepth, childDepth);
        }
      }
      return maxDepth;
    },
    []
  );
  const matchesSearch = React.useCallback(
    (node: SummaryNode, term: string): boolean => {
      if (!term) return true;
      const nodeMatches =
        node.title.toLowerCase().includes(term.toLowerCase()) ||
        node.slug.toLowerCase().includes(term.toLowerCase());
      if (nodeMatches) return true;
      return node.children.some((child) => matchesSearch(child, term));
    },
    []
  );
  return {
    state: {
      open,
      copied,
      searchTerm,
      expandedNodes,
      expandAll,
      activeTab,
    },
    actions: {
      setOpen,
      handleCopy,
      toggleNode,
      toggleExpandAll,
      setSearchTerm,
      setActiveTab,
    },
    helpers: {
      formattedTree,
      countNodes,
      calculateMaxDepth,
      matchesSearch,
    },
  };
}

================
File: src/components/debug/tree-structure.view.tsx
================
'use client';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import {
  CustomDialog,
  CustomDialogContent,
  CustomDialogHeader,
  CustomDialogTitle,
} from '@/components/ui/custom-dialog';
import { DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import type { SummaryNode } from '@/lib/content/types';
import {
  ChevronRight,
  Copy,
  FolderTreeIcon as FileTree,
  Maximize2,
  Minimize2,
  Search,
  X,
} from 'lucide-react';
import { memo } from 'react';
import { useTreeStructureDebugger } from './tree-structure.hook';
function TreeStructureDebuggerComponent({
  summaryTree,
}: {
  summaryTree: SummaryNode[];
}) {
  const { state, actions, helpers } = useTreeStructureDebugger(summaryTree);
  const { open, copied, searchTerm, expandedNodes, expandAll, activeTab } =
    state;
  const {
    setOpen,
    handleCopy,
    toggleNode,
    toggleExpandAll,
    setSearchTerm,
    setActiveTab,
  } = actions;
  const { formattedTree, countNodes, calculateMaxDepth, matchesSearch } =
    helpers;
  if (process.env.NODE_ENV === 'production') return null;
  return (
    <>
      <Button
        onClick={() => setOpen(true)}
        className="fixed bottom-4 left-4 z-50"
        variant="default"
        size="sm"
      >
        <FileTree className="mr-2 h-4 w-4" />
        Tree Debugger
      </Button>
      <CustomDialog open={open} onOpenChange={setOpen}>
        <CustomDialogContent
          dir="ltr"
          className="border-border h-[90vh] w-[90vw] max-w-4xl overflow-x-hidden overflow-y-scroll rounded-lg border p-0 shadow-lg"
        >
          <CustomDialogHeader className="border-b px-6 pt-6 pb-4">
            <div className="flex items-center justify-between">
              <CustomDialogTitle className="flex items-center text-xl font-semibold">
                <FileTree className="text-primary mr-2 h-5 w-5" />
                Tree Structure Debugger
              </CustomDialogTitle>
              <div className="flex items-center gap-2">
                {activeTab === 'visual' && (
                  <Button size="sm" variant="outline" onClick={toggleExpandAll}>
                    {expandAll ? (
                      <>
                        <Minimize2 className="mr-1 h-4 w-4" />
                        Collapse All
                      </>
                    ) : (
                      <>
                        <Maximize2 className="mr-1 h-4 w-4" />
                        Expand All
                      </>
                    )}
                  </Button>
                )}
                {activeTab === 'json' && (
                  <Button size="sm" variant="outline" onClick={handleCopy}>
                    <Copy className="mr-1 h-4 w-4" />
                    {copied ? 'Copied!' : 'Copy JSON'}
                  </Button>
                )}
                <DialogClose asChild>
                  <Button size="icon" variant="ghost">
                    <X className="h-4 w-4" />
                  </Button>
                </DialogClose>
              </div>
            </div>
            <div className="relative mt-4">
              <Search className="text-muted-foreground absolute top-2.5 left-2.5 h-4 w-4" />
              <Input
                placeholder="Search nodes..."
                className="pl-9"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
          </CustomDialogHeader>
          <Tabs
            defaultValue="visual"
            className="flex h-[calc(90vh-160px)] flex-col"
            onValueChange={setActiveTab}
          >
            <TabsList className="mx-6 mt-4 w-auto self-start">
              <TabsTrigger value="visual">Visual Tree</TabsTrigger>
              <TabsTrigger value="json">Raw JSON</TabsTrigger>
            </TabsList>
            <TabsContent
              value="visual"
              className="flex-1 overflow-hidden px-6 pb-6"
            >
              <ScrollArea className="bg-background h-full rounded-md border">
                <div className="p-4">
                  {summaryTree.map((node) => (
                    <TreeNode
                      key={node.slug}
                      node={node}
                      level={0}
                      searchTerm={searchTerm}
                      expandedNodes={expandedNodes}
                      toggleNode={toggleNode}
                      expandAll={expandAll}
                      matchesSearch={matchesSearch}
                    />
                  ))}
                </div>
              </ScrollArea>
            </TabsContent>
            <TabsContent
              value="json"
              className="flex-1 overflow-hidden px-6 pb-6"
            >
              <ScrollArea className="bg-background h-full rounded-md border">
                <pre className="overflow-visible p-4 font-mono text-sm whitespace-pre-wrap">
                  {formattedTree}
                </pre>
              </ScrollArea>
            </TabsContent>
          </Tabs>
          <div className="bg-muted/10 text-muted-foreground border-t px-6 py-3 text-xs">
            <div className="flex items-center justify-between">
              <div>
                Total nodes: {countNodes(summaryTree)} • Root nodes:{' '}
                {summaryTree.length} • Max depth:{' '}
                {calculateMaxDepth(summaryTree)}
              </div>
              <div>
                <span className="font-mono">
                  process.env.NODE_ENV !== "production"
                </span>
              </div>
            </div>
          </div>
        </CustomDialogContent>
      </CustomDialog>
    </>
  );
}
interface TreeNodeProps {
  node: SummaryNode;
  level: number;
  searchTerm: string;
  expandedNodes: string[];
  toggleNode: (path: string) => void;
  expandAll: boolean;
  matchesSearch: (node: SummaryNode, term: string) => boolean;
  parentPath?: string;
}
function TreeNode({
  node,
  level,
  searchTerm,
  expandedNodes,
  toggleNode,
  expandAll,
  matchesSearch,
  parentPath = '',
}: TreeNodeProps) {
  const hasChildren = node.children.length > 0;
  const nodePath = parentPath ? `${parentPath}.${node.slug}` : node.slug;
  const isExpanded = expandedNodes.includes(nodePath) || expandAll;
  const isMatch = matchesSearch(node, searchTerm);
  // If there's a search term and no match, don't render this node
  if (searchTerm && !isMatch) return null;
  return (
    <div className={`${level > 0 ? `ml-${level * 3}` : ''} my-1`}>
      <Collapsible
        open={isExpanded}
        onOpenChange={() => hasChildren && toggleNode(nodePath)}
      >
        <div className="group hover:bg-muted/20 flex items-center rounded-md px-1 py-1">
          {hasChildren ? (
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="text-muted-foreground hover:text-foreground mr-1 h-6 w-6 p-0"
              >
                <ChevronRight
                  className={`h-4 w-4 transition-transform ${
                    isExpanded ? 'rotate-90' : ''
                  }`}
                />
                <span className="sr-only">Toggle</span>
              </Button>
            </CollapsibleTrigger>
          ) : (
            <div className="w-7" />
          )}
          <div className="flex flex-1 items-center gap-2">
            <span
              className={`font-medium ${
                searchTerm &&
                node.title.toLowerCase().includes(searchTerm.toLowerCase())
                  ? 'rounded bg-yellow-100 px-1 dark:bg-yellow-900/30'
                  : ''
              }`}
            >
              {node.title}
            </span>
            <span className="text-muted-foreground font-mono text-xs">
              ({node.slug})
            </span>
            {node.order && (
              <Badge variant="outline" className="text-xs">
                Order: {node.order}
              </Badge>
            )}
          </div>
        </div>
        {hasChildren && (
          <CollapsibleContent>
            <div className="border-muted mt-1 ml-3 border-l-2 pl-3">
              {node.children.map((childNode) => (
                <TreeNode
                  key={childNode.slug}
                  node={childNode}
                  level={level + 1}
                  searchTerm={searchTerm}
                  expandedNodes={expandedNodes}
                  toggleNode={toggleNode}
                  expandAll={expandAll}
                  matchesSearch={matchesSearch}
                  parentPath={nodePath}
                />
              ))}
            </div>
          </CollapsibleContent>
        )}
      </Collapsible>
    </div>
  );
}
export const TreeStructureDebugger = memo(TreeStructureDebuggerComponent);

================
File: src/components/ui/badge.tsx
================
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
const badgeVariants = cva(
  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',
        destructive:
          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);
function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<'span'> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'span';
  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  );
}
export { Badge, badgeVariants };

================
File: src/components/ui/custom-dialog.tsx
================
'use client';
import { cn } from '@/lib/styles/tailwind-utils';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import * as React from 'react';
const CustomDialog = DialogPrimitive.Root;
const CustomDialogTrigger = DialogPrimitive.Trigger;
const CustomDialogPortal = DialogPrimitive.Portal;
const CustomDialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/90',
      className
    )}
    {...props}
  />
));
CustomDialogOverlay.displayName = DialogPrimitive.Overlay.displayName;
const CustomDialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <CustomDialogPortal>
    <CustomDialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] fixed top-[50%] left-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border p-6 shadow-lg duration-200 sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      {}
    </DialogPrimitive.Content>
  </CustomDialogPortal>
));
CustomDialogContent.displayName = DialogPrimitive.Content.displayName;
const CustomDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
CustomDialogHeader.displayName = 'CustomDialogHeader';
const CustomDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
CustomDialogFooter.displayName = 'CustomDialogFooter';
const CustomDialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg leading-none font-semibold tracking-tight',
      className
    )}
    {...props}
  />
));
CustomDialogTitle.displayName = DialogPrimitive.Title.displayName;
const CustomDialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-muted-foreground text-sm', className)}
    {...props}
  />
));
CustomDialogDescription.displayName = DialogPrimitive.Description.displayName;
export {
  CustomDialog,
  CustomDialogContent,
  CustomDialogDescription,
  CustomDialogFooter,
  CustomDialogHeader,
  CustomDialogOverlay,
  CustomDialogPortal,
  CustomDialogTitle,
  CustomDialogTrigger,
};

================
File: src/components/ui/dialog.tsx
================
'use client';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}
function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}
function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}
function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}
function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className
      )}
      {...props}
    />
  );
}
function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}
function DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  );
}
function DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        'flex flex-col-reverse gap-2 sm:flex-row sm:justify-end',
        className
      )}
      {...props}
    />
  );
}
function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn('text-lg leading-none font-semibold', className)}
      {...props}
    />
  );
}
function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}
export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};

================
File: src/components/ui/scroll-area.tsx
================
'use client';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn('relative', className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}
function ScrollBar({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        'flex touch-none p-px transition-colors select-none',
        orientation === 'vertical' &&
          'h-full w-2.5 border-l border-l-transparent',
        orientation === 'horizontal' &&
          'h-2.5 flex-col border-t border-t-transparent',
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}
export { ScrollArea, ScrollBar };

================
File: src/components/ui/table.tsx
================
'use client';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Table({ className, ...props }: React.ComponentProps<'table'>) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn('w-full caption-bottom text-sm', className)}
        {...props}
      />
    </div>
  );
}
function TableHeader({ className, ...props }: React.ComponentProps<'thead'>) {
  return (
    <thead
      data-slot="table-header"
      className={cn('[&_tr]:border-b', className)}
      {...props}
    />
  );
}
function TableBody({ className, ...props }: React.ComponentProps<'tbody'>) {
  return (
    <tbody
      data-slot="table-body"
      className={cn('[&_tr:last-child]:border-0', className)}
      {...props}
    />
  );
}
function TableFooter({ className, ...props }: React.ComponentProps<'tfoot'>) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        'bg-muted/50 border-t font-medium [&>tr]:last:border-b-0',
        className
      )}
      {...props}
    />
  );
}
function TableRow({ className, ...props }: React.ComponentProps<'tr'>) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        'hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors',
        className
      )}
      {...props}
    />
  );
}
function TableHead({ className, ...props }: React.ComponentProps<'th'>) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        'text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}
function TableCell({ className, ...props }: React.ComponentProps<'td'>) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        'p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}
function TableCaption({
  className,
  ...props
}: React.ComponentProps<'caption'>) {
  return (
    <caption
      data-slot="table-caption"
      className={cn('text-muted-foreground mt-4 text-sm', className)}
      {...props}
    />
  );
}
export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
};

================
File: src/components/ui/tabs.tsx
================
'use client';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn('flex flex-col gap-2', className)}
      {...props}
    />
  );
}
function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        'bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]',
        className
      )}
      {...props}
    />
  );
}
function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}
function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn('flex-1 outline-none', className)}
      {...props}
    />
  );
}
export { Tabs, TabsContent, TabsList, TabsTrigger };

================
File: src/components/visualizations/renderers/spatial/circle-pack-renderer.tsx
================
'use client';
import * as d3 from 'd3';
import { useEffect, useRef } from 'react';
interface SummaryNode {
  title: string;
  children: SummaryNode[];
}
interface PackVisualizationProps {
  nodes: SummaryNode[];
  width?: number;
  height?: number;
}
type HierarchyData = {
  title: string;
  children?: HierarchyData[];
};
export function CirclePackRenderer({
  nodes,
  width = 800,
  height = 800,
}: PackVisualizationProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    if (!svgRef.current || !containerRef.current || nodes.length === 0) return;
    const hierarchyData: HierarchyData = {
      title: 'root',
      children: nodes as HierarchyData[],
    };
    const root = d3
      .hierarchy(hierarchyData)
      .sum((d) => Math.max(20, d.title.length));
    const pack = d3.pack<HierarchyData>().size([width, height]).padding(20);
    const packedData = pack(root);
    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();
    const g = svg.append('g');
    const zoom = d3
      .zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
    svg.call(zoom);
    function wrap(
      text: d3.Selection<SVGTextElement, any, any, any>,
      width: number
    ) {
      text.each(function () {
        const textElement = d3.select(this);
        const words = textElement.text().split(/\s+/);
        const lineHeight = 1.1;
        let line: string[] = [];
        let lineNumber = 0;
        const y = textElement.attr('y') || 0;
        const dy = parseFloat(textElement.attr('dy') || '0');
        textElement.text('');
        let tspan = textElement
          .append('tspan')
          .attr('x', 0)
          .attr('y', y)
          .attr('dy', `${dy}em`);
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          line.push(word);
          tspan.text(line.join(' '));
          if (
            (tspan.node()?.getComputedTextLength() || 0) > width &&
            line.length > 1
          ) {
            line.pop();
            tspan.text(line.join(' '));
            line = [word];
            lineNumber++;
            tspan = textElement
              .append('tspan')
              .attr('x', 0)
              .attr('dy', `${lineHeight}em`)
              .text(word);
          }
        }
        const totalLines = lineNumber + 1;
        const offsetY = -(totalLines - 1) * lineHeight * 0.5;
        textElement.selectAll('tspan').each(function (d, i) {
          d3.select(this).attr(
            'dy',
            i === 0 ? `${dy + offsetY}em` : `${lineHeight}em`
          );
        });
      });
    }
    function getTextPosition(d: d3.HierarchyCircularNode<HierarchyData>) {
      if (!d.children) {
        return { x: 0, y: 0 };
      }
      const children = d.children;
      const radius = d.r;
      const positions = [
        { x: 0, y: -radius * 0.7 },
        { x: 0, y: radius * 0.7 },
        { x: -radius * 0.7, y: 0 },
        { x: radius * 0.7, y: 0 },
        { x: -radius * 0.5, y: -radius * 0.5 },
        { x: radius * 0.5, y: -radius * 0.5 },
        { x: -radius * 0.5, y: radius * 0.5 },
        { x: radius * 0.5, y: radius * 0.5 },
      ];
      let bestPosition = positions[0];
      let minOverlap = Infinity;
      for (const pos of positions) {
        let overlap = 0;
        for (const child of children) {
          const distance = Math.sqrt(
            Math.pow(pos.x - (child.x - d.x), 2) +
              Math.pow(pos.y - (child.y - d.y), 2)
          );
          if (distance < child.r + 20) {
            overlap += child.r + 20 - distance;
          }
        }
        if (overlap < minOverlap) {
          minOverlap = overlap;
          bestPosition = pos;
        }
      }
      return bestPosition;
    }
    const hasChildren = (
      d: d3.HierarchyCircularNode<HierarchyData>
    ): boolean => {
      return Boolean(d.children && d.children.length > 0);
    };
    const node = g
      .selectAll<SVGGElement, d3.HierarchyCircularNode<HierarchyData>>('g')
      .data(packedData.descendants().filter((d) => d.depth > 0))
      .join('g')
      .attr('transform', (d) => `translate(${d.x},${d.y})`);
    node
      .filter((d) => !hasChildren(d))
      .append('circle')
      .attr('r', (d) => d.r)
      .attr('fill', '#ffffff00')
      .attr('stroke', '#999')
      .attr('stroke-width', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function () {
        d3.select(this).attr('stroke-width', 2);
      })
      .on('mouseout', function () {
        d3.select(this).attr('stroke-width', 1);
      });
    node
      .filter((d) => hasChildren(d))
      .append('circle')
      .attr('r', (d) => d.r)
      .attr('fill', '#ffffff00')
      .attr('stroke', '#999')
      .attr('stroke-width', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function () {
        d3.select(this).attr('stroke-width', 2);
      })
      .on('mouseout', function () {
        d3.select(this).attr('stroke-width', 1);
      });
    const textElements = node
      .append('text')
      .attr('text-anchor', 'middle')
      .attr('transform', (d) => {
        const pos = getTextPosition(d);
        return `translate(${pos.x}, ${pos.y})`;
      })
      .style('font-size', (d) => {
        const baseSize = Math.min(d.r / 4, 14);
        const textLength = d.data.title.length;
        const scaleFactor = d.children ? 0.8 : 1;
        return `${Math.max(
          baseSize * scaleFactor * (25 / Math.max(textLength, 25)),
          8
        )}px`;
      })
      .style('fill', (d) => (d.children ? '#666666' : '#000000'))
      .style('font-weight', (d) => (d.children ? 'bold' : 'normal'))
      .style('pointer-events', 'none')
      .text((d) => d.data.title);
    textElements.each(function (d) {
      const wrapWidth = d.children ? d.r * 0.8 : d.r * 1.6;
      wrap(d3.select(this), wrapWidth);
    });
    node.on('dblclick', (event, d) => {
      event.stopPropagation();
      const dx = d.x;
      const dy = d.y;
      const scale = Math.min(width / (d.r * 2), height / (d.r * 2)) * 0.9;
      svg
        .transition()
        .duration(750)
        .call(
          zoom.transform,
          d3.zoomIdentity
            .translate(width / 2, height / 2)
            .scale(scale)
            .translate(-dx, -dy)
        );
    });
    svg.on('dblclick', () => {
      svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
    });
  }, [nodes, width, height]);
  return (
    <div
      ref={containerRef}
      className="flex items-center justify-center overflow-hidden rounded-lg bg-zinc-100 shadow ring-1 shadow-zinc-100 ring-zinc-200"
      style={{ width: '100%', height: '100%' }}
    >
      <svg
        ref={svgRef}
        width={'100%'}
        height={'100%'}
        viewBox={`0 0 ${width} ${height}`}
        style={{ maxWidth: '100%', height: 'auto' }}
      />
    </div>
  );
}

================
File: src/lib/content/types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type LeafNodeInfo = {
  title: string;
  fullSlugPath: string;
};
type BookLandingSectionBase = {
  title: string;
};
export type TextLandingSection = BookLandingSectionBase & {
  type: "text";
  content: string[];
};
export type VisualizationLandingSection = BookLandingSectionBase & {
  type: "visualization";
  nodes: SummaryNode[];
};
export type BookLandingSection =
  | TextLandingSection
  | VisualizationLandingSection;
export interface BookLandingPageConfig {
  sections: BookLandingSection[];
}
export type BookLandingConfigFunction = (
  bookChapters: SummaryNode[],
) => BookLandingPageConfig;
export type ContentNode = SummaryNode & {
  pageTitle?: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml?: string;
  frontmatter?: Record<string, any>;
  landingPageConfig?: BookLandingPageConfig;
};

================
File: src/lib/text/transliteration.ts
================
type ArabicToLatinOptions = {
  mode: 'arabic-to-latin';
  input: string;
};
type LatinToArabicDigitsOptions = {
  mode: 'latin-to-arabic-digits';
  input: string;
};
type LatinNumbersToArabicDigitsOptions = {
  mode: 'latin-numbers-to-arabic-digits';
  input: string | number;
};
type LatinToArabicOptions = {
  mode: 'latin-to-arabic';
  input: string;
};
type Options =
  | ArabicToLatinOptions
  | LatinToArabicDigitsOptions
  | LatinNumbersToArabicDigitsOptions
  | LatinToArabicOptions;
const LATIN_TO_ARABIC_DIGITS: Record<string, string> = {
  '0': '٠',
  '1': '١',
  '2': '٢',
  '3': '٣',
  '4': '٤',
  '5': '٥',
  '6': '٦',
  '7': '٧',
  '8': '٨',
  '9': '٩',
};
const ARABIC_TO_LATIN_DIGITS: Record<string, string> = Object.fromEntries(
  Object.entries(LATIN_TO_ARABIC_DIGITS).map(([w, a]) => [a, w])
);
const digitSet = new Set(Object.keys(LATIN_TO_ARABIC_DIGITS));
const ARABIC_TO_LATIN_LETTERS: Record<string, string> = {
  ا: 'a',
  ب: 'b',
  ت: 't',
  ث: 'th',
  ج: 'j',
  ح: 'h',
  خ: 'kh',
  د: 'd',
  ذ: 'dh',
  ر: 'r',
  ز: 'z',
  س: 's',
  ش: 'sh',
  ص: 's',
  ض: 'd',
  ط: 't',
  ظ: 'z',
  ع: 'a',
  غ: 'gh',
  ف: 'f',
  ق: 'q',
  ك: 'k',
  ل: 'l',
  م: 'm',
  ن: 'n',
  ه: 'h',
  و: 'w',
  ي: 'y',
  ء: '',
  ى: 'a',
  ئ: 'y',
  ؤ: 'w',
  ة: 'h',
  إ: 'i',
  أ: 'a',
  آ: 'aa',
  'ٓ': '',
  'َ': 'a',
  'ُ': 'u',
  'ِ': 'i',
  'ّ': '',
  'ْ': '',
  'ً': 'an',
  'ٌ': 'un',
  'ٍ': 'in',
};
const ARABIC_TO_LATIN_MAP = {
  ...ARABIC_TO_LATIN_LETTERS,
  ...ARABIC_TO_LATIN_DIGITS,
};
const LATIN_TO_ARABIC_LETTERS: Record<string, string> = Object.fromEntries(
  Object.entries(ARABIC_TO_LATIN_LETTERS)
    .filter(([_arb, lat]) => lat.length > 0)
    .map(([arb, lat]) => [lat, arb])
);
const LATIN_LETTER_KEYS = Object.keys(LATIN_TO_ARABIC_LETTERS).sort(
  (a, b) => b.length - a.length
);
export function transliterate(options: Options): string {
  const { mode } = options;
  const inputStr = options.input.toString();
  switch (mode) {
    case 'arabic-to-latin':
      return [...inputStr].map((ch) => ARABIC_TO_LATIN_MAP[ch] ?? ch).join('');
    case 'latin-to-arabic-digits':
      return inputStr.replace(/[0-9]/g, (d) => LATIN_TO_ARABIC_DIGITS[d]);
    case 'latin-numbers-to-arabic-digits':
      if (!/^\d+$/.test(inputStr)) {
        throw new Error(
          "Mode 'latin-numbers-to-arabic-digits' requires digits only."
        );
      }
      return [...inputStr].map((d) => LATIN_TO_ARABIC_DIGITS[d]).join('');
    case 'latin-to-arabic':
      return transliterateLatinToArabic(inputStr);
    default:
      const _exhaustive: never = mode;
      throw new Error(`Unsupported mode: ${_exhaustive}`);
  }
}
function transliterateLatinToArabic(s: string): string {
  let result = '';
  let i = 0;
  const N = s.length;
  const lower = s.toLowerCase();
  while (i < N) {
    let matched = false;
    for (const key of LATIN_LETTER_KEYS) {
      if (lower.startsWith(key, i)) {
        result += LATIN_TO_ARABIC_LETTERS[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const ch = s[i];
    if (digitSet.has(ch)) {
      result += LATIN_TO_ARABIC_DIGITS[ch];
    } else {
      result += ch;
    }
    i++;
  }
  return result;
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# Manual
repomix-output.xml

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# wrangler files
.wrangler
.dev.vars*

================
File: README.md
================
# README.md

# Arabic Learning Platform

An interactive platform for learning Arabic with multiple visualization modes.

## Features

- 📚 Structured content navigation
- 🎨 Multiple visualization modes
- 📱 Mobile-responsive design
- 🌙 Dark/light theme support

## Getting Started

```bash
npm install
npm run dev
```

## Project Structure

[Document your folder structure]

## Contributing

[Contribution guidelines]

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    },
    "types": ["./env.d.ts", "node"]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "content/النحو/سليمان_العيوني/النحو_الصغير/landing.js"],
  "exclude": ["node_modules"]
}

================
File: wrangler.jsonc
================
/**
 * For more details on how to configure Wrangler, refer to:
 * https://developers.cloudflare.com/workers/wrangler/configuration/
 */
{
  "$schema": "node_modules/wrangler/config-schema.json",
  "name": "usearabic",
  "compatibility_date": "2025-05-19",
  "compatibility_flags": ["nodejs_compat"],
  "pages_build_output_dir": ".vercel/output/static",
  "observability": {
    "enabled": true,
  },
  /**
   * Smart Placement
   * Docs: https://developers.cloudflare.com/workers/configuration/smart-placement/#smart-placement
   */
  // "placement": { "mode": "smart" },

  /**
   * Bindings
   * Bindings allow your Worker to interact with resources on the Cloudflare Developer Platform, including
   * databases, object storage, AI inference, real-time communication and more.
   * https://developers.cloudflare.com/workers/runtime-apis/bindings/
   */

  /**
   * Environment Variables
   * https://developers.cloudflare.com/workers/wrangler/configuration/#environment-variables
   */
  // "vars": { "MY_VARIABLE": "production_value" },
  /**
   * Note: Use secrets to store sensitive data.
   * https://developers.cloudflare.com/workers/configuration/secrets/
   */

  /**
   * Static Assets
   * https://developers.cloudflare.com/workers/static-assets/binding/
   */
  // "assets": { "directory": "./public/", "binding": "ASSETS" },

  /**
   * Service Bindings (communicate between multiple Workers)
   * https://developers.cloudflare.com/workers/wrangler/configuration/#service-bindings
   */
  // "services": [{ "binding": "MY_SERVICE", "service": "my-service" }]
}

================
File: src/components/layout/sidebar.tsx
================
'use client';
import {
  SidebarContent,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  Sidebar as UISidebar,
} from '@/components/ui/sidebar';
import { useSidebar } from '@/hooks/use-sidebar';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import {
  BookOpen,
  ChevronDown,
  ChevronLeft,
  ChevronsDownUp,
  FileText,
  Folder,
} from 'lucide-react';
import Link from 'next/link';
import React, { memo, useCallback } from 'react';
function SidebarComponent({ summaryTree }: { summaryTree: SummaryNode[] }) {
  const {
    flatItems,
    expandedSections,
    toggleSection,
    isCurrentPage,
    toggleAll,
  } = useSidebar(summaryTree);
  const isVisible = useCallback(
    (node: SummaryNode): boolean => {
      let path = '';
      for (const part of node.parentPath) {
        path = path ? `${path}/${part}` : part;
        if (!expandedSections[path]) return false;
      }
      return true;
    },
    [expandedSections]
  );
  return (
    <UISidebar side="right">
      <SidebarContent
        className={cn('overflow-y-scroll', '[&::-webkit-scrollbar]:w-0')}
      >
        <SidebarGroup>
          <SidebarGroupLabel>النحو الرقمي</SidebarGroupLabel>
          <SidebarGroupAction onClick={toggleAll} title="طي وبسط">
            <ChevronsDownUp /> <span className="sr-only">Toggle</span>
          </SidebarGroupAction>
          <SidebarGroupContent>
            <SidebarMenu>
              <SidebarMenuItem key="__home">
                <SidebarMenuButton
                  asChild
                  isActive={isCurrentPage('__home')}
                  className="pl-1.5"
                >
                  <Link href="/">
                    <BookOpen className="h-4 w-4 shrink-0" />
                    <span>مقدمة</span>
                  </Link>
                </SidebarMenuButton>
              </SidebarMenuItem>
              {flatItems.map(({ node, level }) => {
                const fullPath = [...node.parentPath, node.slug].join('/');
                const hasChildren = node.children.length > 0;
                const isExpanded = expandedSections[fullPath] || false;
                const isActive = isCurrentPage(fullPath);
                const visible = isVisible(node);
                if (!visible) return null;
                return (
                  <SidebarMenuItem key={fullPath}>
                    {hasChildren ? (
                      <SidebarMenuButton
                        className={cn(
                          'pr-[calc(0.5rem*var(--level))] pl-1.5',
                          isActive &&
                            'bg-sidebar-accent text-sidebar-accent-foreground font-medium'
                        )}
                        style={{ '--level': 1 + level } as React.CSSProperties}
                        onClick={() => toggleSection(fullPath)}
                      >
                        <Folder className="h-4 w-4 shrink-0" />
                        <span>{node.title}</span>
                        {isExpanded ? (
                          <ChevronDown className="mr-auto h-4 w-4" />
                        ) : (
                          <ChevronLeft className="mr-auto h-4 w-4" />
                        )}
                      </SidebarMenuButton>
                    ) : (
                      <SidebarMenuButton
                        asChild
                        isActive={isActive}
                        className={cn('pr-[calc(0.5rem*var(--level))]')}
                        style={{ '--level': 1 + level } as React.CSSProperties}
                      >
                        <Link href={`/learn/${fullPath}`}>
                          <FileText className="h-4 w-4 shrink-0" />
                          <span>{node.title}</span>
                        </Link>
                      </SidebarMenuButton>
                    )}
                  </SidebarMenuItem>
                );
              })}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
    </UISidebar>
  );
}
export const Sidebar = memo(SidebarComponent);

================
File: src/components/visualizations/renderers/spatial/grid-layout-renderer.tsx
================
import { getLeafNodes } from '@/lib/content/query/get-leaf-nodes';
import type { SummaryNode } from '@/lib/content/types';
import { memo } from 'react';
export const GridLayoutRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    const leafNodes = getLeafNodes(nodes);
    return (
      <div className="xs:grid-cols-2 grid grid-cols-1 gap-4 py-4 md:grid-cols-3 lg:grid-cols-4">
        {leafNodes.map((node) => (
          <a
            key={node.slug}
            href={`/learn/${node.slug}`}
            className="rounded-lg border p-4 transition-colors hover:bg-zinc-50 dark:hover:bg-zinc-800"
          >
            <h2 className="text-base">{node.title}</h2>
          </a>
        ))}
      </div>
    );
  }
);

================
File: src/components/visualizations/renderers/spatial/nested-boxes-renderer.tsx
================
'use client';
import { getNodeSlugPath } from '@/lib/content/query/get-node-path';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import Link from 'next/link';
import { memo, useId } from 'react';
const COLOR_SCHEMES = [
  {
    bg: 'bg-gradient-to-br from-zinc-50 to-zinc-100',
    border: 'border-zinc-200',
    text: 'text-zinc-700',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-100 to-zinc-200',
    border: 'border-zinc-300',
    text: 'text-zinc-800',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-200 to-zinc-300',
    border: 'border-zinc-400',
    text: 'text-zinc-900',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-300 to-zinc-400',
    border: 'border-zinc-500',
    text: 'text-white',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-400 to-zinc-500',
    border: 'border-zinc-600',
    text: 'text-white',
  },
] as const;
const FONT_SIZES = {
  0: 'text-lg md:text-xl',
  1: 'text-base md:text-lg',
  2: 'text-sm md:text-base',
  default: 'text-xs md:text-sm',
} as const;
const PADDINGS = {
  0: 'py-3 px-4 md:py-4 md:px-5',
  1: 'py-2 px-3 md:py-3 md:px-4',
  default: 'py-1.5 px-2 md:py-2 md:px-3',
} as const;
const GAPS = {
  container: 'gap-2 md:gap-4',
  margin: 'mt-2 md:mt-4',
} as const;
const CONTAINER_STYLES = {
  wrapper: 'w-full bg-zinc-100 rounded-lg ring-1 ring-zinc-200 overflow-hidden',
  flexContainer: 'w-full flex flex-wrap',
  centerContent: 'justify-center',
} as const;
const BOX_STYLES = {
  base: 'w-full rounded-lg border transition-all duration-200',
  interactive: 'group cursor-pointer',
  textBase: 'font-medium transition-all duration-200',
  linkBase: 'transition-all duration-200 block truncate',
} as const;
const ANIMATIONS = {
  duration: 'duration-200',
  fontWeight: 'group-hover:font-semibold',
} as const;
export const NestedBoxesRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    return (
      <div className={CONTAINER_STYLES.wrapper}>
        <BoxView nodes={nodes} />
      </div>
    );
  }
);
const BoxView = memo(
  ({ nodes, depth = 0 }: { nodes: SummaryNode[]; depth?: number }) => {
    const scheme = COLOR_SCHEMES[depth % COLOR_SCHEMES.length];
    const uniqueId = useId();
    const getFontSize = (depth: number): string => {
      if (depth in FONT_SIZES) {
        return FONT_SIZES[depth as keyof typeof FONT_SIZES];
      }
      return FONT_SIZES.default;
    };
    const getPadding = (depth: number): string => {
      if (depth in PADDINGS) {
        return PADDINGS[depth as keyof typeof PADDINGS];
      }
      return PADDINGS.default;
    };
    return (
      <div
        className={cn(
          CONTAINER_STYLES.flexContainer,
          GAPS.container,
          depth > 0 ? GAPS.margin : CONTAINER_STYLES.centerContent
        )}
      >
        {nodes.map((node) => (
          <div
            key={`${uniqueId}-${node.slug}`}
            className={cn(
              BOX_STYLES.base,
              BOX_STYLES.interactive,
              scheme.bg,
              scheme.border,
              getPadding(depth)
            )}
          >
            <div
              className={cn(
                BOX_STYLES.textBase,
                scheme.text,
                ANIMATIONS.fontWeight,
                getFontSize(depth)
              )}
            >
              <Link
                href={`/learn/${getNodeSlugPath(node)}`}
                className={BOX_STYLES.linkBase}
              >
                {node.title}
              </Link>
            </div>
            {node.children.length > 0 && (
              <BoxView nodes={node.children} depth={depth + 1} />
            )}
          </div>
        ))}
      </div>
    );
  }
);

================
File: src/components/visualizations/renderers/tree/ascii-tree-renderer.tsx
================
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import { generateASCIITree } from '@/lib/text/ascii-tree-generator';
import { memo } from 'react';
export const ASCIITreeRenderer = memo(({ nodes }: { nodes: SummaryNode[] }) => {
  return (
    <div className="max-w-none overflow-hidden rounded-lg bg-zinc-100/80 shadow ring-1 shadow-zinc-100 ring-zinc-200">
      <p
        className={cn(
          'overflow-auto p-6 text-base whitespace-pre text-zinc-700'
        )}
      >
        {generateASCIITree(nodes, {
          indent: '',
        })}
      </p>
    </div>
  );
});

================
File: src/components/visualizations/renderers/tree/collapsible-tree-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import { transliterate } from '@/lib/text/transliteration';
import { memo } from 'react';
const ZINC_SHADES = [
  {
    background: 'bg-zinc-50 dark:bg-zinc-900',
    border: 'border-zinc-200 dark:border-zinc-700',
    text: 'text-zinc-900 dark:text-zinc-100',
    connection: 'border-zinc-300 dark:border-zinc-600',
  },
  {
    background: 'bg-zinc-100 dark:bg-zinc-800',
    border: 'border-zinc-300 dark:border-zinc-600',
    text: 'text-zinc-800 dark:text-zinc-200',
    connection: 'border-zinc-400 dark:border-zinc-500',
  },
  {
    background: 'bg-zinc-200 dark:bg-zinc-700',
    border: 'border-zinc-400 dark:border-zinc-500',
    text: 'text-zinc-700 dark:text-zinc-300',
    connection: 'border-zinc-500 dark:border-zinc-400',
  },
  {
    background: 'bg-zinc-300 dark:bg-zinc-600',
    border: 'border-zinc-500 dark:border-zinc-400',
    text: 'text-zinc-600 dark:text-zinc-400',
    connection: 'border-zinc-600 dark:border-zinc-300',
  },
  {
    background: 'bg-zinc-400 dark:bg-zinc-500',
    border: 'border-zinc-600 dark:border-zinc-300',
    text: 'text-white dark:text-zinc-100',
    connection: 'border-zinc-700 dark:border-zinc-200',
  },
  {
    background: 'bg-zinc-500 dark:bg-zinc-400',
    border: 'border-zinc-700 dark:border-zinc-200',
    text: 'text-white dark:text-zinc-900',
    connection: 'border-zinc-800 dark:border-zinc-100',
  },
] as const;
const CONTAINER_COLORS = {
  background: 'bg-zinc-50 dark:bg-zinc-900',
  ring: 'ring-zinc-200 dark:ring-zinc-700',
  shadow: 'shadow-zinc-100 dark:shadow-zinc-800',
} as const;
const SPACING = {
  container: 'p-6',
  nodeGap: 'space-y-3',
  nodeMargin: 'mt-3',
  nodePadding: 'px-4 py-3',
  indent: 'mr-4',
  connector: 'w-4',
} as const;
const LAYOUT = {
  containerBase: 'w-full rounded-lg shadow ring-1',
  flexColumn: 'flex flex-col',
  flexRow: 'flex items-center',
  nodeBase: 'rounded-lg border transition-all duration-200',
  nodeParent: 'font-semibold',
  nodeLeaf: 'font-medium',
  connectionLine: 'border-l-2',
  connectionHorizontal: 'h-0.5',
  connectionHeight: 'h-6',
  connectionShort: 'h-3',
  hover: 'hover:shadow-md hover:scale-[1.01]',
} as const;
const getColorsForLevel = (level: number) => {
  return ZINC_SHADES[level % ZINC_SHADES.length];
};
export const CollapsibleTreeRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    return (
      <div
        className={cn(
          LAYOUT.containerBase,
          CONTAINER_COLORS.background,
          CONTAINER_COLORS.ring,
          CONTAINER_COLORS.shadow,
          SPACING.container
        )}
      >
        <TreeView nodes={nodes} />
      </div>
    );
  }
);
const TreeView = memo(
  ({ nodes, level = 0 }: { nodes: SummaryNode[]; level?: number }) => {
    const levelColors = getColorsForLevel(level);
    return (
      <div className={cn(LAYOUT.flexColumn, SPACING.nodeGap)}>
        {nodes.map((node, index) => (
          <div key={node.slug}>
            <div className={LAYOUT.flexRow}>
              {level > 0 && (
                <div className={LAYOUT.flexRow}>
                  {Array.from({ length: level }).map((_, i) => {
                    const connectionColors = getColorsForLevel(i);
                    return (
                      <div
                        key={i}
                        className={cn(
                          SPACING.indent,
                          LAYOUT.connectionHeight,
                          SPACING.connector,
                          LAYOUT.connectionLine,
                          connectionColors.connection,
                          index === nodes.length - 1 &&
                            i === level - 1 &&
                            LAYOUT.connectionShort
                        )}
                      />
                    );
                  })}
                  <div
                    className={cn(
                      LAYOUT.connectionHorizontal,
                      SPACING.connector,
                      levelColors.connection.replace('border-', 'bg-'),
                      index === nodes.length - 1 && LAYOUT.connectionShort
                    )}
                  />
                </div>
              )}
              {}
              <div
                className={cn(
                  LAYOUT.nodeBase,
                  LAYOUT.hover,
                  SPACING.nodePadding,
                  levelColors.background,
                  levelColors.border,
                  levelColors.text,
                  node.children.length > 0 ? LAYOUT.nodeParent : LAYOUT.nodeLeaf
                )}
              >
                <div className="flex items-center justify-between">
                  <span>{node.title}</span>
                  {node.children.length > 0 && (
                    <span
                      className={cn(
                        'ml-3 rounded-full px-2 py-1 text-xs',
                        'bg-white/20 dark:bg-black/20'
                      )}
                    >
                      {transliterate({
                        input: node.children.length,
                        mode: 'latin-numbers-to-arabic-digits',
                      })}
                    </span>
                  )}
                </div>
              </div>
            </div>
            {}
            {node.children.length > 0 && (
              <div className={SPACING.nodeMargin}>
                <TreeView nodes={node.children} level={level + 1} />
              </div>
            )}
          </div>
        ))}
      </div>
    );
  }
);

================
File: src/components/visualizations/renderers/tree/node-link-diagram-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as d3 from 'd3';
import { memo, useEffect, useRef, useState } from 'react';
type TreeNode = {
  id: string;
  name: string;
  children?: TreeNode[];
};
type TreeVisualizationProps = {
  nodes: SummaryNode[];
  height?: number;
};
export const NodeLinkDiagramRenderer = memo(
  ({ nodes, height = 600 }: TreeVisualizationProps) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [dimensions, setDimensions] = useState({ width: 0, height });
    useEffect(() => {
      if (!containerRef.current) return;
      const updateDimensions = () => {
        if (containerRef.current) {
          const { width } = containerRef.current.getBoundingClientRect();
          setDimensions({ width, height });
        }
      };
      updateDimensions();
      const resizeObserver = new ResizeObserver(updateDimensions);
      resizeObserver.observe(containerRef.current);
      return () => {
        if (containerRef.current) {
          resizeObserver.unobserve(containerRef.current);
        }
        resizeObserver.disconnect();
      };
    }, [height]);
    useEffect(() => {
      if (!containerRef.current || nodes.length === 0 || dimensions.width === 0)
        return;
      containerRef.current.innerHTML = '';
      const svg = d3
        .select(containerRef.current)
        .append('svg')
        .attr('width', '100%')
        .attr('height', dimensions.height)
        .attr('viewBox', `0 0 ${dimensions.width} ${dimensions.height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');
      const contentGroup = svg.append('g').attr('class', 'content');
      const transformNodes = (inputNodes: SummaryNode[]): TreeNode[] => {
        return inputNodes.map((node, index) => ({
          id: node.slug || `node-${index}`,
          name: node.title,
          children: node.children?.length
            ? transformNodes(node.children)
            : undefined,
        }));
      };
      const treeData: TreeNode[] = transformNodes(nodes);
      const root = d3.hierarchy(treeData[0]);
      const isMobile = window.innerWidth < 768;
      const treeLayout = d3
        .tree<TreeNode>()
        .size(
          isMobile
            ? [dimensions.height - 100, dimensions.width - 100]
            : [dimensions.height - 40, dimensions.width - 180]
        )
        .separation((a, b) => (a.parent === b.parent ? 1 : 1.2));
      treeLayout(root);
      contentGroup
        .selectAll('path.link')
        .data(root.links())
        .join('path')
        .attr('class', 'link')
        .attr(
          'd',
          d3
            .linkHorizontal<
              d3.HierarchyLink<TreeNode>,
              d3.HierarchyPointNode<TreeNode>
            >()
            .x((d) => d.y)
            .y((d) => d.x)
        )
        .style('fill', 'none')
        .style('stroke', '#555')
        .style('stroke-width', 1.5);
      const nodeGroups = contentGroup
        .selectAll('g.node')
        .data(root.descendants())
        .join('g')
        .attr('class', 'node')
        .attr('transform', (d) => `translate(${d.y},${d.x})`);
      nodeGroups
        .append('circle')
        .attr('r', 6)
        .style('fill', (d: d3.HierarchyNode<TreeNode>) =>
          d.children ? '#555' : '#999'
        )
        .style('stroke', '#fff')
        .style('stroke-width', 2);
      nodeGroups
        .append('text')
        .attr('dy', '-1.2em')
        .attr('x', 0)
        .style('text-anchor', 'middle')
        .text((d: d3.HierarchyNode<TreeNode>) => d.data.name)
        .style('font-size', isMobile ? '10px' : '12px')
        .style('font-family', 'sans-serif')
        .style('fill', '#333');
      nodeGroups
        .on(
          'mouseover',
          function (event: MouseEvent, d: d3.HierarchyNode<TreeNode>) {
            d3.select(this)
              .select('circle')
              .transition()
              .duration(200)
              .attr('r', 8)
              .style('fill', '#0066cc');
            d3.select(this).select('text').style('font-weight', 'bold');
          }
        )
        .on(
          'mouseout',
          function (event: MouseEvent, d: d3.HierarchyNode<TreeNode>) {
            d3.select(this)
              .select('circle')
              .transition()
              .duration(200)
              .attr('r', 6)
              .style('fill', d.children ? '#555' : '#999');
            d3.select(this).select('text').style('font-weight', 'normal');
          }
        );
      const zoom = d3
        .zoom()
        .scaleExtent([0.3, 3])
        .on('zoom', (event) => {
          contentGroup.attr('transform', event.transform);
        });
      svg.call(zoom as any);
      if (isMobile) {
        const rootNode = root;
        const rootX = rootNode.y || 0;
        const rootY = rootNode.x || 0;
        const scale = 1.0;
        const viewportCenterX = dimensions.width / 2;
        const viewportCenterY = dimensions.height / 2;
        const translateX = viewportCenterX - rootX * scale;
        const translateY = viewportCenterY - rootY * scale;
        svg.call(
          zoom.transform as any,
          d3.zoomIdentity.translate(translateX, translateY).scale(scale)
        );
      } else {
        const bounds = contentGroup.node()?.getBBox();
        if (bounds) {
          const scale = Math.min(
            dimensions.width / bounds.width,
            dimensions.height / bounds.height,
            0.9
          );
          const x = (dimensions.width - bounds.width * scale) / 2;
          const y = (dimensions.height - bounds.height * scale) / 2;
          svg.call(
            zoom.transform as any,
            d3.zoomIdentity.translate(x, y).scale(scale)
          );
        }
      }
    }, [nodes, dimensions.width, dimensions.height]);
    return (
      <div
        ref={containerRef}
        className="h-full w-full overflow-hidden rounded-lg bg-zinc-100 shadow ring-1 shadow-zinc-200 ring-zinc-200 dark:bg-zinc-900"
        style={{ minHeight: height }}
      />
    );
  }
);

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/styles/tailwind-utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: src/app/fonts.ts
================
import localFont from 'next/font/local';
export const ibmPlexSansArabic = localFont({
  src: [
    {
      path: '../../public/fonts/IBMPlexSansArabic-Regular-400.ttf',
      weight: '400',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-Medium-500.ttf',
      weight: '500',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-SemiBold-600.ttf',
      weight: '600',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-Bold-700.ttf',
      weight: '700',
      style: 'normal',
    },
  ],
  variable: '--font-ibmPlexSansArabic',
  display: 'swap',
  preload: true,
});

================
File: src/components/ui/button.tsx
================
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',
        destructive:
          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary:
          'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost:
          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}
export { Button, buttonVariants };

================
File: src/components/ui/dropdown-menu.tsx
================
'use client';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}
function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}
function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}
function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}
function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: 'default' | 'destructive';
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}
function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}
function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}
function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        'px-2 py-1.5 text-sm font-medium data-[inset]:pl-8',
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  );
}
function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        'text-muted-foreground ml-auto text-xs tracking-widest',
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}
function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        'focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8',
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}
function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg',
        className
      )}
      {...props}
    />
  );
}
export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};

================
File: src/components/ui/input.tsx
================
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        'file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        'focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',
        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
        className
      )}
      {...props}
    />
  );
}
export { Input };

================
File: src/components/ui/separator.tsx
================
'use client';
import * as SeparatorPrimitive from '@radix-ui/react-separator';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Separator({
  className,
  orientation = 'horizontal',
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',
        className
      )}
      {...props}
    />
  );
}
export { Separator };

================
File: src/components/ui/sheet.tsx
================
'use client';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />;
}
function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />;
}
function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />;
}
function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />;
}
function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className
      )}
      {...props}
    />
  );
}
function SheetContent({
  className,
  children,
  side = 'right',
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: 'top' | 'right' | 'bottom' | 'left';
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
          side === 'right' &&
            'data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm',
          side === 'left' &&
            'data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm',
          side === 'top' &&
            'data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b',
          side === 'bottom' &&
            'data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t',
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  );
}
function SheetHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-header"
      className={cn('flex flex-col gap-1.5 p-4', className)}
      {...props}
    />
  );
}
function SheetFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn('mt-auto flex flex-col gap-2 p-4', className)}
      {...props}
    />
  );
}
function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn('text-foreground font-semibold', className)}
      {...props}
    />
  );
}
function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}
export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
};

================
File: src/components/ui/skeleton.tsx
================
import { cn } from '@/lib/styles/tailwind-utils';
function Skeleton({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="skeleton"
      className={cn('bg-accent animate-pulse rounded-md', className)}
      {...props}
    />
  );
}
export { Skeleton };

================
File: src/components/ui/tooltip.tsx
================
'use client';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}
function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}
function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance',
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}
export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };

================
File: src/components/visualizations/renderers/radial/radial-sunburst-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as d3 from 'd3';
import { ZoomIn, ZoomOut } from 'lucide-react';
import { memo, useCallback, useEffect, useRef, useState } from 'react';
type HierarchyDatum = {
  name: string;
  value: number;
  children?: HierarchyDatum[];
};
const GRADIENT_DEFINITIONS = [
  { id: 'gradient-1', from: '#fafafa', to: '#f4f4f5' },
  { id: 'gradient-2', from: '#f4f4f5', to: '#e4e4e7' },
  { id: 'gradient-3', from: '#e4e4e7', to: '#d4d4d8' },
  { id: 'gradient-4', from: '#d4d4d8', to: '#a1a1aa' },
  { id: 'gradient-5', from: '#a1a1aa', to: '#71717a' },
  { id: 'gradient-6', from: '#71717a', to: '#52525b' },
  { id: 'gradient-7', from: '#52525b', to: '#3f3f46' },
  { id: 'gradient-8', from: '#3f3f46', to: '#27272a' },
  { id: 'gradient-9', from: '#27272a', to: '#18181b' },
] as const;
export const RadialSunburstRenderer = memo(
  ({
    nodes,
    initialWidth = 1000,
    initialHeight = 1000,
  }: {
    nodes: SummaryNode[];
    initialWidth?: number;
    initialHeight?: number;
  }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const svgRef = useRef<SVGSVGElement>(null);
    const zoomBehaviorRef = useRef<d3.ZoomBehavior<
      SVGSVGElement,
      unknown
    > | null>(null);
    const [zoomLevel, setZoomLevel] = useState(1);
    const [dimensions, setDimensions] = useState({
      width: initialWidth,
      height: initialHeight,
    });
    const transformData = useCallback(
      (nodes: SummaryNode[]): HierarchyDatum[] => {
        const transform = (nodes: SummaryNode[]): HierarchyDatum[] => {
          return nodes.map(
            (node): HierarchyDatum => ({
              name: node.title,
              value: node.children.length ? 0 : 1,
              children: node.children.length
                ? transform(node.children)
                : undefined,
            })
          );
        };
        return transform(nodes);
      },
      []
    );
    useEffect(() => {
      const updateDimensions = () => {
        if (!containerRef.current) return;
        const containerWidth = containerRef.current.clientWidth;
        const containerHeight = containerRef.current.clientHeight;
        const size = Math.max(
          Math.min(
            Math.min(containerWidth - 40, containerHeight - 100),
            initialWidth
          ),
          1000
        );
        setDimensions({ width: size, height: size });
      };
      updateDimensions();
      window.addEventListener('resize', updateDimensions);
      return () => window.removeEventListener('resize', updateDimensions);
    }, [initialWidth, initialHeight]);
    const handleZoomIn = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        d3.select(svgRef.current)
          .transition()
          .duration(300)
          .call(zoomBehaviorRef.current.scaleBy, 1.5);
      }
    }, []);
    const handleZoomOut = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        d3.select(svgRef.current)
          .transition()
          .duration(300)
          .call(zoomBehaviorRef.current.scaleBy, 1 / 1.5);
      }
    }, []);
    const handleResetZoom = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        const { width, height } = dimensions;
        const centerX = width / 2;
        const centerY = height / 2;
        d3.select(svgRef.current)
          .transition()
          .duration(500)
          .call(
            zoomBehaviorRef.current.transform,
            d3.zoomIdentity.translate(centerX, centerY).scale(1)
          );
      }
    }, [dimensions]);
    useEffect(() => {
      if (!svgRef.current || !nodes.length || !dimensions.width) return;
      const svg = d3.select(svgRef.current);
      svg.selectAll('*').remove();
      const { width, height } = dimensions;
      const radius = Math.min(width, height) / 2.2;
      const defs = svg.append('defs');
      GRADIENT_DEFINITIONS.forEach((gradientDef) => {
        const gradient = defs
          .append('radialGradient')
          .attr('id', gradientDef.id)
          .attr('cx', '50%')
          .attr('cy', '50%')
          .attr('r', '50%');
        gradient
          .append('stop')
          .attr('offset', '0%')
          .attr('stop-color', gradientDef.from);
        gradient
          .append('stop')
          .attr('offset', '100%')
          .attr('stop-color', gradientDef.to);
      });
      const zoom = d3
        .zoom<SVGSVGElement, unknown>()
        .scaleExtent([0.5, 5])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
          setZoomLevel(event.transform.k);
        });
      zoomBehaviorRef.current = zoom;
      svg.call(zoom);
      const g = svg
        .append('g')
        .attr('transform', `translate(${width / 2},${height / 2})`);
      const root = d3
        .hierarchy<HierarchyDatum>({
          name: 'root',
          value: 0,
          children: transformData(nodes),
        })
        .sum((d) => d.value);
      const partition = d3
        .partition<HierarchyDatum>()
        .size([2 * Math.PI, radius * 0.95]);
      const rootWithPartition = partition(root);
      const gradientScale = d3
        .scaleOrdinal<number, string>()
        .domain([1, 2, 3, 4, 5, 6, 7, 8, 9])
        .range(GRADIENT_DEFINITIONS.map((def) => def.id));
      const arc = d3
        .arc<d3.HierarchyRectangularNode<HierarchyDatum>>()
        .startAngle((d) => d.x0)
        .endAngle((d) => d.x1)
        .innerRadius((d) => d.y0)
        .outerRadius((d) => d.y1);
      const segments = g
        .selectAll('path')
        .data(rootWithPartition.descendants().slice(1))
        .enter()
        .append('path')
        .attr('d', (d) => arc(d as d3.HierarchyRectangularNode<HierarchyDatum>))
        .style('fill', (d) => `url(#${gradientScale(d.depth)})`)
        .style('opacity', 0.9)
        .style('stroke', '#ffffff')
        .style('stroke-width', '1px')
        .style('cursor', 'pointer')
        .on('mouseover', function () {
          d3.select(this).style('opacity', 1).style('stroke-width', '2px');
        })
        .on('mouseout', function () {
          d3.select(this).style('opacity', 0.9).style('stroke-width', '1px');
        });
      segments.append('title').text((d) => d.data.name);
      const textNodes = rootWithPartition
        .descendants()
        .slice(1)
        .filter((d) => {
          const node = d as d3.HierarchyRectangularNode<HierarchyDatum>;
          const arcAngleDegrees = (node.x1 - node.x0) * (180 / Math.PI);
          const radialThickness = node.y1 - node.y0;
          const minAngle = node.depth === 1 ? 3 : node.depth === 2 ? 2 : 1.5;
          const minThickness = radius * 0.02;
          return arcAngleDegrees > minAngle && radialThickness > minThickness;
        });
      const textContainers = g
        .selectAll('.text-container')
        .data(textNodes)
        .enter()
        .append('g')
        .attr('class', 'text-container');
      textContainers.each(function (d) {
        const node = d as d3.HierarchyRectangularNode<HierarchyDatum>;
        const middleAngle = (node.x0 + node.x1) / 2;
        const middleRadius = (node.y0 + node.y1) / 2;
        const x = Math.sin(middleAngle) * middleRadius;
        const y = -Math.cos(middleAngle) * middleRadius;
        const arcWidth = node.y1 - node.y0;
        const arcAngle = node.x1 - node.x0;
        const arcLength = arcAngle * middleRadius;
        const boxWidth = Math.min(arcLength * 0.9, arcWidth * 2);
        const boxHeight = arcWidth * 0.9;
        const baseFontSize =
          Math.min(dimensions.width, dimensions.height) / 100;
        let fontSize;
        if (d.depth === 1) {
          fontSize = Math.min(baseFontSize * 2.5, arcWidth * 0.4);
        } else if (d.depth === 2) {
          fontSize = Math.min(baseFontSize * 2, arcWidth * 0.3);
        } else {
          fontSize = Math.min(baseFontSize * 1.5, arcWidth * 0.25);
        }
        fontSize = Math.max(fontSize, 8);
        let rotation = (middleAngle * 180) / Math.PI;
        if (rotation > 90 && rotation < 270) {
          rotation += 180;
        }
        const textColor = d.depth <= 4 ? '#18181b' : '#ffffff';
        const textElement = d3
          .select(this)
          .attr('transform', `translate(${x},${y}) rotate(${rotation})`)
          .append('text')
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .attr('fill', textColor)
          .attr('font-size', `${fontSize}px`)
          .attr('font-family', 'var(--font-ibmPlexSansArabic)')
          .attr('font-weight', '600')
          .style(
            'text-shadow',
            textColor === '#ffffff'
              ? '1px 1px 3px rgba(0,0,0,0.8)'
              : '1px 1px 3px rgba(255,255,255,0.8)'
          );
        const words = d.data.name.split(/\s+/);
        const lineHeight = fontSize * 1.2;
        const maxLines = Math.max(1, Math.floor(boxHeight / lineHeight));
        const charsPerLine = Math.max(
          3,
          Math.floor(boxWidth / (fontSize * 0.55))
        );
        if (
          words.length === 1 &&
          words[0].length > charsPerLine &&
          maxLines > 1
        ) {
          const word = words[0];
          let currentLine = '';
          let lineNumber = 0;
          for (let i = 0; i < word.length && lineNumber < maxLines; i++) {
            currentLine += word[i];
            if (currentLine.length >= charsPerLine || i === word.length - 1) {
              const isLastLine =
                lineNumber === maxLines - 1 || i === word.length - 1;
              const text =
                isLastLine && i < word.length - 1
                  ? currentLine + '...'
                  : currentLine;
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(text);
              currentLine = '';
              lineNumber++;
            }
          }
        } else {
          // Handle multiple words
          let currentLine = '';
          let lineNumber = 0;
          for (let i = 0; i < words.length && lineNumber < maxLines; i++) {
            const word = words[i];
            const testLine = currentLine + (currentLine ? ' ' : '') + word;
            if (testLine.length <= charsPerLine || currentLine === '') {
              currentLine = testLine;
            } else {
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(currentLine);
              currentLine = word;
              lineNumber++;
            }
            if (i === words.length - 1 && lineNumber < maxLines) {
              const isLastPossibleLine = lineNumber === maxLines - 1;
              const hasMoreWords = i < words.length - 1;
              const text =
                isLastPossibleLine && hasMoreWords
                  ? currentLine + '...'
                  : currentLine;
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(text);
            }
          }
        }
      });
    }, [nodes, dimensions, transformData]);
    return (
      <div
        ref={containerRef}
        className="relative h-[80vh] w-full rounded-lg bg-zinc-100/80 shadow ring-1 shadow-zinc-100 ring-zinc-200 dark:bg-slate-800"
      >
        {}
        <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
          <button
            onClick={handleZoomIn}
            className="flex items-center justify-center rounded-lg border border-zinc-200 bg-white p-2 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700"
            title="Zoom In"
          >
            <ZoomIn className="h-5 w-5 text-zinc-600 dark:text-zinc-300" />
          </button>
          <button
            onClick={handleZoomOut}
            className="flex items-center justify-center rounded-lg border border-zinc-200 bg-white p-2 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700"
            title="Zoom Out"
          >
            <ZoomOut className="h-5 w-5 text-zinc-600 dark:text-zinc-300" />
          </button>
          <button
            onClick={handleResetZoom}
            className="rounded-lg border border-zinc-200 bg-white px-3 py-2 text-xs font-bold text-zinc-600 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700 dark:text-zinc-300"
            title="Reset Zoom"
          >
            اضبط
          </button>
        </div>
        {}
        <div className="absolute right-4 bottom-4 z-10 rounded-lg border border-zinc-200 bg-white px-3 py-1 shadow-xs dark:border-zinc-600 dark:bg-zinc-700">
          <span className="text-xs font-medium text-zinc-600 dark:text-zinc-300">
            {Math.round(zoomLevel * 100)}%
          </span>
        </div>
        {}
        <div className="flex h-full w-full items-center justify-center overflow-hidden">
          <svg
            ref={svgRef}
            className="cursor-grab active:cursor-grabbing"
            width={`${dimensions.width}px`}
            height={`${dimensions.height}px`}
            viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
            preserveAspectRatio="xMidYMid meet"
          />
        </div>
      </div>
    );
  }
);
RadialSunburstRenderer.displayName = 'RadialSunburstRenderer';

================
File: src/components/visualizations/visualization-switcher.tsx
================
'use client';
import type React from 'react';
import type { SummaryNode } from '@/lib/content/types';
import {
  Boxes,
  GitBranch,
  Grid,
  Network,
  PieChart,
  Target,
  Terminal,
} from 'lucide-react';
import { memo, useMemo, useState } from 'react';
import { RadialSunburstRenderer } from './renderers/radial/radial-sunburst-renderer';
import { CirclePackRenderer } from './renderers/spatial/circle-pack-renderer';
import { GridLayoutRenderer } from './renderers/spatial/grid-layout-renderer';
import { NestedBoxesRenderer } from './renderers/spatial/nested-boxes-renderer';
import { ASCIITreeRenderer } from './renderers/tree/ascii-tree-renderer';
import { CollapsibleTreeRenderer } from './renderers/tree/collapsible-tree-renderer';
import { NodeLinkDiagramRenderer } from './renderers/tree/node-link-diagram-renderer';
type VisualizationType =
  | 'collapsible-tree'
  | 'ascii-tree'
  | 'nested-boxes'
  | 'grid-layout'
  | 'radial-sunburst'
  | 'node-diagram'
  | 'circle-pack';
interface VisualizationConfig {
  type: VisualizationType;
  label: string;
  icon: React.ReactNode;
  component: React.ComponentType<{ nodes: SummaryNode[] }>;
}
const VISUALIZATION_CONFIGS: VisualizationConfig[] = [
  {
    type: 'node-diagram',
    label: 'شبكة',
    icon: <Network className="h-4 w-4" />,
    component: NodeLinkDiagramRenderer,
  },
  {
    type: 'circle-pack',
    label: 'تراص',
    icon: <Target className="h-4 w-4" />,
    component: CirclePackRenderer,
  },
  {
    type: 'radial-sunburst',
    label: 'شعاع',
    icon: <PieChart className="h-4 w-4" />,
    component: RadialSunburstRenderer,
  },
  {
    type: 'ascii-tree',
    label: 'تفرع',
    icon: <Terminal className="h-4 w-4" />,
    component: ASCIITreeRenderer,
  },
  {
    type: 'collapsible-tree',
    label: 'سلسلة',
    icon: <GitBranch className="h-4 w-4" />,
    component: CollapsibleTreeRenderer,
  },
  {
    type: 'nested-boxes',
    label: 'وعاء',
    icon: <Boxes className="h-4 w-4" />,
    component: NestedBoxesRenderer,
  },
  {
    type: 'grid-layout',
    label: 'مصفوفة',
    icon: <Grid className="h-4 w-4" />,
    component: GridLayoutRenderer,
  },
];
export const VisualizationSwitcher = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    const [visualizationType, setVisualizationType] =
      useState<VisualizationType>(VISUALIZATION_CONFIGS[0].type);
    const currentVisualization = useMemo(() => {
      const config = VISUALIZATION_CONFIGS.find(
        (cfg) => cfg.type === visualizationType
      );
      if (config) {
        const Component = config.component;
        return <Component nodes={nodes} />;
      }
      return null;
    }, [visualizationType, nodes]);
    return (
      <>
        <VisualizationTypeSelector
          visualizationType={visualizationType}
          onVisualizationChange={setVisualizationType}
          configs={VISUALIZATION_CONFIGS}
        />
        <div className="transition-opacity duration-300">
          {currentVisualization}
        </div>
      </>
    );
  }
);
VisualizationSwitcher.displayName = 'VisualizationSwitcher';
const VisualizationTypeSelector = memo(
  ({
    visualizationType,
    onVisualizationChange,
    configs,
  }: {
    visualizationType: VisualizationType;
    onVisualizationChange: (type: VisualizationType) => void;
    configs: VisualizationConfig[];
  }) => {
    return (
      <div className="flex flex-wrap gap-2">
        {configs.map((config) => (
          <button
            key={config.type}
            onClick={() => onVisualizationChange(config.type)}
            className={`flex cursor-pointer items-center gap-2 rounded-md px-3 py-1.5 text-sm transition-colors ${
              visualizationType === config.type
                ? 'bg-zinc-200 text-zinc-900 dark:bg-zinc-700 dark:text-zinc-100'
                : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700'
            }`}
            aria-label={`تغيير إلى ${config.label}`}
            title={`تغيير إلى ${config.label}`}
          >
            {config.icon}
            <span className="hidden sm:inline">{config.label}</span>
          </button>
        ))}
      </div>
    );
  }
);
VisualizationTypeSelector.displayName = 'VisualizationTypeSelector';

================
File: src/hooks/use-sidebar.tsx
================
import type { SummaryNode } from '@/lib/content/types';
import { usePathname } from 'next/navigation';
import { useCallback, useMemo, useState } from 'react';
export function useSidebar(summaryTree: SummaryNode[]) {
  const pathname = usePathname();
  const [expandedSections, setExpandedSections] = useState<
    Record<string, boolean>
  >(() => ({}));
  const toggleSection = useCallback((path: string) => {
    setExpandedSections((prev) => ({
      ...prev,
      [path]: !prev[path],
    }));
  }, []);
  const isCurrentPage = useCallback(
    (fullPath: string) => {
      if (fullPath === '__home') return pathname === '/';
      return pathname === `/learn/${fullPath}/`;
    },
    [pathname]
  );
  const flatItems = useMemo(() => {
    const walk = (
      nodes: SummaryNode[],
      level = 0
    ): { node: SummaryNode; level: number }[] => {
      let result: { node: SummaryNode; level: number }[] = [];
      for (const node of nodes) {
        result.push({ node, level });
        result = result.concat(walk(node.children, level + 1));
      }
      return result;
    };
    return walk(summaryTree);
  }, [summaryTree]);
  const getAllPaths = useCallback((nodes: SummaryNode[]): string[] => {
    let paths: string[] = [];
    for (const node of nodes) {
      const fullPath = [...node.parentPath, node.slug].join('/');
      if (node.children.length > 0) {
        paths.push(fullPath);
        paths = paths.concat(getAllPaths(node.children));
      }
    }
    return paths;
  }, []);
  const expandAll = useCallback(() => {
    const all = getAllPaths(summaryTree);
    const expanded: Record<string, boolean> = {};
    all.forEach((p) => (expanded[p] = true));
    setExpandedSections(expanded);
  }, [summaryTree, getAllPaths]);
  const collapseAll = useCallback(() => {
    setExpandedSections({});
  }, []);
  const toggleAll = useCallback(() => {
    const allPaths = getAllPaths(summaryTree);
    const someExpanded = allPaths.some((path) => expandedSections[path]);
    if (someExpanded) collapseAll();
    else expandAll();
  }, [expandedSections, collapseAll, expandAll, getAllPaths, summaryTree]);
  return useMemo(
    () => ({
      flatItems,
      expandedSections,
      toggleSection,
      isCurrentPage,
      toggleAll,
    }),
    [flatItems, expandedSections, toggleSection, isCurrentPage, toggleAll]
  );
}

================
File: next.config.ts
================
import { setupDevPlatform } from '@cloudflare/next-on-pages/next-dev';
setupDevPlatform().catch(console.error);
import type { NextConfig } from 'next';
const nextConfig: NextConfig = {
  trailingSlash: true,
  devIndicators: false,
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
};
export default nextConfig;

================
File: src/app/globals.css
================
@import 'tailwindcss';
@import 'tw-animate-css';
@plugin "@tailwindcss/typography";
@plugin "tailwindcss-debug-screens" {
  classname: 'debug-screens';
  position: 'bottom, right';
  prefix: 'screen: ';
}
@custom-variant dark (&:is(.dark *));
@theme {
  --font-ibmPlexSansArabic: var(--font-ibmPlexSansArabic);
}
@theme {
  --breakpoint-*: initial;
  --breakpoint-xxs: 20rem;
  --breakpoint-xs: 30rem;
  --breakpoint-sm: 40rem;
  --breakpoint-md: 48rem;
  --breakpoint-lg: 64rem;
  --breakpoint-xl: 80rem;
  --breakpoint-2xl: 96rem;
  --breakpoint-3xl: 112rem;
  --breakpoint-4xl: 128rem;
}
@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}
:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}
.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}
@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/components/ui/sidebar.tsx
================
'use client';
import { Slot } from '@radix-ui/react-slot';
import { VariantProps, cva } from 'class-variance-authority';
import { PanelRightIcon } from 'lucide-react';
import * as React from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Separator } from '@/components/ui/separator';
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useIsMobile } from '@/hooks/use-mobile';
import { cn } from '@/lib/styles/tailwind-utils';
const SIDEBAR_COOKIE_NAME = 'sidebar_state';
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = '16rem';
const SIDEBAR_WIDTH_MOBILE = '18rem';
const SIDEBAR_WIDTH_ICON = '3rem';
const SIDEBAR_KEYBOARD_SHORTCUT = 'b';
type SidebarContextProps = {
  state: 'expanded' | 'collapsed';
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};
const SidebarContext = React.createContext<SidebarContextProps | null>(null);
function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.');
  }
  return context;
}
function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === 'function' ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault();
        toggleSidebar();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleSidebar]);
  const state = open ? 'expanded' : 'collapsed';
  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );
  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH,
              '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            'group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full',
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
}
function Sidebar({
  side = 'left',
  variant = 'sidebar',
  collapsible = 'offcanvas',
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  side?: 'left' | 'right';
  variant?: 'sidebar' | 'floating' | 'inset';
  collapsible?: 'offcanvas' | 'icon' | 'none';
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();
  if (collapsible === 'none') {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          'bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col',
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }
  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === 'collapsed' ? collapsible : ''}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          'relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear',
          'group-data-[collapsible=offcanvas]:w-0',
          'group-data-[side=right]:rotate-180',
          variant === 'floating' || variant === 'inset'
            ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon)'
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          'fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex',
          side === 'left'
            ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
            : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
          variant === 'floating' || variant === 'inset'
            ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l',
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
}
function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar();
  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn('size-7', className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelRightIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
}
function SidebarRail({ className, ...props }: React.ComponentProps<'button'>) {
  const { toggleSidebar } = useSidebar();
  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        'hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex',
        'in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize',
        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
        'hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full',
        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
        className
      )}
      {...props}
    />
  );
}
function SidebarInset({ className, ...props }: React.ComponentProps<'main'>) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        'bg-background relative flex w-full flex-1 flex-col',
        'md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2',
        className
      )}
      {...props}
    />
  );
}
function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn('bg-background h-8 w-full shadow-none', className)}
      {...props}
    />
  );
}
function SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}
function SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}
function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn('bg-sidebar-border mx-2 w-auto', className)}
      {...props}
    />
  );
}
function SidebarContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
      {...props}
    />
  );
}
function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'div'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'div';
  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        'text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 left-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'after:absolute after:-inset-2 md:after:hidden',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn('w-full text-sm', className)}
      {...props}
    />
  );
}
function SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn('flex w-full min-w-0 flex-col gap-1', className)}
      {...props}
    />
  );
}
function SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn('group/menu-item relative', className)}
      {...props}
    />
  );
}
const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:p-0!',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = 'default',
  size = 'default',
  tooltip,
  className,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : 'button';
  const { isMobile, state } = useSidebar();
  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );
  if (!tooltip) {
    return button;
  }
  if (typeof tooltip === 'string') {
    tooltip = {
      children: tooltip,
    };
  }
  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== 'collapsed' || isMobile}
        {...tooltip}
      />
    </Tooltip>
  );
}
function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'after:absolute after:-inset-2 md:after:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        'text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none',
        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<'div'> & {
  showIcon?: boolean;
}) {
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);
  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  );
}
function SidebarMenuSub({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        'border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn('group/menu-sub-item relative', className)}
      {...props}
    />
  );
}
function SidebarMenuSubButton({
  asChild = false,
  size = 'md',
  isActive = false,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean;
  size?: 'sm' | 'md';
  isActive?: boolean;
}) {
  const Comp = asChild ? Slot : 'a';
  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};

================
File: src/app/not-found.tsx
================
import { Button } from '@/components/ui/button';
import { flattenTree } from '@/lib/content/api';
import { buildContentSummaryTree } from '@/lib/content/core/tree-builder';
import { getNodeSlugPath } from '@/lib/content/query/get-node-path';
import { FileQuestion, Home, Search } from 'lucide-react';
import Link from 'next/link';
export const metadata = {
  title: 'Page Not Found | Documentation',
  description: "The page you're looking for doesn't exist or has been moved.",
};
export default async function NotFound() {
  const summaryTree = await buildContentSummaryTree();
  const flatTree = flattenTree(summaryTree);
  const suggestedPages = flatTree.sort(() => 0.5 - Math.random()).slice(0, 3);
  return (
    <div className="flex flex-col items-center justify-center px-4 py-16 text-center">
      <div className="mb-8 rounded-full bg-slate-100 p-6 dark:bg-slate-800">
        <FileQuestion className="h-16 w-16 text-slate-500" />
      </div>
      <h1 className="mb-2 text-4xl font-bold tracking-tight">
        {`404 - Page Not Found`}
      </h1>
      <p className="mb-8 max-w-md text-lg text-slate-500 dark:text-slate-400">
        {`The documentation page you're looking for doesn't exist or has been
        moved to a new location.`}
      </p>
      <div className="mb-12 flex flex-wrap justify-center gap-4">
        <Button asChild>
          <Link href="/">
            <Home className="mr-2 h-4 w-4" />
            Back to Home
          </Link>
        </Button>
        <Button variant="outline" asChild>
          <Link href="/learn">
            <Search className="mr-2 h-4 w-4" />
            Browse All Docs
          </Link>
        </Button>
      </div>
      {suggestedPages.length > 0 && (
        <>
          <h2 className="mb-4 text-xl font-semibold">
            You might be interested in:
          </h2>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {suggestedPages.map((page) => (
              <Link
                key={page.slug}
                href={`/learn/${getNodeSlugPath(page)}`}
                className="rounded-lg border border-slate-200 bg-white p-4 shadow-sm transition-colors hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-800 dark:hover:bg-slate-700"
              >
                <h3 className="font-medium">{page.title}</h3>
              </Link>
            ))}
          </div>
        </>
      )}
    </div>
  );
}

================
File: package.json
================
{
  "name": "usearabic",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "pages:build": "pnpm next-on-pages",
    "preview": "pnpm pages:build && wrangler pages dev",
    "deploy": "pnpm pages:build && wrangler pages deploy",
    "cf-typegen": "wrangler types --env-interface CloudflareEnv ./env.d.ts",
    "format": "prettier --write . --ignore-path .prettierignore"
  },
  "dependencies": {
    "@radix-ui/react-collapsible": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.13",
    "@radix-ui/react-dropdown-menu": "^2.1.14",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-separator": "^1.1.6",
    "@radix-ui/react-slot": "^1.2.2",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-tooltip": "^1.2.6",
    "@types/d3": "^7.4.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "d3": "^7.9.0",
    "gray-matter": "^4.0.3",
    "lucide-react": "^0.511.0",
    "next": "15.3.2",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "remark": "^15.0.1",
    "remark-html": "^16.0.1",
    "tailwind-merge": "^3.3.0",
    "tailwindcss-debug-screens": "^3.0.1"
  },
  "devDependencies": {
    "@cloudflare/next-on-pages": "1",
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^20.17.48",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "esbuild": "^0.25.4",
    "eslint": "^9",
    "eslint-config-next": "15.3.2",
    "prettier": "^3.5.3",
    "prettier-plugin-tailwindcss": "^0.6.11",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.0",
    "typescript": "^5",
    "vercel": "^41.7.8",
    "wrangler": "^4.15.2"
  }
}

================
File: src/app/page.tsx
================
import { redirect } from "next/navigation";
export default function Page() {
  redirect("/alnhw/slyman-alaywny/alnhw-alsghyr/");
}

================
File: src/app/layout.tsx
================
import { DevDebuggers } from '@/components/debug';
import { Sidebar } from '@/components/layout/sidebar';
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from '@/components/ui/sidebar';
import { isDev } from '@/config/env';
import { SITE_URL } from '@/config/site';
import { buildContentSummaryTree } from '@/lib/content/core/tree-builder';
import { cn } from '@/lib/styles/tailwind-utils';
import { ThemeProvider } from '@/providers/theme-provider';
import type { Metadata } from 'next';
import { ibmPlexSansArabic } from './fonts';
import './globals.css';
export const metadata: Metadata = {
  metadataBase: new URL(SITE_URL),
  title: {
    template: '%s | Documentation',
    default: 'Documentation',
  },
  description: 'Documentation site built with Next.js',
};
export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const summaryTree = await buildContentSummaryTree();
  return (
    <>
      <html
        dir="rtl"
        lang="ar"
        className={cn(ibmPlexSansArabic.variable)}
        suppressHydrationWarning
      >
        <body
          className={cn(
            'overflow-x-hidden overflow-y-scroll',
            'font-ibmPlexSansArabic antialiased',
            {
              'debug-screens': isDev,
            }
          )}
        >
          <ThemeProvider
            attribute="class"
            defaultTheme="light"
            enableSystem
            disableTransitionOnChange
          >
            <DevDebuggers summaryTree={summaryTree} />
            <SidebarProvider>
              <Sidebar summaryTree={summaryTree} />
              <SidebarInset className="px-4 py-6 md:px-8">
                <header className="mb-4 flex items-center">
                  <SidebarTrigger />
                </header>
                <main className="pb-16">{children}</main>
              </SidebarInset>
            </SidebarProvider>
          </ThemeProvider>
        </body>
      </html>
    </>
  );
}



================================================================
End of Codebase
================================================================
