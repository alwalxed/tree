This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
core/
  content-loader.ts
  landing-page-loader.ts
  tree-builder.ts
query/
  find-node.ts
  get-all-paths.ts
  get-breadcrumbs.ts
  get-leaf-nodes.ts
  get-node-path.ts
utils/
  path-utils.ts
  tree-utils.ts
api.ts
types.ts

================================================================
Files
================================================================

================
File: core/content-loader.ts
================
import fs from 'fs/promises';
import matter from 'gray-matter';
import path from 'path';
import { remark } from 'remark';
import html from 'remark-html';
import { normalizeTitle } from '../utils/path-utils';
export type PageSpecificContent = {
  pageTitle: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  frontmatter: Record<string, any>;
};
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
export async function loadPageSpecificContent(
  slugPath: string[]
): Promise<PageSpecificContent | null> {
  if (slugPath.length === 0) return null;
  const markdownFilePath = path.join(
    CONTENT_BASE_PATH,
    ...slugPath,
    'index.md'
  );
  try {
    const rawMarkdown = await fs.readFile(markdownFilePath, 'utf-8');
    const { data: frontmatter, content: markdownContent } = matter(rawMarkdown);
    const processedHtml = await remark().use(html).process(markdownContent);
    const currentDirSlug = slugPath.at(-1)!;
    const title = frontmatter.title ?? normalizeTitle(currentDirSlug);
    return {
      pageTitle: title,
      pageOrder: frontmatter.order,
      excerpt: frontmatter.excerpt,
      contentHtml: processedHtml.toString(),
      frontmatter,
    };
  } catch (e: unknown) {
    if (e instanceof Error) {
      console.error('Error message:', e.message);
    } else {
      console.error('Non-Error thrown:', e);
    }
    return null;
  }
}

================
File: core/landing-page-loader.ts
================
import fs from 'fs/promises';
import path from 'path';
import type {
  BookLandingPageConfigJson,
  ProcessedBookLandingPageConfig,
  ProcessedBookLandingSection,
  ProcessedTextLandingSection,
  ProcessedVisualizationLandingSection,
  SummaryNode,
} from '../types';
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
const LANDING_CONFIG_FILENAME = 'landing.json';
const LOG_PREFIX = '[LandingPageLoader]';
export async function loadBookLandingPageConfigForBuild(
  bookNodeLatinSlugPath: string[],
  bookChapters: SummaryNode[]
) {
  if (bookNodeLatinSlugPath.length === 0) {
    console.log(
      `${LOG_PREFIX} Received empty bookNodeLatinSlugPath. Skipping.`
    );
    return null;
  }
  const bookPathStringLatin = bookNodeLatinSlugPath.join('/');
  const landingConfigPath = path.join(
    CONTENT_BASE_PATH,
    ...bookNodeLatinSlugPath,
    LANDING_CONFIG_FILENAME
  );
  try {
    const fileContent = await fs.readFile(landingConfigPath, 'utf-8');
    const rawConfig = JSON.parse(fileContent) as BookLandingPageConfigJson;
    if (!rawConfig || !Array.isArray(rawConfig.sections)) {
      return null;
    }
    const processedSections: ProcessedBookLandingSection[] = [];
    for (const [, section] of rawConfig.sections.entries()) {
      if (section.type === 'text') {
        processedSections.push(section as ProcessedTextLandingSection);
      } else if (section.type === 'visualization') {
        const vizSectionJson =
          section as import('../types').VisualizationLandingSectionJson;
        const chapterIdentifier = vizSectionJson.chapterIdentifier;
        const identifiedChapterNode = bookChapters.find((chapter) => {
          return chapter.title.includes(chapterIdentifier);
        });
        if (identifiedChapterNode) {
          const nodesForViz = identifiedChapterNode.children || [];
          processedSections.push({
            type: 'visualization',
            title: vizSectionJson.title,
            nodes: nodesForViz,
          } as ProcessedVisualizationLandingSection);
        }
        const finalConfig: ProcessedBookLandingPageConfig = {
          sections: processedSections,
        };
        return finalConfig;
      }
    }
  } catch (error) {
    const err = error as NodeJS.ErrnoException;
    if (err.code === 'ENOENT') {
      console.log(
        `${LOG_PREFIX} Optional landing config file ${landingConfigPath} not found for book (Latin slug path: "${bookPathStringLatin}"). This is acceptable.`
      );
    } else if (error instanceof SyntaxError) {
      console.warn(
        `${LOG_PREFIX} Invalid JSON in ${landingConfigPath}: ${error.message}`
      );
    } else {
      console.error(
        `${LOG_PREFIX} Could not load or parse ${LANDING_CONFIG_FILENAME} for book (Latin slug path: ${bookPathStringLatin}). Path: ${landingConfigPath}. Error: ${err.message}`,
        err.stack
      );
    }
    return null;
  }
}

================
File: core/tree-builder.ts
================
import fs from 'fs';
import path from 'path';
import type { SummaryNode } from '../types';
import { normalizeTitle, parseDirectoryName } from '../utils/path-utils';
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
let fullSummaryTreeCache: SummaryNode[] | null = null;
const bookSpecificTreeCache = new Map<string, SummaryNode[]>();
function isPrefixMandatoryForDepth(absoluteDepth: number): boolean {
  return absoluteDepth >= 3;
}
async function scanContentDirectoryRecursive(
  currentActualDirPath: string,
  parentSlugPath: string[] = [],
  currentAbsoluteDepth: number = 0
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(currentActualDirPath, {
    withFileTypes: true,
  });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue;
    const fullActualEntryPath = path.join(currentActualDirPath, entry.name);
    if (entry.isDirectory()) {
      const { order: dirOrder, name: unprefixedDirName } = parseDirectoryName({
        directoryName: entry.name,
        isDirectoryPrefixMandatory:
          isPrefixMandatoryForDepth(currentAbsoluteDepth),
      });
      const slug = unprefixedDirName;
      const title = normalizeTitle(unprefixedDirName);
      const children = await scanContentDirectoryRecursive(
        fullActualEntryPath,
        [...parentSlugPath, slug],
        currentAbsoluteDepth + 1
      );
      items.push({
        title,
        slug,
        order: dirOrder,
        parentPath: parentSlugPath,
        children,
      });
    }
  }
  return items.sort((a, b) => {
    if (a.order !== b.order) {
      return a.order - b.order;
    }
    return a.title.localeCompare(b.title);
  });
}
export async function buildFullContentSummaryTree(): Promise<SummaryNode[]> {
  if (fullSummaryTreeCache) {
    console.log('[TreeBuilder] Returning cached full summary tree.');
    return fullSummaryTreeCache;
  }
  console.log('[TreeBuilder] Building full summary tree from scratch.');
  fullSummaryTreeCache = await scanContentDirectoryRecursive(CONTENT_BASE_PATH);
  return fullSummaryTreeCache;
}
export async function buildBookContentOnlyTree(
  bookSlugPath: string[]
): Promise<SummaryNode[]> {
  if (bookSlugPath.length !== 3) {
    console.error(
      '[TreeBuilder] buildBookContentOnlyTree expects a slug path of length 3 (subject/author/book). Received:',
      bookSlugPath
    );
    return [];
  }
  const cacheKey = bookSlugPath.join('/');
  if (bookSpecificTreeCache.has(cacheKey)) {
    console.log(
      `[TreeBuilder] Returning cached content tree for book: ${cacheKey}`
    );
    return bookSpecificTreeCache.get(cacheKey)!;
  }
  console.log(
    `[TreeBuilder] Building content tree specifically for book: ${cacheKey}`
  );
  const bookActualDirPath = path.join(CONTENT_BASE_PATH, ...bookSlugPath);
  try {
    await fs.promises.access(bookActualDirPath);
  } catch (e) {
    console.error(
      `[TreeBuilder] Book directory not found at: ${bookActualDirPath} (derived from Latin slug: ${cacheKey}) ${e}`
    );
    return [];
  }
  const bookContent = await scanContentDirectoryRecursive(
    bookActualDirPath,
    bookSlugPath
  );
  bookSpecificTreeCache.set(cacheKey, bookContent);
  return bookContent;
}
export function clearFullSummaryTreeCache(): void {
  console.log('[TreeBuilder] Clearing full summary tree cache.');
  fullSummaryTreeCache = null;
}
export function clearBookSpecificTreeCache(bookLatinSlugPath?: string[]): void {
  if (bookLatinSlugPath) {
    const cacheKey = bookLatinSlugPath.join('/');
    bookSpecificTreeCache.delete(cacheKey);
    console.log(`[TreeBuilder] Cleared cache for specific book: ${cacheKey}`);
  } else {
    bookSpecificTreeCache.clear();
    console.log('[TreeBuilder] Cleared all book-specific tree caches.');
  }
}

================
File: query/find-node.ts
================
import type { SummaryNode } from "../types";
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[],
): SummaryNode | null {
  let currentNodes: SummaryNode[] = tree;
  let foundNode: SummaryNode | null = null;
  for (const slug of slugPath) {
    const nextNode = currentNodes.find((node) => node.slug === slug);
    if (!nextNode) return null;
    foundNode = nextNode;
    currentNodes = nextNode.children;
  }
  return foundNode;
}

================
File: query/get-all-paths.ts
================
import { buildFullContentSummaryTree } from "../core/tree-builder";
import type { SummaryNode } from "../types";
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildFullContentSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, currentPath: string[] = []) {
    const newPath = [...currentPath, node.slug];
    slugs.push(newPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, newPath));
    }
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: query/get-breadcrumbs.ts
================
import type { SummaryNode } from "../types";
import { findDeepestNode } from "./find-node";
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[],
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  if (node.parentPath.length === 0) {
    return breadcrumbs;
  }
  let currentParentPath = node.parentPath;
  while (currentParentPath.length > 0) {
    const parentNode = findDeepestNode(tree, currentParentPath);
    if (parentNode) {
      breadcrumbs.unshift({ title: parentNode.title, slug: parentNode.slug });
    }
    currentParentPath = currentParentPath.slice(0, -1);
  }
  return breadcrumbs;
}

================
File: query/get-leaf-nodes.ts
================
import type { LeafNodeInfo, SummaryNode } from "../types";
export function getLeafNodes(tree: SummaryNode[]): LeafNodeInfo[] {
  const leaves: LeafNodeInfo[] = [];
  function walk(node: SummaryNode, currentPath: string[] = []) {
    const fullPathSegments = [...currentPath, node.slug];
    if (node.children.length === 0) {
      leaves.push({
        title: node.title,
        fullSlugPath: fullPathSegments.join("/"),
      });
    } else {
      node.children.forEach((child) => walk(child, fullPathSegments));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: query/get-node-path.ts
================
import type { SummaryNode } from "../types";
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join("/");
}

================
File: utils/path-utils.ts
================
import { convertNumerals } from '@/lib/common/convert-numerals';
export type ParsedNameInfo = {
  order: number;
  name: string;
  isPrefixed: boolean;
};
const DEFAULT_ORDER = 0;
export function parseDirectoryName({
  directoryName,
  isDirectoryPrefixMandatory,
}: {
  directoryName: string;
  isDirectoryPrefixMandatory: boolean;
}): ParsedNameInfo {
  if (/\.[a-z0-9]+$/i.test(directoryName)) {
    throw new Error(
      `Directory name "${directoryName}" must not contain a file extension.`
    );
  }
  const match = directoryName.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (match) {
    const [, numericPrefix, remainder] = match;
    const order = parseInt(
      convertNumerals({ value: numericPrefix, direction: 'ar-to-en' }),
      10
    );
    if (isNaN(order)) {
      throw new Error(
        `Invalid numeric prefix in directory name: "${directoryName}". Could not parse "${numericPrefix}" to a number.`
      );
    }
    return {
      order,
      name: remainder,
      isPrefixed: true,
    };
  }
  if (isDirectoryPrefixMandatory) {
    throw new Error(
      `Invalid directory name format: "${directoryName}". Expected format: <number>_<name> as prefix is mandatory at this level.`
    );
  }
  return {
    order: DEFAULT_ORDER,
    name: directoryName,
    isPrefixed: false,
  };
}
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, '');
  return arabicOnly.replace(/_+/g, ' ');
}

================
File: utils/tree-utils.ts
================
import type { SummaryNode } from "../types";
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  currentPath: string[] = [],
  level: number = 0,
): void {
  for (const node of nodes) {
    callback(node, currentPath, level);
    if (node.children && node.children.length > 0) {
      walkTree(node.children, callback, [...currentPath, node.slug], level + 1);
    }
  }
}
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: api.ts
================
import { loadPageSpecificContent } from "./core/content-loader";
import { loadBookLandingPageConfigForBuild } from "./core/landing-page-loader";
import {
  buildFullContentSummaryTree,
  clearBookSpecificTreeCache,
  clearFullSummaryTreeCache,
} from "./core/tree-builder";
import { findDeepestNode } from "./query/find-node";
import type { ContentNode, SummaryNode } from "./types";
export { getTreeSlugs as getAllContentPaths } from "./query/get-all-paths";
export { getBreadcrumbs } from "./query/get-breadcrumbs";
export { getLeafNodes } from "./query/get-leaf-nodes";
export { getNodeSlugPath } from "./query/get-node-path";
export { flattenTree, walkTree } from "./utils/tree-utils";
const BOOK_DEPTH = 2; // 0:subject, 1:author, 2:book
export async function getFullSummaryTree(): Promise<SummaryNode[]> {
  return buildFullContentSummaryTree();
}
export async function getContentNodeBySlugPath(
  slugPath: string[],
): Promise<ContentNode | null> {
  const fullTree = await getFullSummaryTree();
  const summaryNode = findDeepestNode(fullTree, slugPath);
  if (!summaryNode) {
    console.warn(
      `[API] getContentNodeBySlugPath: Node not found for slugPath: ${slugPath.join("/")}`,
    );
    return null;
  }
  const pageContent = await loadPageSpecificContent(slugPath);
  const contentNode: ContentNode = {
    ...summaryNode,
  };
  if (pageContent) {
    contentNode.pageTitle = pageContent.pageTitle;
    contentNode.pageOrder = pageContent.pageOrder;
    contentNode.excerpt = pageContent.excerpt;
    contentNode.contentHtml = pageContent.contentHtml;
    contentNode.frontmatter = pageContent.frontmatter;
  }
  const nodeDepth = summaryNode.parentPath.length;
  if (nodeDepth === BOOK_DEPTH) {
    const landingConfig = await loadBookLandingPageConfigForBuild(
      slugPath,
      summaryNode.children,
    );
    if (landingConfig) {
      contentNode.landingPageConfig = landingConfig;
    }
  }
  return contentNode;
}
export function clearAllSummaryCaches(): void {
  console.log("[API] Clearing all summary caches.");
  clearFullSummaryTreeCache();
  clearBookSpecificTreeCache();
}
export function clearSpecificBookCache(bookLatinSlugPath: string[]): void {
  if (bookLatinSlugPath && bookLatinSlugPath.length === 3) {
    console.log(
      `[API] Clearing cache for specific book: ${bookLatinSlugPath.join("/")}`,
    );
    clearBookSpecificTreeCache(bookLatinSlugPath);
  } else {
    console.warn(
      "[API] clearSpecificBookCache: Invalid or missing bookLatinSlugPath provided.",
    );
  }
}

================
File: types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type LeafNodeInfo = {
  title: string;
  fullSlugPath: string;
};
type BookLandingSectionBaseJson = {
  title: string;
};
export type TextLandingSectionJson = BookLandingSectionBaseJson & {
  type: 'text';
  content: string[];
};
export type VisualizationLandingSectionJson = BookLandingSectionBaseJson & {
  type: 'visualization';
  chapterIdentifier: string;
};
export type BookLandingSectionJson =
  | TextLandingSectionJson
  | VisualizationLandingSectionJson;
export type BookLandingPageConfigJson = {
  sections: BookLandingSectionJson[];
};
export type ProcessedTextLandingSection = BookLandingSectionBaseJson & {
  type: 'text';
  content: string[];
};
export type ProcessedVisualizationLandingSection =
  BookLandingSectionBaseJson & {
    type: 'visualization';
    nodes: SummaryNode[];
  };
export type ProcessedBookLandingSection =
  | ProcessedTextLandingSection
  | ProcessedVisualizationLandingSection;
export type ProcessedBookLandingPageConfig = {
  sections: ProcessedBookLandingSection[];
};
export type ContentNode = SummaryNode & {
  pageTitle?: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  frontmatter?: Record<string, any>;
  landingPageConfig?: ProcessedBookLandingPageConfig;
};



================================================================
End of Codebase
================================================================
