This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
content/
  core/
    content-loader.ts
    landing-page-loader.ts
    tree-builder.ts
  query/
    find-node.ts
    get-all-paths.ts
    get-breadcrumbs.ts
    get-leaf-nodes.ts
    get-node-path.ts
  utils/
    path-utils.ts
    tree-utils.ts
  api.ts
  types.ts
styles/
  tailwind-utils.ts
text/
  ascii-tree-generator.ts
  transliteration.ts

================================================================
Files
================================================================

================
File: content/core/content-loader.ts
================
import fs from "fs/promises";
import matter from "gray-matter";
import path from "path";
import { remark } from "remark";
import html from "remark-html";
import { normalizeTitle } from "../utils/path-utils";
export interface PageSpecificContent {
  pageTitle: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml: string;
  frontmatter: Record<string, any>;
}
const CONTENT_BASE_PATH = path.join(process.cwd(), "content");
export async function loadPageSpecificContent(
  slugPath: string[],
): Promise<PageSpecificContent | null> {
  if (slugPath.length === 0) return null;
  const markdownFilePath = path.join(
    CONTENT_BASE_PATH,
    ...slugPath,
    "index.md",
  );
  try {
    const rawMarkdown = await fs.readFile(markdownFilePath, "utf-8");
    const { data: frontmatter, content: markdownContent } = matter(rawMarkdown);
    const processedHtml = await remark().use(html).process(markdownContent);
    const currentDirSlug = slugPath.at(-1)!;
    const title = frontmatter.title ?? normalizeTitle(currentDirSlug);
    return {
      pageTitle: title,
      pageOrder: frontmatter.order,
      excerpt: frontmatter.excerpt,
      contentHtml: processedHtml.toString(),
      frontmatter,
    };
  } catch (error) {
    return null;
  }
}

================
File: content/core/landing-page-loader.ts
================
import fs from "fs/promises";
import path from "path";
import type {
  BookLandingPageConfigJson,
  ProcessedBookLandingPageConfig,
  ProcessedBookLandingSection,
  ProcessedTextLandingSection,
  ProcessedVisualizationLandingSection,
  SummaryNode,
  VisualizationLandingSectionJson,
} from "../types";
const CONTENT_BASE_PATH = path.join(process.cwd(), "content");
const LANDING_CONFIG_FILENAME = "landing.json";
export async function loadBookLandingPageConfigForBuild(
  bookNodeSlugPath: string[],
  bookChapters: SummaryNode[],
): Promise<ProcessedBookLandingPageConfig | null> {
  if (bookNodeSlugPath.length === 0) {
    return null;
  }
  const landingConfigPath = path.join(
    CONTENT_BASE_PATH,
    ...bookNodeSlugPath,
    LANDING_CONFIG_FILENAME,
  );
  try {
    const fileContent = await fs.readFile(landingConfigPath, "utf-8");
    const rawConfig = JSON.parse(fileContent) as BookLandingPageConfigJson;
    if (!rawConfig || !Array.isArray(rawConfig.sections)) {
      console.warn(
        `Invalid structure in ${landingConfigPath}. 'sections' array is missing.`,
      );
      return null;
    }
    const processedSections: ProcessedBookLandingSection[] = [];
    for (const section of rawConfig.sections) {
      if (section.type === "text") {
        processedSections.push(section as ProcessedTextLandingSection);
      } else if (section.type === "visualization") {
        const vizSectionJson = section as VisualizationLandingSectionJson;
        const chapterIdentifier = vizSectionJson.chapterIdentifier;
        const identifiedChapterNode = bookChapters.find((chapter) =>
          chapter.title.includes(chapterIdentifier),
        );
        if (identifiedChapterNode) {
          processedSections.push({
            type: "visualization",
            title: vizSectionJson.title,
            nodes: identifiedChapterNode.children || [],
          } as ProcessedVisualizationLandingSection);
        } else {
          console.warn(
            `Could not find chapter with identifier "${chapterIdentifier}" for visualization section "${vizSectionJson.title}" in book ${bookNodeSlugPath.join("/")}. This section will be skipped.`,
          );
        }
      } else {
        console.warn(
          `Unknown section type "${(section as any).type}" in ${landingConfigPath}. Section skipped.`,
        );
      }
    }
    return {
      sections: processedSections,
    };
  } catch (error) {
    const err = error as NodeJS.ErrnoException;
    if (err.code === "ENOENT") {
    } else if (error instanceof SyntaxError) {
      console.warn(`Invalid JSON in ${landingConfigPath}: ${error.message}`);
    } else {
      console.warn(
        `Could not load or parse ${LANDING_CONFIG_FILENAME} for book at ${bookNodeSlugPath.join("/")}. Path: ${landingConfigPath}. Error: ${err.message}`,
      );
    }
    return null;
  }
}

================
File: content/core/tree-builder.ts
================
import fs from 'fs';
import path from 'path';
import type { SummaryNode } from '../types';
import {
  normalizeSlug,
  normalizeTitle,
  parseDirectoryName,
} from '../utils/path-utils';
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
let summaryTreeCache: SummaryNode[] | null = null;
function isPrefixMandatoryForDepth(depth: number): boolean {
  return depth >= 3;
}
async function scanContentDirectory(
  currentDirPath: string,
  parentSlugPath: string[] = [],
  currentDepth: number = 0
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(currentDirPath, {
    withFileTypes: true,
  });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue;
    const fullEntryPath = path.join(currentDirPath, entry.name);
    if (entry.isDirectory()) {
      const { order: dirOrder, name: unprefixedDirName } = parseDirectoryName({
        directoryName: entry.name,
        isDirectoryPrefixMandatory: isPrefixMandatoryForDepth(currentDepth),
      });
      const slug = normalizeSlug(unprefixedDirName);
      const title = normalizeTitle(unprefixedDirName);
      const children = await scanContentDirectory(
        fullEntryPath,
        [...parentSlugPath, slug],
        currentDepth + 1
      );
      items.push({
        title,
        slug,
        order: dirOrder,
        parentPath: parentSlugPath,
        children,
      });
    }
  }
  return items.sort((a, b) => {
    if (a.order !== b.order) {
      return a.order - b.order;
    }
    return a.title.localeCompare(b.title);
  });
}
export async function buildContentSummaryTree(): Promise<SummaryNode[]> {
  if (summaryTreeCache) return summaryTreeCache;
  summaryTreeCache = await scanContentDirectory(CONTENT_BASE_PATH);
  return summaryTreeCache;
}
export function clearSummaryTreeCache(): void {
  summaryTreeCache = null;
}

================
File: content/query/find-node.ts
================
import type { SummaryNode } from '../types';
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[]
): SummaryNode | null {
  let currentNodes: SummaryNode[] = tree;
  let foundNode: SummaryNode | null = null;
  for (const slug of slugPath) {
    const nextNode = currentNodes.find((node) => node.slug === slug);
    if (!nextNode) return null;
    foundNode = nextNode;
    currentNodes = nextNode.children;
  }
  return foundNode;
}

================
File: content/query/get-all-paths.ts
================
import { buildContentSummaryTree } from '../core/tree-builder';
import type { SummaryNode } from '../types';
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildContentSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, currentPath: string[] = []) {
    const newPath = [...currentPath, node.slug];
    slugs.push(newPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, newPath));
    }
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: content/query/get-breadcrumbs.ts
================
import type { SummaryNode } from '../types';
import { findDeepestNode } from './find-node';
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[]
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  if (node.parentPath.length === 0) {
    return breadcrumbs;
  }
  let currentParentPath = node.parentPath;
  while (currentParentPath.length > 0) {
    const parentNode = findDeepestNode(tree, currentParentPath);
    if (parentNode) {
      breadcrumbs.unshift({ title: parentNode.title, slug: parentNode.slug });
    }
    currentParentPath = currentParentPath.slice(0, -1);
  }
  return breadcrumbs;
}

================
File: content/query/get-leaf-nodes.ts
================
import type { LeafNodeInfo, SummaryNode } from '../types';
export function getLeafNodes(tree: SummaryNode[]): LeafNodeInfo[] {
  const leaves: LeafNodeInfo[] = [];
  function walk(node: SummaryNode, currentPath: string[] = []) {
    const fullPathSegments = [...currentPath, node.slug];
    if (node.children.length === 0) {
      leaves.push({
        title: node.title,
        fullSlugPath: fullPathSegments.join('/'),
      });
    } else {
      node.children.forEach((child) => walk(child, fullPathSegments));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: content/query/get-node-path.ts
================
import type { SummaryNode } from '../types';
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join('/');
}

================
File: content/utils/path-utils.ts
================
import { transliterate } from '../../text/transliteration';
export interface ParsedNameInfo {
  order: number;
  name: string;
  isPrefixed: boolean;
}
const DEFAULT_ORDER = 0;
export function parseDirectoryName({
  directoryName,
  isDirectoryPrefixMandatory,
}: {
  directoryName: string;
  isDirectoryPrefixMandatory: boolean;
}): ParsedNameInfo {
  if (/\.[a-z0-9]+$/i.test(directoryName)) {
    throw new Error(
      `Directory name "${directoryName}" must not contain a file extension.`
    );
  }
  const match = directoryName.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (match) {
    const [, numericPrefix, remainder] = match;
    const order = parseInt(
      transliterate({ input: numericPrefix, mode: 'arabic-to-latin' }),
      10
    );
    if (isNaN(order)) {
      throw new Error(
        `Invalid numeric prefix in directory name: "${directoryName}". Could not parse "${numericPrefix}" to a number.`
      );
    }
    return {
      order,
      name: remainder,
      isPrefixed: true,
    };
  }
  if (isDirectoryPrefixMandatory) {
    throw new Error(
      `Invalid directory name format: "${directoryName}". Expected format: <number>_<name> as prefix is mandatory at this level.`
    );
  }
  return {
    order: DEFAULT_ORDER,
    name: directoryName,
    isPrefixed: false,
  };
}
export function normalizeSlug(raw: string): string {
  const base = raw.replace(/\.md$/, '');
  const arabicOnly = base.replace(/[^\u0600-\u06FF_]/g, '');
  return transliterate({
    input: arabicOnly,
    mode: 'arabic-to-latin',
  }).replace(/_+/g, '-');
}
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, '');
  return arabicOnly.replace(/_+/g, ' ');
}

================
File: content/utils/tree-utils.ts
================
import type { SummaryNode } from '../types';
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  currentPath: string[] = [],
  level: number = 0
): void {
  for (const node of nodes) {
    callback(node, currentPath, level);
    if (node.children && node.children.length > 0) {
      walkTree(node.children, callback, [...currentPath, node.slug], level + 1);
    }
  }
}
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: content/api.ts
================
import { loadPageSpecificContent } from "./core/content-loader";
import { loadBookLandingPageConfigForBuild } from "./core/landing-page-loader";
import {
  buildContentSummaryTree,
  clearSummaryTreeCache as clearInternalSummaryTreeCache,
} from "./core/tree-builder";
import { findDeepestNode } from "./query/find-node";
import type { ContentNode, SummaryNode } from "./types";
export { getTreeSlugs as getAllContentPaths } from "./query/get-all-paths";
export { getBreadcrumbs } from "./query/get-breadcrumbs";
export { getLeafNodes } from "./query/get-leaf-nodes";
export { getNodeSlugPath } from "./query/get-node-path";
export { flattenTree, walkTree } from "./utils/tree-utils";
const BOOK_DEPTH = 2;
export async function getSummaryTree(): Promise<SummaryNode[]> {
  return buildContentSummaryTree();
}
export async function getContentNodeBySlugPath(
  slugPath: string[],
): Promise<ContentNode | null> {
  const tree = await getSummaryTree();
  const summaryNode = findDeepestNode(tree, slugPath);
  if (!summaryNode) {
    return null;
  }
  const pageContent = await loadPageSpecificContent(slugPath);
  const contentNode: ContentNode = {
    ...summaryNode,
  };
  if (pageContent) {
    contentNode.pageTitle = pageContent.pageTitle;
    contentNode.pageOrder = pageContent.pageOrder;
    contentNode.excerpt = pageContent.excerpt;
    contentNode.contentHtml = pageContent.contentHtml;
    contentNode.frontmatter = pageContent.frontmatter;
  }
  const nodeDepth = summaryNode.parentPath.length;
  if (nodeDepth === BOOK_DEPTH) {
    const landingConfig = await loadBookLandingPageConfigForBuild(
      slugPath,
      summaryNode.children,
    );
    if (landingConfig) {
      contentNode.landingPageConfig = landingConfig;
    }
  }
  return contentNode;
}
export function clearSummaryCache(): void {
  clearInternalSummaryTreeCache();
}

================
File: content/types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type LeafNodeInfo = {
  title: string;
  fullSlugPath: string;
};
interface BookLandingSectionBaseJson {
  title: string;
}
export interface TextLandingSectionJson extends BookLandingSectionBaseJson {
  type: "text";
  content: string[];
}
export interface VisualizationLandingSectionJson
  extends BookLandingSectionBaseJson {
  type: "visualization";
  chapterIdentifier: string;
}
export type BookLandingSectionJson =
  | TextLandingSectionJson
  | VisualizationLandingSectionJson;
export interface BookLandingPageConfigJson {
  sections: BookLandingSectionJson[];
}
export interface ProcessedTextLandingSection
  extends BookLandingSectionBaseJson {
  type: "text";
  content: string[];
}
export interface ProcessedVisualizationLandingSection
  extends BookLandingSectionBaseJson {
  type: "visualization";
  nodes: SummaryNode[];
}
export type ProcessedBookLandingSection =
  | ProcessedTextLandingSection
  | ProcessedVisualizationLandingSection;
export interface ProcessedBookLandingPageConfig {
  sections: ProcessedBookLandingSection[];
}
export type ContentNode = SummaryNode & {
  pageTitle?: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml?: string;
  frontmatter?: Record<string, any>;
  landingPageConfig?: ProcessedBookLandingPageConfig;
};

================
File: styles/tailwind-utils.ts
================
import clsx, { type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

================
File: text/ascii-tree-generator.ts
================
import type { SummaryNode } from '../content/types';
export function generateASCIITree(
  docs: SummaryNode[],
  options: {
    indent?: string;
    splitLevel?: number;
    splitString?: string;
    currentLevel?: number;
  } = {}
): string {
  const {
    indent = '',
    splitLevel = Infinity,
    splitString = '',
    currentLevel = 0,
  } = options;
  return docs
    .map((node, index) => {
      const isLast = index === docs.length - 1;
      const branch = isLast ? '└── ' : '├── ';
      const nextIndent = indent + (isLast ? '    ' : '│   ');
      const label = node.title.replace(/_/g, ' ');
      let output = '';
      if (currentLevel === splitLevel && label !== splitString) {
        return '';
      }
      output += `${indent}${branch}${label}\n`;
      if (node.children.length > 0) {
        output += generateASCIITree(node.children, {
          indent: nextIndent,
          splitLevel,
          splitString,
          currentLevel: currentLevel + 1,
        });
      }
      return output;
    })
    .join('');
}

================
File: text/transliteration.ts
================
type ArabicToLatinOptions = {
  mode: "arabic-to-latin";
  input: string;
};
type LatinToArabicDigitsOptions = {
  mode: "latin-to-arabic-digits";
  input: string;
};
type LatinNumbersToArabicDigitsOptions = {
  mode: "latin-numbers-to-arabic-digits";
  input: string | number;
};
type LatinToArabicOptions = {
  mode: "latin-to-arabic";
  input: string;
};
type Options =
  | ArabicToLatinOptions
  | LatinToArabicDigitsOptions
  | LatinNumbersToArabicDigitsOptions
  | LatinToArabicOptions;
const LATIN_TO_ARABIC_DIGITS: Record<string, string> = {
  "0": "٠",
  "1": "١",
  "2": "٢",
  "3": "٣",
  "4": "٤",
  "5": "٥",
  "6": "٦",
  "7": "٧",
  "8": "٨",
  "9": "٩",
};
const ARABIC_TO_LATIN_DIGITS: Record<string, string> = Object.fromEntries(
  Object.entries(LATIN_TO_ARABIC_DIGITS).map(([w, a]) => [a, w]),
);
const digitSet = new Set(Object.keys(LATIN_TO_ARABIC_DIGITS));
const ARABIC_TO_LATIN_LETTERS: Record<string, string> = {
  ا: "a",
  ب: "b",
  ت: "t",
  ث: "th",
  ج: "j",
  ح: "h",
  خ: "kh",
  د: "d",
  ذ: "dh",
  ر: "r",
  ز: "z",
  س: "s",
  ش: "sh",
  ص: "s",
  ض: "d",
  ط: "t",
  ظ: "z",
  ع: "a",
  غ: "gh",
  ف: "f",
  ق: "q",
  ك: "k",
  ل: "l",
  م: "m",
  ن: "n",
  ه: "h",
  و: "w",
  ي: "y",
  ء: "",
  ى: "a",
  ئ: "y",
  ؤ: "w",
  ة: "h",
  إ: "i",
  أ: "a",
  آ: "aa",
  "ٓ": "",
  "َ": "a",
  "ُ": "u",
  "ِ": "i",
  "ّ": "",
  "ْ": "",
  "ً": "an",
  "ٌ": "un",
  "ٍ": "in",
};
const ARABIC_TO_LATIN_MAP = {
  ...ARABIC_TO_LATIN_LETTERS,
  ...ARABIC_TO_LATIN_DIGITS,
};
const LATIN_TO_ARABIC_LETTERS: Record<string, string> = {
  al: "ال",
  aa: "آ",
  th: "ث",
  kh: "خ",
  dh: "ذ",
  sh: "ش",
  gh: "غ",
  sgh: "صغ",
  ay: "عي",
  a: "ا",
  b: "ب",
  t: "ت",
  j: "ج",
  h: "ح",
  d: "د",
  r: "ر",
  z: "ز",
  s: "س",
  f: "ف",
  q: "ق",
  k: "ك",
  l: "ل",
  m: "م",
  n: "ن",
  w: "و",
  y: "ي",
  i: "إ",
};
const LATIN_LETTER_KEYS = Object.keys(LATIN_TO_ARABIC_LETTERS).sort(
  (a, b) => b.length - a.length,
);
export function transliterate(options: Options): string {
  const { mode } = options;
  const inputStr = options.input.toString();
  switch (mode) {
    case "arabic-to-latin":
      return [...inputStr].map((ch) => ARABIC_TO_LATIN_MAP[ch] ?? ch).join("");
    case "latin-to-arabic-digits":
      return inputStr.replace(/[0-9]/g, (d) => LATIN_TO_ARABIC_DIGITS[d]);
    case "latin-numbers-to-arabic-digits":
      if (!/^\d+$/.test(inputStr)) {
        throw new Error(
          "Mode 'latin-numbers-to-arabic-digits' requires digits only.",
        );
      }
      return [...inputStr].map((d) => LATIN_TO_ARABIC_DIGITS[d]).join("");
    case "latin-to-arabic":
      return transliterateLatinToArabic(inputStr);
    default:
      const _exhaustive: never = mode;
      throw new Error(`Unsupported mode: ${_exhaustive}`);
  }
}
function transliterateLatinToArabic(s: string): string {
  let result = "";
  let i = 0;
  const N = s.length;
  const lower = s.toLowerCase();
  while (i < N) {
    let matched = false;
    for (const key of LATIN_LETTER_KEYS) {
      if (lower.startsWith(key, i)) {
        result += LATIN_TO_ARABIC_LETTERS[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const ch = s[i];
    if (digitSet.has(ch)) {
      result += LATIN_TO_ARABIC_DIGITS[ch];
    } else if (ch === "-") {
      result += "_";
    } else {
      result += ch;
    }
    i++;
  }
  return result;
}



================================================================
End of Codebase
================================================================
