This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
app/
  [subjectSlug]/
    [authorSlug]/
      [bookSlug]/
        [...slug]/
          page.tsx
        page.tsx
  fonts.ts
  globals.css
  layout.tsx
  not-found.tsx
  page.tsx
components/
  common/
    markdown-renderer.tsx
    section.tsx
    theme-mode-toggle.tsx
  debug/
    index.tsx
    tree-structure.hook.ts
    tree-structure.view.tsx
  layout/
    sidebar.tsx
  ui/
    badge.tsx
    button.tsx
    collapsible.tsx
    custom-dialog.tsx
    dialog.tsx
    dropdown-menu.tsx
    input.tsx
    scroll-area.tsx
    separator.tsx
    sheet.tsx
    sidebar.tsx
    skeleton.tsx
    table.tsx
    tabs.tsx
    tooltip.tsx
  visualizations/
    renderers/
      radial/
        radial-sunburst-renderer.tsx
      spatial/
        circle-pack-renderer.tsx
        grid-layout-renderer.tsx
        nested-boxes-renderer.tsx
      tree/
        ascii-tree-renderer.tsx
        collapsible-tree-renderer.tsx
        node-link-diagram-renderer.tsx
    visualization-switcher.tsx
config/
  env.ts
  site.ts
constants/
  arabic-to-english-map.ts
hooks/
  use-mobile.ts
  use-sidebar.tsx
lib/
  content/
    core/
      content-loader.ts
      landing-page-loader.ts
      tree-builder.ts
    query/
      find-node.ts
      get-all-paths.ts
      get-breadcrumbs.ts
      get-leaf-nodes.ts
      get-node-path.ts
    utils/
      path-utils.ts
      tree-utils.ts
    api.ts
    types.ts
  styles/
    tailwind-utils.ts
  text/
    ascii-tree-generator.ts
    transliteration.ts
  output.txt
providers/
  theme-provider.tsx

================================================================
Files
================================================================

================
File: app/[subjectSlug]/[authorSlug]/[bookSlug]/[...slug]/page.tsx
================
import { MarkdownRenderer } from '@/components/common/markdown-renderer';
import { getContentNodeBySlugPath } from '@/lib/content/api';
import { getTreeSlugs } from '@/lib/content/query/get-all-paths';
import type { Metadata, ResolvingMetadata } from 'next';
import { notFound } from 'next/navigation';
type Props = {
  params: Promise<{ slug: string[] }>;
};
export async function generateStaticParams() {
  const slugs = await getTreeSlugs();
  return slugs.map((slugParts) => ({
    slug: slugParts,
  }));
}
export async function generateMetadata(
  { params }: Props,
  parent: ResolvingMetadata
): Promise<Metadata> {
  const resolvedParams = await params;
  const slugPath = resolvedParams.slug;
  const markdown = await getContentNodeBySlugPath(slugPath);
  if (!markdown) {
    return {
      title: 'Not Found',
      description: 'The requested documentation page could not be found.',
    };
  }
  const previousImages = (await parent).openGraph?.images || [];
  const description =
    markdown.excerpt ||
    (markdown.contentHtml
      ? markdown.contentHtml
          .replace(/<[^>]*>/g, '')
          .slice(0, 160)
          .trim() + '...'
      : '');
  const canonicalSlug = slugPath.join('/');
  return {
    title: markdown.title,
    description,
    openGraph: {
      title: markdown.title,
      description,
      type: 'article',
      url: `/learn/${canonicalSlug}`,
      images: previousImages,
    },
    twitter: {
      card: 'summary_large_image',
      title: markdown.title,
      description,
      images: previousImages,
    },
    alternates: {
      canonical: `/learn/${canonicalSlug}`,
    },
  };
}
export default async function Page({ params }: Props) {
  const resolvedParams = await params;
  const slugPath = resolvedParams.slug;
  const markdown = await getContentNodeBySlugPath(slugPath);
  if (!markdown) {
    notFound();
  }
  return (
    <article className="prose prose-slate dark:prose-invert max-w-none">
      <h1>{markdown.title}</h1>
      {markdown.contentHtml ? (
        <MarkdownRenderer content={markdown.contentHtml} />
      ) : (
        <p className="text-muted">No content available for this section.</p>
      )}
    </article>
  );
}

================
File: app/[subjectSlug]/[authorSlug]/[bookSlug]/page.tsx
================
import { Section } from "@/components/common/section";
import { VisualizationSwitcher } from "@/components/visualizations/visualization-switcher";
import { getContentNodeBySlugPath } from "@/lib/content/api";
import type {
  TextLandingSection,
  VisualizationLandingSection,
} from "@/lib/content/types";
import { notFound } from "next/navigation";
interface PageProps {
  params: {
    subjectSlug: string;
    authorSlug: string;
    bookSlug: string;
  };
}
export default async function BookLandingPage({ params }: PageProps) {
  const { subjectSlug, authorSlug, bookSlug } = params;
  const slugPath = [subjectSlug, authorSlug, bookSlug];
  const bookNode = await getContentNodeBySlugPath(slugPath);
  if (!bookNode) {
    return notFound();
  }
  if (!bookNode.landingPageConfig) {
    return (
      <div className="mx-auto flex max-w-4xl flex-col gap-12 p-6">
        <Section>
          <Section.H level={1}>{bookNode.title}</Section.H>
          <Section.P>
            This book does not have a custom landing page configuration.
          </Section.P>
          {bookNode.children.length > 0 && (
            <div className="mt-6">
              <Section.H level={3}>Chapters:</Section.H>
              <ul>
                {bookNode.children.map((child) => (
                  <li key={child.slug}>
                    <a
                      href={`/${slugPath.join("/")}/${child.slug}`}
                      className="text-blue-600 hover:underline"
                    >
                      {child.title}
                    </a>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </Section>
      </div>
    );
  }
  const { landingPageConfig } = bookNode;
  return (
    <div className="mx-auto flex max-w-4xl flex-col gap-12 p-6">
      <Section>
        <Section.H level={1}>{bookNode.title}</Section.H>
      </Section>
      {landingPageConfig.sections.map((section, index) => (
        <Section key={`${section.type}-${index}`}>
          <Section.H level={2}>{section.title}</Section.H>
          {section.type === "text" && (
            <div>
              {(section as TextLandingSection).content.map(
                (paragraph, pIndex) => (
                  <Section.P key={pIndex}>{paragraph}</Section.P>
                ),
              )}
            </div>
          )}
          {section.type === "visualization" && (
            <VisualizationSwitcher
              nodes={(section as VisualizationLandingSection).nodes}
            />
          )}
        </Section>
      ))}
    </div>
  );
}

================
File: app/fonts.ts
================
import localFont from 'next/font/local';
export const ibmPlexSansArabic = localFont({
  src: [
    {
      path: '../../public/fonts/IBMPlexSansArabic-Regular-400.ttf',
      weight: '400',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-Medium-500.ttf',
      weight: '500',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-SemiBold-600.ttf',
      weight: '600',
      style: 'normal',
    },
    {
      path: '../../public/fonts/IBMPlexSansArabic-Bold-700.ttf',
      weight: '700',
      style: 'normal',
    },
  ],
  variable: '--font-ibmPlexSansArabic',
  display: 'swap',
  preload: true,
});

================
File: app/globals.css
================
@import 'tailwindcss';
@import 'tw-animate-css';
@plugin "@tailwindcss/typography";
@plugin "tailwindcss-debug-screens" {
  classname: 'debug-screens';
  position: 'bottom, right';
  prefix: 'screen: ';
}
@custom-variant dark (&:is(.dark *));
@theme {
  --font-ibmPlexSansArabic: var(--font-ibmPlexSansArabic);
}
@theme {
  --breakpoint-*: initial;
  --breakpoint-xxs: 20rem;
  --breakpoint-xs: 30rem;
  --breakpoint-sm: 40rem;
  --breakpoint-md: 48rem;
  --breakpoint-lg: 64rem;
  --breakpoint-xl: 80rem;
  --breakpoint-2xl: 96rem;
  --breakpoint-3xl: 112rem;
  --breakpoint-4xl: 128rem;
}
@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}
:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.141 0.005 285.823);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.141 0.005 285.823);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.141 0.005 285.823);
  --primary: oklch(0.21 0.006 285.885);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.967 0.001 286.375);
  --secondary-foreground: oklch(0.21 0.006 285.885);
  --muted: oklch(0.967 0.001 286.375);
  --muted-foreground: oklch(0.552 0.016 285.938);
  --accent: oklch(0.967 0.001 286.375);
  --accent-foreground: oklch(0.21 0.006 285.885);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.92 0.004 286.32);
  --input: oklch(0.92 0.004 286.32);
  --ring: oklch(0.705 0.015 286.067);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.141 0.005 285.823);
  --sidebar-primary: oklch(0.21 0.006 285.885);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.967 0.001 286.375);
  --sidebar-accent-foreground: oklch(0.21 0.006 285.885);
  --sidebar-border: oklch(0.92 0.004 286.32);
  --sidebar-ring: oklch(0.705 0.015 286.067);
}
.dark {
  --background: oklch(0.141 0.005 285.823);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.21 0.006 285.885);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.21 0.006 285.885);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.92 0.004 286.32);
  --primary-foreground: oklch(0.21 0.006 285.885);
  --secondary: oklch(0.274 0.006 286.033);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.274 0.006 286.033);
  --muted-foreground: oklch(0.705 0.015 286.067);
  --accent: oklch(0.274 0.006 286.033);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.552 0.016 285.938);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.21 0.006 285.885);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.274 0.006 286.033);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.552 0.016 285.938);
}
@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/layout.tsx
================
import { DevDebuggers } from '@/components/debug';
import { Sidebar } from '@/components/layout/sidebar';
import {
  SidebarInset,
  SidebarProvider,
  SidebarTrigger,
} from '@/components/ui/sidebar';
import { isDev } from '@/config/env';
import { SITE_URL } from '@/config/site';
import { buildContentSummaryTree } from '@/lib/content/core/tree-builder';
import { cn } from '@/lib/styles/tailwind-utils';
import { ThemeProvider } from '@/providers/theme-provider';
import type { Metadata } from 'next';
import { ibmPlexSansArabic } from './fonts';
import './globals.css';
export const metadata: Metadata = {
  metadataBase: new URL(SITE_URL),
  title: {
    template: '%s | Documentation',
    default: 'Documentation',
  },
  description: 'Documentation site built with Next.js',
};
export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const summaryTree = await buildContentSummaryTree();
  return (
    <>
      <html
        dir="rtl"
        lang="ar"
        className={cn(ibmPlexSansArabic.variable)}
        suppressHydrationWarning
      >
        <body
          className={cn(
            'overflow-x-hidden overflow-y-scroll',
            'font-ibmPlexSansArabic antialiased',
            {
              'debug-screens': isDev,
            }
          )}
        >
          <ThemeProvider
            attribute="class"
            defaultTheme="light"
            enableSystem
            disableTransitionOnChange
          >
            <DevDebuggers summaryTree={summaryTree} />
            <SidebarProvider>
              <Sidebar summaryTree={summaryTree} />
              <SidebarInset className="px-4 py-6 md:px-8">
                <header className="mb-4 flex items-center">
                  <SidebarTrigger />
                </header>
                <main className="pb-16">{children}</main>
              </SidebarInset>
            </SidebarProvider>
          </ThemeProvider>
        </body>
      </html>
    </>
  );
}

================
File: app/not-found.tsx
================
import { Button } from '@/components/ui/button';
import { flattenTree } from '@/lib/content/api';
import { buildContentSummaryTree } from '@/lib/content/core/tree-builder';
import { getNodeSlugPath } from '@/lib/content/query/get-node-path';
import { FileQuestion, Home, Search } from 'lucide-react';
import Link from 'next/link';
export const metadata = {
  title: 'Page Not Found | Documentation',
  description: "The page you're looking for doesn't exist or has been moved.",
};
export default async function NotFound() {
  const summaryTree = await buildContentSummaryTree();
  const flatTree = flattenTree(summaryTree);
  const suggestedPages = flatTree.sort(() => 0.5 - Math.random()).slice(0, 3);
  return (
    <div className="flex flex-col items-center justify-center px-4 py-16 text-center">
      <div className="mb-8 rounded-full bg-slate-100 p-6 dark:bg-slate-800">
        <FileQuestion className="h-16 w-16 text-slate-500" />
      </div>
      <h1 className="mb-2 text-4xl font-bold tracking-tight">
        {`404 - Page Not Found`}
      </h1>
      <p className="mb-8 max-w-md text-lg text-slate-500 dark:text-slate-400">
        {`The documentation page you're looking for doesn't exist or has been
        moved to a new location.`}
      </p>
      <div className="mb-12 flex flex-wrap justify-center gap-4">
        <Button asChild>
          <Link href="/">
            <Home className="mr-2 h-4 w-4" />
            Back to Home
          </Link>
        </Button>
        <Button variant="outline" asChild>
          <Link href="/learn">
            <Search className="mr-2 h-4 w-4" />
            Browse All Docs
          </Link>
        </Button>
      </div>
      {suggestedPages.length > 0 && (
        <>
          <h2 className="mb-4 text-xl font-semibold">
            You might be interested in:
          </h2>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {suggestedPages.map((page) => (
              <Link
                key={page.slug}
                href={`/learn/${getNodeSlugPath(page)}`}
                className="rounded-lg border border-slate-200 bg-white p-4 shadow-sm transition-colors hover:bg-slate-50 dark:border-slate-700 dark:bg-slate-800 dark:hover:bg-slate-700"
              >
                <h3 className="font-medium">{page.title}</h3>
              </Link>
            ))}
          </div>
        </>
      )}
    </div>
  );
}

================
File: app/page.tsx
================
import { redirect } from "next/navigation";
export default function Page() {
  redirect("/alnhw/slyman-alaywny/alnhw-alsghyr/");
}

================
File: components/common/markdown-renderer.tsx
================
export function MarkdownRenderer({ content }: { content: string }) {
  return (
    <div
      className="prose-code:bg-gray-100 prose-code:p-1 prose-code:rounded"
      dangerouslySetInnerHTML={{ __html: content }}
    />
  );
}

================
File: components/common/section.tsx
================
import { ReactNode } from 'react';
type SectionProps = {
  children: ReactNode;
};
type SectionTitleProps = {
  children: ReactNode;
  level?: 1 | 2 | 3 | 4 | 5 | 6;
};
type SectionPProps = {
  children: ReactNode;
};
function Section({ children }: SectionProps) {
  return (
    <section className="flex flex-col gap-6">
      {children}
      <div className="h-2 w-full border-t border-zinc-200"></div>
    </section>
  );
}
Section.H = function SectionTitle({ children, level = 2 }: SectionTitleProps) {
  const Tag = `h${level}` as const;
  const sizeMap = {
    1: 'text-4xl',
    2: 'text-3xl',
    3: 'text-2xl',
    4: 'text-xl',
    5: 'text-lg',
    6: 'text-base',
  };
  return <Tag className={`${sizeMap[level]} font-bold`}>{children}</Tag>;
};
Section.P = function SectionParagraph({ children }: SectionPProps) {
  return <p className="text-lg">{children}</p>;
};
export { Section };

================
File: components/common/theme-mode-toggle.tsx
================
'use client';
import { Moon, Sun } from 'lucide-react';
import { useTheme } from 'next-themes';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
export function ThemeModeToggle() {
  const { setTheme } = useTheme();
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon">
          <Sun className="h-[1.2rem] w-[1.2rem] scale-100 rotate-0 transition-all dark:scale-0 dark:-rotate-90" />
          <Moon className="absolute h-[1.2rem] w-[1.2rem] scale-0 rotate-90 transition-all dark:scale-100 dark:rotate-0" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme('light')}>
          Light
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('dark')}>
          Dark
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme('system')}>
          System
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: components/debug/index.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import { memo } from 'react';
import { TreeStructureDebugger } from './tree-structure.view';
function DevDebuggersComponent({
  summaryTree,
}: {
  summaryTree: SummaryNode[];
}) {
  return (
    <>
      <TreeStructureDebugger summaryTree={summaryTree} />
    </>
  );
}
export const DevDebuggers = memo(DevDebuggersComponent);

================
File: components/debug/tree-structure.hook.ts
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as React from 'react';
export interface TreeDebuggerState {
  open: boolean;
  copied: boolean;
  searchTerm: string;
  expandedNodes: string[];
  expandAll: boolean;
  activeTab: string;
}
export interface TreeDebuggerActions {
  setOpen: (open: boolean) => void;
  handleCopy: () => void;
  toggleNode: (path: string) => void;
  toggleExpandAll: () => void;
  setSearchTerm: (term: string) => void;
  setActiveTab: (tab: string) => void;
}
export interface TreeDebuggerHelpers {
  formattedTree: string;
  countNodes: (nodes: SummaryNode[]) => number;
  calculateMaxDepth: (nodes: SummaryNode[], currentDepth?: number) => number;
  matchesSearch: (node: SummaryNode, term: string) => boolean;
}
export interface UseTreeDebuggerResult {
  state: TreeDebuggerState;
  actions: TreeDebuggerActions;
  helpers: TreeDebuggerHelpers;
}
export function useTreeStructureDebugger(
  tree: SummaryNode[]
): UseTreeDebuggerResult {
  const [open, setOpen] = React.useState(false);
  const [copied, setCopied] = React.useState(false);
  const [searchTerm, setSearchTerm] = React.useState('');
  const [expandedNodes, setExpandedNodes] = React.useState<string[]>([]);
  const [expandAll, setExpandAll] = React.useState(false);
  const [activeTab, setActiveTab] = React.useState('visual');
  const formattedTree = React.useMemo(
    () => JSON.stringify(tree, null, 2),
    [tree]
  );
  const handleCopy = React.useCallback(() => {
    navigator.clipboard.writeText(formattedTree).then(() => {
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    });
  }, [formattedTree]);
  const toggleNode = React.useCallback((path: string) => {
    setExpandedNodes((prev) =>
      prev.includes(path) ? prev.filter((p) => p !== path) : [...prev, path]
    );
  }, []);
  const toggleExpandAll = React.useCallback(() => {
    setExpandAll((prev) => !prev);
    if (!expandAll) {
      const allPaths: string[] = [];
      const collectPaths = (nodes: SummaryNode[], currentPath = '') => {
        nodes.forEach((node) => {
          const nodePath = currentPath
            ? `${currentPath}.${node.slug}`
            : node.slug;
          allPaths.push(nodePath);
          if (node.children.length) {
            collectPaths(node.children, nodePath);
          }
        });
      };
      collectPaths(tree);
      setExpandedNodes(allPaths);
    } else {
      setExpandedNodes([]);
    }
  }, [expandAll, tree]);
  const countNodes = React.useCallback((nodes: SummaryNode[]): number => {
    let count = nodes.length;
    for (const node of nodes) {
      count += countNodes(node.children);
    }
    return count;
  }, []);
  const calculateMaxDepth = React.useCallback(
    (nodes: SummaryNode[], currentDepth = 1): number => {
      if (nodes.length === 0) return currentDepth - 1;
      let maxDepth = currentDepth;
      for (const node of nodes) {
        if (node.children.length > 0) {
          const childDepth = calculateMaxDepth(node.children, currentDepth + 1);
          maxDepth = Math.max(maxDepth, childDepth);
        }
      }
      return maxDepth;
    },
    []
  );
  const matchesSearch = React.useCallback(
    (node: SummaryNode, term: string): boolean => {
      if (!term) return true;
      const nodeMatches =
        node.title.toLowerCase().includes(term.toLowerCase()) ||
        node.slug.toLowerCase().includes(term.toLowerCase());
      if (nodeMatches) return true;
      return node.children.some((child) => matchesSearch(child, term));
    },
    []
  );
  return {
    state: {
      open,
      copied,
      searchTerm,
      expandedNodes,
      expandAll,
      activeTab,
    },
    actions: {
      setOpen,
      handleCopy,
      toggleNode,
      toggleExpandAll,
      setSearchTerm,
      setActiveTab,
    },
    helpers: {
      formattedTree,
      countNodes,
      calculateMaxDepth,
      matchesSearch,
    },
  };
}

================
File: components/debug/tree-structure.view.tsx
================
'use client';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@/components/ui/collapsible';
import {
  CustomDialog,
  CustomDialogContent,
  CustomDialogHeader,
  CustomDialogTitle,
} from '@/components/ui/custom-dialog';
import { DialogClose } from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import type { SummaryNode } from '@/lib/content/types';
import {
  ChevronRight,
  Copy,
  FolderTreeIcon as FileTree,
  Maximize2,
  Minimize2,
  Search,
  X,
} from 'lucide-react';
import { memo } from 'react';
import { useTreeStructureDebugger } from './tree-structure.hook';
function TreeStructureDebuggerComponent({
  summaryTree,
}: {
  summaryTree: SummaryNode[];
}) {
  const { state, actions, helpers } = useTreeStructureDebugger(summaryTree);
  const { open, copied, searchTerm, expandedNodes, expandAll, activeTab } =
    state;
  const {
    setOpen,
    handleCopy,
    toggleNode,
    toggleExpandAll,
    setSearchTerm,
    setActiveTab,
  } = actions;
  const { formattedTree, countNodes, calculateMaxDepth, matchesSearch } =
    helpers;
  if (process.env.NODE_ENV === 'production') return null;
  return (
    <>
      <Button
        onClick={() => setOpen(true)}
        className="fixed bottom-4 left-4 z-50"
        variant="default"
        size="sm"
      >
        <FileTree className="mr-2 h-4 w-4" />
        Tree Debugger
      </Button>
      <CustomDialog open={open} onOpenChange={setOpen}>
        <CustomDialogContent
          dir="ltr"
          className="border-border h-[90vh] w-[90vw] max-w-4xl overflow-x-hidden overflow-y-scroll rounded-lg border p-0 shadow-lg"
        >
          <CustomDialogHeader className="border-b px-6 pt-6 pb-4">
            <div className="flex items-center justify-between">
              <CustomDialogTitle className="flex items-center text-xl font-semibold">
                <FileTree className="text-primary mr-2 h-5 w-5" />
                Tree Structure Debugger
              </CustomDialogTitle>
              <div className="flex items-center gap-2">
                {activeTab === 'visual' && (
                  <Button size="sm" variant="outline" onClick={toggleExpandAll}>
                    {expandAll ? (
                      <>
                        <Minimize2 className="mr-1 h-4 w-4" />
                        Collapse All
                      </>
                    ) : (
                      <>
                        <Maximize2 className="mr-1 h-4 w-4" />
                        Expand All
                      </>
                    )}
                  </Button>
                )}
                {activeTab === 'json' && (
                  <Button size="sm" variant="outline" onClick={handleCopy}>
                    <Copy className="mr-1 h-4 w-4" />
                    {copied ? 'Copied!' : 'Copy JSON'}
                  </Button>
                )}
                <DialogClose asChild>
                  <Button size="icon" variant="ghost">
                    <X className="h-4 w-4" />
                  </Button>
                </DialogClose>
              </div>
            </div>
            <div className="relative mt-4">
              <Search className="text-muted-foreground absolute top-2.5 left-2.5 h-4 w-4" />
              <Input
                placeholder="Search nodes..."
                className="pl-9"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
          </CustomDialogHeader>
          <Tabs
            defaultValue="visual"
            className="flex h-[calc(90vh-160px)] flex-col"
            onValueChange={setActiveTab}
          >
            <TabsList className="mx-6 mt-4 w-auto self-start">
              <TabsTrigger value="visual">Visual Tree</TabsTrigger>
              <TabsTrigger value="json">Raw JSON</TabsTrigger>
            </TabsList>
            <TabsContent
              value="visual"
              className="flex-1 overflow-hidden px-6 pb-6"
            >
              <ScrollArea className="bg-background h-full rounded-md border">
                <div className="p-4">
                  {summaryTree.map((node) => (
                    <TreeNode
                      key={node.slug}
                      node={node}
                      level={0}
                      searchTerm={searchTerm}
                      expandedNodes={expandedNodes}
                      toggleNode={toggleNode}
                      expandAll={expandAll}
                      matchesSearch={matchesSearch}
                    />
                  ))}
                </div>
              </ScrollArea>
            </TabsContent>
            <TabsContent
              value="json"
              className="flex-1 overflow-hidden px-6 pb-6"
            >
              <ScrollArea className="bg-background h-full rounded-md border">
                <pre className="overflow-visible p-4 font-mono text-sm whitespace-pre-wrap">
                  {formattedTree}
                </pre>
              </ScrollArea>
            </TabsContent>
          </Tabs>
          <div className="bg-muted/10 text-muted-foreground border-t px-6 py-3 text-xs">
            <div className="flex items-center justify-between">
              <div>
                Total nodes: {countNodes(summaryTree)} • Root nodes:{' '}
                {summaryTree.length} • Max depth:{' '}
                {calculateMaxDepth(summaryTree)}
              </div>
              <div>
                <span className="font-mono">
                  process.env.NODE_ENV !== "production"
                </span>
              </div>
            </div>
          </div>
        </CustomDialogContent>
      </CustomDialog>
    </>
  );
}
interface TreeNodeProps {
  node: SummaryNode;
  level: number;
  searchTerm: string;
  expandedNodes: string[];
  toggleNode: (path: string) => void;
  expandAll: boolean;
  matchesSearch: (node: SummaryNode, term: string) => boolean;
  parentPath?: string;
}
function TreeNode({
  node,
  level,
  searchTerm,
  expandedNodes,
  toggleNode,
  expandAll,
  matchesSearch,
  parentPath = '',
}: TreeNodeProps) {
  const hasChildren = node.children.length > 0;
  const nodePath = parentPath ? `${parentPath}.${node.slug}` : node.slug;
  const isExpanded = expandedNodes.includes(nodePath) || expandAll;
  const isMatch = matchesSearch(node, searchTerm);
  // If there's a search term and no match, don't render this node
  if (searchTerm && !isMatch) return null;
  return (
    <div className={`${level > 0 ? `ml-${level * 3}` : ''} my-1`}>
      <Collapsible
        open={isExpanded}
        onOpenChange={() => hasChildren && toggleNode(nodePath)}
      >
        <div className="group hover:bg-muted/20 flex items-center rounded-md px-1 py-1">
          {hasChildren ? (
            <CollapsibleTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className="text-muted-foreground hover:text-foreground mr-1 h-6 w-6 p-0"
              >
                <ChevronRight
                  className={`h-4 w-4 transition-transform ${
                    isExpanded ? 'rotate-90' : ''
                  }`}
                />
                <span className="sr-only">Toggle</span>
              </Button>
            </CollapsibleTrigger>
          ) : (
            <div className="w-7" />
          )}
          <div className="flex flex-1 items-center gap-2">
            <span
              className={`font-medium ${
                searchTerm &&
                node.title.toLowerCase().includes(searchTerm.toLowerCase())
                  ? 'rounded bg-yellow-100 px-1 dark:bg-yellow-900/30'
                  : ''
              }`}
            >
              {node.title}
            </span>
            <span className="text-muted-foreground font-mono text-xs">
              ({node.slug})
            </span>
            {node.order && (
              <Badge variant="outline" className="text-xs">
                Order: {node.order}
              </Badge>
            )}
          </div>
        </div>
        {hasChildren && (
          <CollapsibleContent>
            <div className="border-muted mt-1 ml-3 border-l-2 pl-3">
              {node.children.map((childNode) => (
                <TreeNode
                  key={childNode.slug}
                  node={childNode}
                  level={level + 1}
                  searchTerm={searchTerm}
                  expandedNodes={expandedNodes}
                  toggleNode={toggleNode}
                  expandAll={expandAll}
                  matchesSearch={matchesSearch}
                  parentPath={nodePath}
                />
              ))}
            </div>
          </CollapsibleContent>
        )}
      </Collapsible>
    </div>
  );
}
export const TreeStructureDebugger = memo(TreeStructureDebuggerComponent);

================
File: components/layout/sidebar.tsx
================
'use client';
import {
  SidebarContent,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  Sidebar as UISidebar,
} from '@/components/ui/sidebar';
import { useSidebar } from '@/hooks/use-sidebar';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import {
  BookOpen,
  ChevronDown,
  ChevronLeft,
  ChevronsDownUp,
  FileText,
  Folder,
} from 'lucide-react';
import Link from 'next/link';
import React, { memo, useCallback } from 'react';
function SidebarComponent({ summaryTree }: { summaryTree: SummaryNode[] }) {
  const {
    flatItems,
    expandedSections,
    toggleSection,
    isCurrentPage,
    toggleAll,
  } = useSidebar(summaryTree);
  const isVisible = useCallback(
    (node: SummaryNode): boolean => {
      let path = '';
      for (const part of node.parentPath) {
        path = path ? `${path}/${part}` : part;
        if (!expandedSections[path]) return false;
      }
      return true;
    },
    [expandedSections]
  );
  return (
    <UISidebar side="right">
      <SidebarContent
        className={cn('overflow-y-scroll', '[&::-webkit-scrollbar]:w-0')}
      >
        <SidebarGroup>
          <SidebarGroupLabel>النحو الرقمي</SidebarGroupLabel>
          <SidebarGroupAction onClick={toggleAll} title="طي وبسط">
            <ChevronsDownUp /> <span className="sr-only">Toggle</span>
          </SidebarGroupAction>
          <SidebarGroupContent>
            <SidebarMenu>
              <SidebarMenuItem key="__home">
                <SidebarMenuButton
                  asChild
                  isActive={isCurrentPage('__home')}
                  className="pl-1.5"
                >
                  <Link href="/">
                    <BookOpen className="h-4 w-4 shrink-0" />
                    <span>مقدمة</span>
                  </Link>
                </SidebarMenuButton>
              </SidebarMenuItem>
              {flatItems.map(({ node, level }) => {
                const fullPath = [...node.parentPath, node.slug].join('/');
                const hasChildren = node.children.length > 0;
                const isExpanded = expandedSections[fullPath] || false;
                const isActive = isCurrentPage(fullPath);
                const visible = isVisible(node);
                if (!visible) return null;
                return (
                  <SidebarMenuItem key={fullPath}>
                    {hasChildren ? (
                      <SidebarMenuButton
                        className={cn(
                          'pr-[calc(0.5rem*var(--level))] pl-1.5',
                          isActive &&
                            'bg-sidebar-accent text-sidebar-accent-foreground font-medium'
                        )}
                        style={{ '--level': 1 + level } as React.CSSProperties}
                        onClick={() => toggleSection(fullPath)}
                      >
                        <Folder className="h-4 w-4 shrink-0" />
                        <span>{node.title}</span>
                        {isExpanded ? (
                          <ChevronDown className="mr-auto h-4 w-4" />
                        ) : (
                          <ChevronLeft className="mr-auto h-4 w-4" />
                        )}
                      </SidebarMenuButton>
                    ) : (
                      <SidebarMenuButton
                        asChild
                        isActive={isActive}
                        className={cn('pr-[calc(0.5rem*var(--level))]')}
                        style={{ '--level': 1 + level } as React.CSSProperties}
                      >
                        <Link href={`/learn/${fullPath}`}>
                          <FileText className="h-4 w-4 shrink-0" />
                          <span>{node.title}</span>
                        </Link>
                      </SidebarMenuButton>
                    )}
                  </SidebarMenuItem>
                );
              })}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
    </UISidebar>
  );
}
export const Sidebar = memo(SidebarComponent);

================
File: components/ui/badge.tsx
================
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
const badgeVariants = cva(
  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',
        destructive:
          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);
function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<'span'> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'span';
  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  );
}
export { Badge, badgeVariants };

================
File: components/ui/button.tsx
================
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',
        destructive:
          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',
        outline:
          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',
        secondary:
          'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',
        ghost:
          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2 has-[>svg]:px-3',
        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',
        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',
        icon: 'size-9',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}
export { Button, buttonVariants };

================
File: components/ui/collapsible.tsx
================
'use client';
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';
function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />;
}
function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  );
}
function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  );
}
export { Collapsible, CollapsibleTrigger, CollapsibleContent };

================
File: components/ui/custom-dialog.tsx
================
'use client';
import { cn } from '@/lib/styles/tailwind-utils';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import * as React from 'react';
const CustomDialog = DialogPrimitive.Root;
const CustomDialogTrigger = DialogPrimitive.Trigger;
const CustomDialogPortal = DialogPrimitive.Portal;
const CustomDialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/90',
      className
    )}
    {...props}
  />
));
CustomDialogOverlay.displayName = DialogPrimitive.Overlay.displayName;
const CustomDialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <CustomDialogPortal>
    <CustomDialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] fixed top-[50%] left-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border p-6 shadow-lg duration-200 sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      {}
    </DialogPrimitive.Content>
  </CustomDialogPortal>
));
CustomDialogContent.displayName = DialogPrimitive.Content.displayName;
const CustomDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
CustomDialogHeader.displayName = 'CustomDialogHeader';
const CustomDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
CustomDialogFooter.displayName = 'CustomDialogFooter';
const CustomDialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg leading-none font-semibold tracking-tight',
      className
    )}
    {...props}
  />
));
CustomDialogTitle.displayName = DialogPrimitive.Title.displayName;
const CustomDialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-muted-foreground text-sm', className)}
    {...props}
  />
));
CustomDialogDescription.displayName = DialogPrimitive.Description.displayName;
export {
  CustomDialog,
  CustomDialogContent,
  CustomDialogDescription,
  CustomDialogFooter,
  CustomDialogHeader,
  CustomDialogOverlay,
  CustomDialogPortal,
  CustomDialogTitle,
  CustomDialogTrigger,
};

================
File: components/ui/dialog.tsx
================
'use client';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}
function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}
function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}
function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}
function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className
      )}
      {...props}
    />
  );
}
function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}
function DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-header"
      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}
      {...props}
    />
  );
}
function DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        'flex flex-col-reverse gap-2 sm:flex-row sm:justify-end',
        className
      )}
      {...props}
    />
  );
}
function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn('text-lg leading-none font-semibold', className)}
      {...props}
    />
  );
}
function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}
export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};

================
File: components/ui/dropdown-menu.tsx
================
'use client';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}
function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}
function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}
function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}
function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}
function DropdownMenuItem({
  className,
  inset,
  variant = 'default',
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: 'default' | 'destructive';
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}
function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}
function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}
function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        'px-2 py-1.5 text-sm font-medium data-[inset]:pl-8',
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn('bg-border -mx-1 my-1 h-px', className)}
      {...props}
    />
  );
}
function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<'span'>) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        'text-muted-foreground ml-auto text-xs tracking-widest',
        className
      )}
      {...props}
    />
  );
}
function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}
function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        'focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8',
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}
function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg',
        className
      )}
      {...props}
    />
  );
}
export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};

================
File: components/ui/input.tsx
================
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Input({ className, type, ...props }: React.ComponentProps<'input'>) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        'file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        'focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',
        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',
        className
      )}
      {...props}
    />
  );
}
export { Input };

================
File: components/ui/scroll-area.tsx
================
'use client';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn('relative', className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  );
}
function ScrollBar({
  className,
  orientation = 'vertical',
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        'flex touch-none p-px transition-colors select-none',
        orientation === 'vertical' &&
          'h-full w-2.5 border-l border-l-transparent',
        orientation === 'horizontal' &&
          'h-2.5 flex-col border-t border-t-transparent',
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  );
}
export { ScrollArea, ScrollBar };

================
File: components/ui/separator.tsx
================
'use client';
import * as SeparatorPrimitive from '@radix-ui/react-separator';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Separator({
  className,
  orientation = 'horizontal',
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',
        className
      )}
      {...props}
    />
  );
}
export { Separator };

================
File: components/ui/sheet.tsx
================
'use client';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { XIcon } from 'lucide-react';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />;
}
function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />;
}
function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />;
}
function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />;
}
function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',
        className
      )}
      {...props}
    />
  );
}
function SheetContent({
  className,
  children,
  side = 'right',
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: 'top' | 'right' | 'bottom' | 'left';
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
          side === 'right' &&
            'data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm',
          side === 'left' &&
            'data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm',
          side === 'top' &&
            'data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b',
          side === 'bottom' &&
            'data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t',
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  );
}
function SheetHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-header"
      className={cn('flex flex-col gap-1.5 p-4', className)}
      {...props}
    />
  );
}
function SheetFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn('mt-auto flex flex-col gap-2 p-4', className)}
      {...props}
    />
  );
}
function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn('text-foreground font-semibold', className)}
      {...props}
    />
  );
}
function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn('text-muted-foreground text-sm', className)}
      {...props}
    />
  );
}
export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
};

================
File: components/ui/sidebar.tsx
================
'use client';
import { Slot } from '@radix-ui/react-slot';
import { VariantProps, cva } from 'class-variance-authority';
import { PanelRightIcon } from 'lucide-react';
import * as React from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Separator } from '@/components/ui/separator';
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { useIsMobile } from '@/hooks/use-mobile';
import { cn } from '@/lib/styles/tailwind-utils';
const SIDEBAR_COOKIE_NAME = 'sidebar_state';
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7;
const SIDEBAR_WIDTH = '16rem';
const SIDEBAR_WIDTH_MOBILE = '18rem';
const SIDEBAR_WIDTH_ICON = '3rem';
const SIDEBAR_KEYBOARD_SHORTCUT = 'b';
type SidebarContextProps = {
  state: 'expanded' | 'collapsed';
  open: boolean;
  setOpen: (open: boolean) => void;
  openMobile: boolean;
  setOpenMobile: (open: boolean) => void;
  isMobile: boolean;
  toggleSidebar: () => void;
};
const SidebarContext = React.createContext<SidebarContextProps | null>(null);
function useSidebar() {
  const context = React.useContext(SidebarContext);
  if (!context) {
    throw new Error('useSidebar must be used within a SidebarProvider.');
  }
  return context;
}
function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  defaultOpen?: boolean;
  open?: boolean;
  onOpenChange?: (open: boolean) => void;
}) {
  const isMobile = useIsMobile();
  const [openMobile, setOpenMobile] = React.useState(false);
  const [_open, _setOpen] = React.useState(defaultOpen);
  const open = openProp ?? _open;
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === 'function' ? value(open) : value;
      if (setOpenProp) {
        setOpenProp(openState);
      } else {
        _setOpen(openState);
      }
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`;
    },
    [setOpenProp, open]
  );
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open);
  }, [isMobile, setOpen, setOpenMobile]);
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault();
        toggleSidebar();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [toggleSidebar]);
  const state = open ? 'expanded' : 'collapsed';
  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  );
  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH,
              '--sidebar-width-icon': SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            'group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full',
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  );
}
function Sidebar({
  side = 'left',
  variant = 'sidebar',
  collapsible = 'offcanvas',
  className,
  children,
  ...props
}: React.ComponentProps<'div'> & {
  side?: 'left' | 'right';
  variant?: 'sidebar' | 'floating' | 'inset';
  collapsible?: 'offcanvas' | 'icon' | 'none';
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar();
  if (collapsible === 'none') {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          'bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col',
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              '--sidebar-width': SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    );
  }
  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === 'collapsed' ? collapsible : ''}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          'relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear',
          'group-data-[collapsible=offcanvas]:w-0',
          'group-data-[side=right]:rotate-180',
          variant === 'floating' || variant === 'inset'
            ? 'group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon)'
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          'fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex',
          side === 'left'
            ? 'left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]'
            : 'right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]',
          variant === 'floating' || variant === 'inset'
            ? 'p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]'
            : 'group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l',
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  );
}
function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar();
  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn('size-7', className)}
      onClick={(event) => {
        onClick?.(event);
        toggleSidebar();
      }}
      {...props}
    >
      <PanelRightIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  );
}
function SidebarRail({ className, ...props }: React.ComponentProps<'button'>) {
  const { toggleSidebar } = useSidebar();
  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        'hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex',
        'in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize',
        '[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize',
        'hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full',
        '[[data-side=left][data-collapsible=offcanvas]_&]:-right-2',
        '[[data-side=right][data-collapsible=offcanvas]_&]:-left-2',
        className
      )}
      {...props}
    />
  );
}
function SidebarInset({ className, ...props }: React.ComponentProps<'main'>) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        'bg-background relative flex w-full flex-1 flex-col',
        'md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2',
        className
      )}
      {...props}
    />
  );
}
function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn('bg-background h-8 w-full shadow-none', className)}
      {...props}
    />
  );
}
function SidebarHeader({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}
function SidebarFooter({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn('flex flex-col gap-2 p-2', className)}
      {...props}
    />
  );
}
function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn('bg-sidebar-border mx-2 w-auto', className)}
      {...props}
    />
  );
}
function SidebarContent({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        'flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroup({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn('relative flex w-full min-w-0 flex-col p-2', className)}
      {...props}
    />
  );
}
function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'div'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'div';
  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        'text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<'button'> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 left-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'after:absolute after:-inset-2 md:after:hidden',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn('w-full text-sm', className)}
      {...props}
    />
  );
}
function SidebarMenu({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn('flex w-full min-w-0 flex-col gap-1', className)}
      {...props}
    />
  );
}
function SidebarMenuItem({ className, ...props }: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn('group/menu-item relative', className)}
      {...props}
    />
  );
}
const sidebarMenuButtonVariants = cva(
  'peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
  {
    variants: {
      variant: {
        default: 'hover:bg-sidebar-accent hover:text-sidebar-accent-foreground',
        outline:
          'bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]',
      },
      size: {
        default: 'h-8 text-sm',
        sm: 'h-7 text-xs',
        lg: 'h-12 text-sm group-data-[collapsible=icon]:p-0!',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);
function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = 'default',
  size = 'default',
  tooltip,
  className,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  isActive?: boolean;
  tooltip?: string | React.ComponentProps<typeof TooltipContent>;
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : 'button';
  const { isMobile, state } = useSidebar();
  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  );
  if (!tooltip) {
    return button;
  }
  if (typeof tooltip === 'string') {
    tooltip = {
      children: tooltip,
    };
  }
  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== 'collapsed' || isMobile}
        {...tooltip}
      />
    </Tooltip>
  );
}
function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<'button'> & {
  asChild?: boolean;
  showOnHover?: boolean;
}) {
  const Comp = asChild ? Slot : 'button';
  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0',
        'after:absolute after:-inset-2 md:after:hidden',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        showOnHover &&
          'peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        'text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none',
        'peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground',
        'peer-data-[size=sm]/menu-button:top-1',
        'peer-data-[size=default]/menu-button:top-1.5',
        'peer-data-[size=lg]/menu-button:top-2.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<'div'> & {
  showIcon?: boolean;
}) {
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`;
  }, []);
  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn('flex h-8 items-center gap-2 rounded-md px-2', className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            '--skeleton-width': width,
          } as React.CSSProperties
        }
      />
    </div>
  );
}
function SidebarMenuSub({ className, ...props }: React.ComponentProps<'ul'>) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        'border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<'li'>) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn('group/menu-sub-item relative', className)}
      {...props}
    />
  );
}
function SidebarMenuSubButton({
  asChild = false,
  size = 'md',
  isActive = false,
  className,
  ...props
}: React.ComponentProps<'a'> & {
  asChild?: boolean;
  size?: 'sm' | 'md';
  isActive?: boolean;
}) {
  const Comp = asChild ? Slot : 'a';
  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        'text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0',
        'data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground',
        size === 'sm' && 'text-xs',
        size === 'md' && 'text-sm',
        'group-data-[collapsible=icon]:hidden',
        className
      )}
      {...props}
    />
  );
}
export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
};

================
File: components/ui/skeleton.tsx
================
import { cn } from '@/lib/styles/tailwind-utils';
function Skeleton({ className, ...props }: React.ComponentProps<'div'>) {
  return (
    <div
      data-slot="skeleton"
      className={cn('bg-accent animate-pulse rounded-md', className)}
      {...props}
    />
  );
}
export { Skeleton };

================
File: components/ui/table.tsx
================
'use client';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Table({ className, ...props }: React.ComponentProps<'table'>) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn('w-full caption-bottom text-sm', className)}
        {...props}
      />
    </div>
  );
}
function TableHeader({ className, ...props }: React.ComponentProps<'thead'>) {
  return (
    <thead
      data-slot="table-header"
      className={cn('[&_tr]:border-b', className)}
      {...props}
    />
  );
}
function TableBody({ className, ...props }: React.ComponentProps<'tbody'>) {
  return (
    <tbody
      data-slot="table-body"
      className={cn('[&_tr:last-child]:border-0', className)}
      {...props}
    />
  );
}
function TableFooter({ className, ...props }: React.ComponentProps<'tfoot'>) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        'bg-muted/50 border-t font-medium [&>tr]:last:border-b-0',
        className
      )}
      {...props}
    />
  );
}
function TableRow({ className, ...props }: React.ComponentProps<'tr'>) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        'hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors',
        className
      )}
      {...props}
    />
  );
}
function TableHead({ className, ...props }: React.ComponentProps<'th'>) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        'text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}
function TableCell({ className, ...props }: React.ComponentProps<'td'>) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        'p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',
        className
      )}
      {...props}
    />
  );
}
function TableCaption({
  className,
  ...props
}: React.ComponentProps<'caption'>) {
  return (
    <caption
      data-slot="table-caption"
      className={cn('text-muted-foreground mt-4 text-sm', className)}
      {...props}
    />
  );
}
export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
};

================
File: components/ui/tabs.tsx
================
'use client';
import * as TabsPrimitive from '@radix-ui/react-tabs';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn('flex flex-col gap-2', className)}
      {...props}
    />
  );
}
function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        'bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]',
        className
      )}
      {...props}
    />
  );
}
function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  );
}
function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn('flex-1 outline-none', className)}
      {...props}
    />
  );
}
export { Tabs, TabsContent, TabsList, TabsTrigger };

================
File: components/ui/tooltip.tsx
================
'use client';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';
import * as React from 'react';
import { cn } from '@/lib/styles/tailwind-utils';
function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}
function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}
function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}
function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          'bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance',
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}
export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };

================
File: components/visualizations/renderers/radial/radial-sunburst-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as d3 from 'd3';
import { ZoomIn, ZoomOut } from 'lucide-react';
import { memo, useCallback, useEffect, useRef, useState } from 'react';
type HierarchyDatum = {
  name: string;
  value: number;
  children?: HierarchyDatum[];
};
const GRADIENT_DEFINITIONS = [
  { id: 'gradient-1', from: '#fafafa', to: '#f4f4f5' },
  { id: 'gradient-2', from: '#f4f4f5', to: '#e4e4e7' },
  { id: 'gradient-3', from: '#e4e4e7', to: '#d4d4d8' },
  { id: 'gradient-4', from: '#d4d4d8', to: '#a1a1aa' },
  { id: 'gradient-5', from: '#a1a1aa', to: '#71717a' },
  { id: 'gradient-6', from: '#71717a', to: '#52525b' },
  { id: 'gradient-7', from: '#52525b', to: '#3f3f46' },
  { id: 'gradient-8', from: '#3f3f46', to: '#27272a' },
  { id: 'gradient-9', from: '#27272a', to: '#18181b' },
] as const;
export const RadialSunburstRenderer = memo(
  ({
    nodes,
    initialWidth = 1000,
    initialHeight = 1000,
  }: {
    nodes: SummaryNode[];
    initialWidth?: number;
    initialHeight?: number;
  }) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const svgRef = useRef<SVGSVGElement>(null);
    const zoomBehaviorRef = useRef<d3.ZoomBehavior<
      SVGSVGElement,
      unknown
    > | null>(null);
    const [zoomLevel, setZoomLevel] = useState(1);
    const [dimensions, setDimensions] = useState({
      width: initialWidth,
      height: initialHeight,
    });
    const transformData = useCallback(
      (nodes: SummaryNode[]): HierarchyDatum[] => {
        const transform = (nodes: SummaryNode[]): HierarchyDatum[] => {
          return nodes.map(
            (node): HierarchyDatum => ({
              name: node.title,
              value: node.children.length ? 0 : 1,
              children: node.children.length
                ? transform(node.children)
                : undefined,
            })
          );
        };
        return transform(nodes);
      },
      []
    );
    useEffect(() => {
      const updateDimensions = () => {
        if (!containerRef.current) return;
        const containerWidth = containerRef.current.clientWidth;
        const containerHeight = containerRef.current.clientHeight;
        const size = Math.max(
          Math.min(
            Math.min(containerWidth - 40, containerHeight - 100),
            initialWidth
          ),
          1000
        );
        setDimensions({ width: size, height: size });
      };
      updateDimensions();
      window.addEventListener('resize', updateDimensions);
      return () => window.removeEventListener('resize', updateDimensions);
    }, [initialWidth, initialHeight]);
    const handleZoomIn = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        d3.select(svgRef.current)
          .transition()
          .duration(300)
          .call(zoomBehaviorRef.current.scaleBy, 1.5);
      }
    }, []);
    const handleZoomOut = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        d3.select(svgRef.current)
          .transition()
          .duration(300)
          .call(zoomBehaviorRef.current.scaleBy, 1 / 1.5);
      }
    }, []);
    const handleResetZoom = useCallback(() => {
      if (svgRef.current && zoomBehaviorRef.current) {
        const { width, height } = dimensions;
        const centerX = width / 2;
        const centerY = height / 2;
        d3.select(svgRef.current)
          .transition()
          .duration(500)
          .call(
            zoomBehaviorRef.current.transform,
            d3.zoomIdentity.translate(centerX, centerY).scale(1)
          );
      }
    }, [dimensions]);
    useEffect(() => {
      if (!svgRef.current || !nodes.length || !dimensions.width) return;
      const svg = d3.select(svgRef.current);
      svg.selectAll('*').remove();
      const { width, height } = dimensions;
      const radius = Math.min(width, height) / 2.2;
      const defs = svg.append('defs');
      GRADIENT_DEFINITIONS.forEach((gradientDef) => {
        const gradient = defs
          .append('radialGradient')
          .attr('id', gradientDef.id)
          .attr('cx', '50%')
          .attr('cy', '50%')
          .attr('r', '50%');
        gradient
          .append('stop')
          .attr('offset', '0%')
          .attr('stop-color', gradientDef.from);
        gradient
          .append('stop')
          .attr('offset', '100%')
          .attr('stop-color', gradientDef.to);
      });
      const zoom = d3
        .zoom<SVGSVGElement, unknown>()
        .scaleExtent([0.5, 5])
        .on('zoom', (event) => {
          g.attr('transform', event.transform);
          setZoomLevel(event.transform.k);
        });
      zoomBehaviorRef.current = zoom;
      svg.call(zoom);
      const g = svg
        .append('g')
        .attr('transform', `translate(${width / 2},${height / 2})`);
      const root = d3
        .hierarchy<HierarchyDatum>({
          name: 'root',
          value: 0,
          children: transformData(nodes),
        })
        .sum((d) => d.value);
      const partition = d3
        .partition<HierarchyDatum>()
        .size([2 * Math.PI, radius * 0.95]);
      const rootWithPartition = partition(root);
      const gradientScale = d3
        .scaleOrdinal<number, string>()
        .domain([1, 2, 3, 4, 5, 6, 7, 8, 9])
        .range(GRADIENT_DEFINITIONS.map((def) => def.id));
      const arc = d3
        .arc<d3.HierarchyRectangularNode<HierarchyDatum>>()
        .startAngle((d) => d.x0)
        .endAngle((d) => d.x1)
        .innerRadius((d) => d.y0)
        .outerRadius((d) => d.y1);
      const segments = g
        .selectAll('path')
        .data(rootWithPartition.descendants().slice(1))
        .enter()
        .append('path')
        .attr('d', (d) => arc(d as d3.HierarchyRectangularNode<HierarchyDatum>))
        .style('fill', (d) => `url(#${gradientScale(d.depth)})`)
        .style('opacity', 0.9)
        .style('stroke', '#ffffff')
        .style('stroke-width', '1px')
        .style('cursor', 'pointer')
        .on('mouseover', function () {
          d3.select(this).style('opacity', 1).style('stroke-width', '2px');
        })
        .on('mouseout', function () {
          d3.select(this).style('opacity', 0.9).style('stroke-width', '1px');
        });
      segments.append('title').text((d) => d.data.name);
      const textNodes = rootWithPartition
        .descendants()
        .slice(1)
        .filter((d) => {
          const node = d as d3.HierarchyRectangularNode<HierarchyDatum>;
          const arcAngleDegrees = (node.x1 - node.x0) * (180 / Math.PI);
          const radialThickness = node.y1 - node.y0;
          const minAngle = node.depth === 1 ? 3 : node.depth === 2 ? 2 : 1.5;
          const minThickness = radius * 0.02;
          return arcAngleDegrees > minAngle && radialThickness > minThickness;
        });
      const textContainers = g
        .selectAll('.text-container')
        .data(textNodes)
        .enter()
        .append('g')
        .attr('class', 'text-container');
      textContainers.each(function (d) {
        const node = d as d3.HierarchyRectangularNode<HierarchyDatum>;
        const middleAngle = (node.x0 + node.x1) / 2;
        const middleRadius = (node.y0 + node.y1) / 2;
        const x = Math.sin(middleAngle) * middleRadius;
        const y = -Math.cos(middleAngle) * middleRadius;
        const arcWidth = node.y1 - node.y0;
        const arcAngle = node.x1 - node.x0;
        const arcLength = arcAngle * middleRadius;
        const boxWidth = Math.min(arcLength * 0.9, arcWidth * 2);
        const boxHeight = arcWidth * 0.9;
        const baseFontSize =
          Math.min(dimensions.width, dimensions.height) / 100;
        let fontSize;
        if (d.depth === 1) {
          fontSize = Math.min(baseFontSize * 2.5, arcWidth * 0.4);
        } else if (d.depth === 2) {
          fontSize = Math.min(baseFontSize * 2, arcWidth * 0.3);
        } else {
          fontSize = Math.min(baseFontSize * 1.5, arcWidth * 0.25);
        }
        fontSize = Math.max(fontSize, 8);
        let rotation = (middleAngle * 180) / Math.PI;
        if (rotation > 90 && rotation < 270) {
          rotation += 180;
        }
        const textColor = d.depth <= 4 ? '#18181b' : '#ffffff';
        const textElement = d3
          .select(this)
          .attr('transform', `translate(${x},${y}) rotate(${rotation})`)
          .append('text')
          .attr('text-anchor', 'middle')
          .attr('dominant-baseline', 'middle')
          .attr('fill', textColor)
          .attr('font-size', `${fontSize}px`)
          .attr('font-family', 'var(--font-ibmPlexSansArabic)')
          .attr('font-weight', '600')
          .style(
            'text-shadow',
            textColor === '#ffffff'
              ? '1px 1px 3px rgba(0,0,0,0.8)'
              : '1px 1px 3px rgba(255,255,255,0.8)'
          );
        const words = d.data.name.split(/\s+/);
        const lineHeight = fontSize * 1.2;
        const maxLines = Math.max(1, Math.floor(boxHeight / lineHeight));
        const charsPerLine = Math.max(
          3,
          Math.floor(boxWidth / (fontSize * 0.55))
        );
        if (
          words.length === 1 &&
          words[0].length > charsPerLine &&
          maxLines > 1
        ) {
          const word = words[0];
          let currentLine = '';
          let lineNumber = 0;
          for (let i = 0; i < word.length && lineNumber < maxLines; i++) {
            currentLine += word[i];
            if (currentLine.length >= charsPerLine || i === word.length - 1) {
              const isLastLine =
                lineNumber === maxLines - 1 || i === word.length - 1;
              const text =
                isLastLine && i < word.length - 1
                  ? currentLine + '...'
                  : currentLine;
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(text);
              currentLine = '';
              lineNumber++;
            }
          }
        } else {
          // Handle multiple words
          let currentLine = '';
          let lineNumber = 0;
          for (let i = 0; i < words.length && lineNumber < maxLines; i++) {
            const word = words[i];
            const testLine = currentLine + (currentLine ? ' ' : '') + word;
            if (testLine.length <= charsPerLine || currentLine === '') {
              currentLine = testLine;
            } else {
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(currentLine);
              currentLine = word;
              lineNumber++;
            }
            if (i === words.length - 1 && lineNumber < maxLines) {
              const isLastPossibleLine = lineNumber === maxLines - 1;
              const hasMoreWords = i < words.length - 1;
              const text =
                isLastPossibleLine && hasMoreWords
                  ? currentLine + '...'
                  : currentLine;
              textElement
                .append('tspan')
                .attr('x', 0)
                .attr(
                  'y',
                  lineNumber * lineHeight - ((maxLines - 1) * lineHeight) / 2
                )
                .text(text);
            }
          }
        }
      });
    }, [nodes, dimensions, transformData]);
    return (
      <div
        ref={containerRef}
        className="relative h-[80vh] w-full rounded-lg bg-zinc-100/80 shadow ring-1 shadow-zinc-100 ring-zinc-200 dark:bg-slate-800"
      >
        {}
        <div className="absolute top-4 right-4 z-10 flex flex-col gap-2">
          <button
            onClick={handleZoomIn}
            className="flex items-center justify-center rounded-lg border border-zinc-200 bg-white p-2 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700"
            title="Zoom In"
          >
            <ZoomIn className="h-5 w-5 text-zinc-600 dark:text-zinc-300" />
          </button>
          <button
            onClick={handleZoomOut}
            className="flex items-center justify-center rounded-lg border border-zinc-200 bg-white p-2 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700"
            title="Zoom Out"
          >
            <ZoomOut className="h-5 w-5 text-zinc-600 dark:text-zinc-300" />
          </button>
          <button
            onClick={handleResetZoom}
            className="rounded-lg border border-zinc-200 bg-white px-3 py-2 text-xs font-bold text-zinc-600 shadow-xs transition-shadow hover:shadow-sm dark:border-zinc-600 dark:bg-zinc-700 dark:text-zinc-300"
            title="Reset Zoom"
          >
            اضبط
          </button>
        </div>
        {}
        <div className="absolute right-4 bottom-4 z-10 rounded-lg border border-zinc-200 bg-white px-3 py-1 shadow-xs dark:border-zinc-600 dark:bg-zinc-700">
          <span className="text-xs font-medium text-zinc-600 dark:text-zinc-300">
            {Math.round(zoomLevel * 100)}%
          </span>
        </div>
        {}
        <div className="flex h-full w-full items-center justify-center overflow-hidden">
          <svg
            ref={svgRef}
            className="cursor-grab active:cursor-grabbing"
            width={`${dimensions.width}px`}
            height={`${dimensions.height}px`}
            viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
            preserveAspectRatio="xMidYMid meet"
          />
        </div>
      </div>
    );
  }
);
RadialSunburstRenderer.displayName = 'RadialSunburstRenderer';

================
File: components/visualizations/renderers/spatial/circle-pack-renderer.tsx
================
'use client';
import * as d3 from 'd3';
import { useEffect, useRef } from 'react';
interface SummaryNode {
  title: string;
  children: SummaryNode[];
}
interface PackVisualizationProps {
  nodes: SummaryNode[];
  width?: number;
  height?: number;
}
type HierarchyData = {
  title: string;
  children?: HierarchyData[];
};
export function CirclePackRenderer({
  nodes,
  width = 800,
  height = 800,
}: PackVisualizationProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    if (!svgRef.current || !containerRef.current || nodes.length === 0) return;
    const hierarchyData: HierarchyData = {
      title: 'root',
      children: nodes as HierarchyData[],
    };
    const root = d3
      .hierarchy(hierarchyData)
      .sum((d) => Math.max(20, d.title.length));
    const pack = d3.pack<HierarchyData>().size([width, height]).padding(20);
    const packedData = pack(root);
    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();
    const g = svg.append('g');
    const zoom = d3
      .zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });
    svg.call(zoom);
    function wrap(
      text: d3.Selection<SVGTextElement, any, any, any>,
      width: number
    ) {
      text.each(function () {
        const textElement = d3.select(this);
        const words = textElement.text().split(/\s+/);
        const lineHeight = 1.1;
        let line: string[] = [];
        let lineNumber = 0;
        const y = textElement.attr('y') || 0;
        const dy = parseFloat(textElement.attr('dy') || '0');
        textElement.text('');
        let tspan = textElement
          .append('tspan')
          .attr('x', 0)
          .attr('y', y)
          .attr('dy', `${dy}em`);
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          line.push(word);
          tspan.text(line.join(' '));
          if (
            (tspan.node()?.getComputedTextLength() || 0) > width &&
            line.length > 1
          ) {
            line.pop();
            tspan.text(line.join(' '));
            line = [word];
            lineNumber++;
            tspan = textElement
              .append('tspan')
              .attr('x', 0)
              .attr('dy', `${lineHeight}em`)
              .text(word);
          }
        }
        const totalLines = lineNumber + 1;
        const offsetY = -(totalLines - 1) * lineHeight * 0.5;
        textElement.selectAll('tspan').each(function (d, i) {
          d3.select(this).attr(
            'dy',
            i === 0 ? `${dy + offsetY}em` : `${lineHeight}em`
          );
        });
      });
    }
    function getTextPosition(d: d3.HierarchyCircularNode<HierarchyData>) {
      if (!d.children) {
        return { x: 0, y: 0 };
      }
      const children = d.children;
      const radius = d.r;
      const positions = [
        { x: 0, y: -radius * 0.7 },
        { x: 0, y: radius * 0.7 },
        { x: -radius * 0.7, y: 0 },
        { x: radius * 0.7, y: 0 },
        { x: -radius * 0.5, y: -radius * 0.5 },
        { x: radius * 0.5, y: -radius * 0.5 },
        { x: -radius * 0.5, y: radius * 0.5 },
        { x: radius * 0.5, y: radius * 0.5 },
      ];
      let bestPosition = positions[0];
      let minOverlap = Infinity;
      for (const pos of positions) {
        let overlap = 0;
        for (const child of children) {
          const distance = Math.sqrt(
            Math.pow(pos.x - (child.x - d.x), 2) +
              Math.pow(pos.y - (child.y - d.y), 2)
          );
          if (distance < child.r + 20) {
            overlap += child.r + 20 - distance;
          }
        }
        if (overlap < minOverlap) {
          minOverlap = overlap;
          bestPosition = pos;
        }
      }
      return bestPosition;
    }
    const hasChildren = (
      d: d3.HierarchyCircularNode<HierarchyData>
    ): boolean => {
      return Boolean(d.children && d.children.length > 0);
    };
    const node = g
      .selectAll<SVGGElement, d3.HierarchyCircularNode<HierarchyData>>('g')
      .data(packedData.descendants().filter((d) => d.depth > 0))
      .join('g')
      .attr('transform', (d) => `translate(${d.x},${d.y})`);
    node
      .filter((d) => !hasChildren(d))
      .append('circle')
      .attr('r', (d) => d.r)
      .attr('fill', '#ffffff00')
      .attr('stroke', '#999')
      .attr('stroke-width', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function () {
        d3.select(this).attr('stroke-width', 2);
      })
      .on('mouseout', function () {
        d3.select(this).attr('stroke-width', 1);
      });
    node
      .filter((d) => hasChildren(d))
      .append('circle')
      .attr('r', (d) => d.r)
      .attr('fill', '#ffffff00')
      .attr('stroke', '#999')
      .attr('stroke-width', 1)
      .style('cursor', 'pointer')
      .on('mouseover', function () {
        d3.select(this).attr('stroke-width', 2);
      })
      .on('mouseout', function () {
        d3.select(this).attr('stroke-width', 1);
      });
    const textElements = node
      .append('text')
      .attr('text-anchor', 'middle')
      .attr('transform', (d) => {
        const pos = getTextPosition(d);
        return `translate(${pos.x}, ${pos.y})`;
      })
      .style('font-size', (d) => {
        const baseSize = Math.min(d.r / 4, 14);
        const textLength = d.data.title.length;
        const scaleFactor = d.children ? 0.8 : 1;
        return `${Math.max(
          baseSize * scaleFactor * (25 / Math.max(textLength, 25)),
          8
        )}px`;
      })
      .style('fill', (d) => (d.children ? '#666666' : '#000000'))
      .style('font-weight', (d) => (d.children ? 'bold' : 'normal'))
      .style('pointer-events', 'none')
      .text((d) => d.data.title);
    textElements.each(function (d) {
      const wrapWidth = d.children ? d.r * 0.8 : d.r * 1.6;
      wrap(d3.select(this), wrapWidth);
    });
    node.on('dblclick', (event, d) => {
      event.stopPropagation();
      const dx = d.x;
      const dy = d.y;
      const scale = Math.min(width / (d.r * 2), height / (d.r * 2)) * 0.9;
      svg
        .transition()
        .duration(750)
        .call(
          zoom.transform,
          d3.zoomIdentity
            .translate(width / 2, height / 2)
            .scale(scale)
            .translate(-dx, -dy)
        );
    });
    svg.on('dblclick', () => {
      svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
    });
  }, [nodes, width, height]);
  return (
    <div
      ref={containerRef}
      className="flex items-center justify-center overflow-hidden rounded-lg bg-zinc-100 shadow ring-1 shadow-zinc-100 ring-zinc-200"
      style={{ width: '100%', height: '100%' }}
    >
      <svg
        ref={svgRef}
        width={'100%'}
        height={'100%'}
        viewBox={`0 0 ${width} ${height}`}
        style={{ maxWidth: '100%', height: 'auto' }}
      />
    </div>
  );
}

================
File: components/visualizations/renderers/spatial/grid-layout-renderer.tsx
================
import { getLeafNodes } from '@/lib/content/query/get-leaf-nodes';
import type { SummaryNode } from '@/lib/content/types';
import { memo } from 'react';
export const GridLayoutRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    const leafNodes = getLeafNodes(nodes);
    return (
      <div className="xs:grid-cols-2 grid grid-cols-1 gap-4 py-4 md:grid-cols-3 lg:grid-cols-4">
        {leafNodes.map((node) => (
          <a
            key={node.slug}
            href={`/learn/${node.slug}`}
            className="rounded-lg border p-4 transition-colors hover:bg-zinc-50 dark:hover:bg-zinc-800"
          >
            <h2 className="text-base">{node.title}</h2>
          </a>
        ))}
      </div>
    );
  }
);

================
File: components/visualizations/renderers/spatial/nested-boxes-renderer.tsx
================
'use client';
import { getNodeSlugPath } from '@/lib/content/query/get-node-path';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import Link from 'next/link';
import { memo, useId } from 'react';
const COLOR_SCHEMES = [
  {
    bg: 'bg-gradient-to-br from-zinc-50 to-zinc-100',
    border: 'border-zinc-200',
    text: 'text-zinc-700',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-100 to-zinc-200',
    border: 'border-zinc-300',
    text: 'text-zinc-800',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-200 to-zinc-300',
    border: 'border-zinc-400',
    text: 'text-zinc-900',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-300 to-zinc-400',
    border: 'border-zinc-500',
    text: 'text-white',
  },
  {
    bg: 'bg-gradient-to-br from-zinc-400 to-zinc-500',
    border: 'border-zinc-600',
    text: 'text-white',
  },
] as const;
const FONT_SIZES = {
  0: 'text-lg md:text-xl',
  1: 'text-base md:text-lg',
  2: 'text-sm md:text-base',
  default: 'text-xs md:text-sm',
} as const;
const PADDINGS = {
  0: 'py-3 px-4 md:py-4 md:px-5',
  1: 'py-2 px-3 md:py-3 md:px-4',
  default: 'py-1.5 px-2 md:py-2 md:px-3',
} as const;
const GAPS = {
  container: 'gap-2 md:gap-4',
  margin: 'mt-2 md:mt-4',
} as const;
const CONTAINER_STYLES = {
  wrapper: 'w-full bg-zinc-100 rounded-lg ring-1 ring-zinc-200 overflow-hidden',
  flexContainer: 'w-full flex flex-wrap',
  centerContent: 'justify-center',
} as const;
const BOX_STYLES = {
  base: 'w-full rounded-lg border transition-all duration-200',
  interactive: 'group cursor-pointer',
  textBase: 'font-medium transition-all duration-200',
  linkBase: 'transition-all duration-200 block truncate',
} as const;
const ANIMATIONS = {
  duration: 'duration-200',
  fontWeight: 'group-hover:font-semibold',
} as const;
export const NestedBoxesRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    return (
      <div className={CONTAINER_STYLES.wrapper}>
        <BoxView nodes={nodes} />
      </div>
    );
  }
);
const BoxView = memo(
  ({ nodes, depth = 0 }: { nodes: SummaryNode[]; depth?: number }) => {
    const scheme = COLOR_SCHEMES[depth % COLOR_SCHEMES.length];
    const uniqueId = useId();
    const getFontSize = (depth: number): string => {
      if (depth in FONT_SIZES) {
        return FONT_SIZES[depth as keyof typeof FONT_SIZES];
      }
      return FONT_SIZES.default;
    };
    const getPadding = (depth: number): string => {
      if (depth in PADDINGS) {
        return PADDINGS[depth as keyof typeof PADDINGS];
      }
      return PADDINGS.default;
    };
    return (
      <div
        className={cn(
          CONTAINER_STYLES.flexContainer,
          GAPS.container,
          depth > 0 ? GAPS.margin : CONTAINER_STYLES.centerContent
        )}
      >
        {nodes.map((node) => (
          <div
            key={`${uniqueId}-${node.slug}`}
            className={cn(
              BOX_STYLES.base,
              BOX_STYLES.interactive,
              scheme.bg,
              scheme.border,
              getPadding(depth)
            )}
          >
            <div
              className={cn(
                BOX_STYLES.textBase,
                scheme.text,
                ANIMATIONS.fontWeight,
                getFontSize(depth)
              )}
            >
              <Link
                href={`/learn/${getNodeSlugPath(node)}`}
                className={BOX_STYLES.linkBase}
              >
                {node.title}
              </Link>
            </div>
            {node.children.length > 0 && (
              <BoxView nodes={node.children} depth={depth + 1} />
            )}
          </div>
        ))}
      </div>
    );
  }
);

================
File: components/visualizations/renderers/tree/ascii-tree-renderer.tsx
================
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import { generateASCIITree } from '@/lib/text/ascii-tree-generator';
import { memo } from 'react';
export const ASCIITreeRenderer = memo(({ nodes }: { nodes: SummaryNode[] }) => {
  return (
    <div className="max-w-none overflow-hidden rounded-lg bg-zinc-100/80 shadow ring-1 shadow-zinc-100 ring-zinc-200">
      <p
        className={cn(
          'overflow-auto p-6 text-base whitespace-pre text-zinc-700'
        )}
      >
        {generateASCIITree(nodes, {
          indent: '',
        })}
      </p>
    </div>
  );
});

================
File: components/visualizations/renderers/tree/collapsible-tree-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import { cn } from '@/lib/styles/tailwind-utils';
import { transliterate } from '@/lib/text/transliteration';
import { memo } from 'react';
const ZINC_SHADES = [
  {
    background: 'bg-zinc-50 dark:bg-zinc-900',
    border: 'border-zinc-200 dark:border-zinc-700',
    text: 'text-zinc-900 dark:text-zinc-100',
    connection: 'border-zinc-300 dark:border-zinc-600',
  },
  {
    background: 'bg-zinc-100 dark:bg-zinc-800',
    border: 'border-zinc-300 dark:border-zinc-600',
    text: 'text-zinc-800 dark:text-zinc-200',
    connection: 'border-zinc-400 dark:border-zinc-500',
  },
  {
    background: 'bg-zinc-200 dark:bg-zinc-700',
    border: 'border-zinc-400 dark:border-zinc-500',
    text: 'text-zinc-700 dark:text-zinc-300',
    connection: 'border-zinc-500 dark:border-zinc-400',
  },
  {
    background: 'bg-zinc-300 dark:bg-zinc-600',
    border: 'border-zinc-500 dark:border-zinc-400',
    text: 'text-zinc-600 dark:text-zinc-400',
    connection: 'border-zinc-600 dark:border-zinc-300',
  },
  {
    background: 'bg-zinc-400 dark:bg-zinc-500',
    border: 'border-zinc-600 dark:border-zinc-300',
    text: 'text-white dark:text-zinc-100',
    connection: 'border-zinc-700 dark:border-zinc-200',
  },
  {
    background: 'bg-zinc-500 dark:bg-zinc-400',
    border: 'border-zinc-700 dark:border-zinc-200',
    text: 'text-white dark:text-zinc-900',
    connection: 'border-zinc-800 dark:border-zinc-100',
  },
] as const;
const CONTAINER_COLORS = {
  background: 'bg-zinc-50 dark:bg-zinc-900',
  ring: 'ring-zinc-200 dark:ring-zinc-700',
  shadow: 'shadow-zinc-100 dark:shadow-zinc-800',
} as const;
const SPACING = {
  container: 'p-6',
  nodeGap: 'space-y-3',
  nodeMargin: 'mt-3',
  nodePadding: 'px-4 py-3',
  indent: 'mr-4',
  connector: 'w-4',
} as const;
const LAYOUT = {
  containerBase: 'w-full rounded-lg shadow ring-1',
  flexColumn: 'flex flex-col',
  flexRow: 'flex items-center',
  nodeBase: 'rounded-lg border transition-all duration-200',
  nodeParent: 'font-semibold',
  nodeLeaf: 'font-medium',
  connectionLine: 'border-l-2',
  connectionHorizontal: 'h-0.5',
  connectionHeight: 'h-6',
  connectionShort: 'h-3',
  hover: 'hover:shadow-md hover:scale-[1.01]',
} as const;
const getColorsForLevel = (level: number) => {
  return ZINC_SHADES[level % ZINC_SHADES.length];
};
export const CollapsibleTreeRenderer = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    return (
      <div
        className={cn(
          LAYOUT.containerBase,
          CONTAINER_COLORS.background,
          CONTAINER_COLORS.ring,
          CONTAINER_COLORS.shadow,
          SPACING.container
        )}
      >
        <TreeView nodes={nodes} />
      </div>
    );
  }
);
const TreeView = memo(
  ({ nodes, level = 0 }: { nodes: SummaryNode[]; level?: number }) => {
    const levelColors = getColorsForLevel(level);
    return (
      <div className={cn(LAYOUT.flexColumn, SPACING.nodeGap)}>
        {nodes.map((node, index) => (
          <div key={node.slug}>
            <div className={LAYOUT.flexRow}>
              {level > 0 && (
                <div className={LAYOUT.flexRow}>
                  {Array.from({ length: level }).map((_, i) => {
                    const connectionColors = getColorsForLevel(i);
                    return (
                      <div
                        key={i}
                        className={cn(
                          SPACING.indent,
                          LAYOUT.connectionHeight,
                          SPACING.connector,
                          LAYOUT.connectionLine,
                          connectionColors.connection,
                          index === nodes.length - 1 &&
                            i === level - 1 &&
                            LAYOUT.connectionShort
                        )}
                      />
                    );
                  })}
                  <div
                    className={cn(
                      LAYOUT.connectionHorizontal,
                      SPACING.connector,
                      levelColors.connection.replace('border-', 'bg-'),
                      index === nodes.length - 1 && LAYOUT.connectionShort
                    )}
                  />
                </div>
              )}
              {}
              <div
                className={cn(
                  LAYOUT.nodeBase,
                  LAYOUT.hover,
                  SPACING.nodePadding,
                  levelColors.background,
                  levelColors.border,
                  levelColors.text,
                  node.children.length > 0 ? LAYOUT.nodeParent : LAYOUT.nodeLeaf
                )}
              >
                <div className="flex items-center justify-between">
                  <span>{node.title}</span>
                  {node.children.length > 0 && (
                    <span
                      className={cn(
                        'ml-3 rounded-full px-2 py-1 text-xs',
                        'bg-white/20 dark:bg-black/20'
                      )}
                    >
                      {transliterate({
                        input: node.children.length,
                        mode: 'latin-numbers-to-arabic-digits',
                      })}
                    </span>
                  )}
                </div>
              </div>
            </div>
            {}
            {node.children.length > 0 && (
              <div className={SPACING.nodeMargin}>
                <TreeView nodes={node.children} level={level + 1} />
              </div>
            )}
          </div>
        ))}
      </div>
    );
  }
);

================
File: components/visualizations/renderers/tree/node-link-diagram-renderer.tsx
================
'use client';
import type { SummaryNode } from '@/lib/content/types';
import * as d3 from 'd3';
import { memo, useEffect, useRef, useState } from 'react';
type TreeNode = {
  id: string;
  name: string;
  children?: TreeNode[];
};
type TreeVisualizationProps = {
  nodes: SummaryNode[];
  height?: number;
};
export const NodeLinkDiagramRenderer = memo(
  ({ nodes, height = 600 }: TreeVisualizationProps) => {
    const containerRef = useRef<HTMLDivElement>(null);
    const [dimensions, setDimensions] = useState({ width: 0, height });
    useEffect(() => {
      if (!containerRef.current) return;
      const updateDimensions = () => {
        if (containerRef.current) {
          const { width } = containerRef.current.getBoundingClientRect();
          setDimensions({ width, height });
        }
      };
      updateDimensions();
      const resizeObserver = new ResizeObserver(updateDimensions);
      resizeObserver.observe(containerRef.current);
      return () => {
        if (containerRef.current) {
          resizeObserver.unobserve(containerRef.current);
        }
        resizeObserver.disconnect();
      };
    }, [height]);
    useEffect(() => {
      if (!containerRef.current || nodes.length === 0 || dimensions.width === 0)
        return;
      containerRef.current.innerHTML = '';
      const svg = d3
        .select(containerRef.current)
        .append('svg')
        .attr('width', '100%')
        .attr('height', dimensions.height)
        .attr('viewBox', `0 0 ${dimensions.width} ${dimensions.height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');
      const contentGroup = svg.append('g').attr('class', 'content');
      const transformNodes = (inputNodes: SummaryNode[]): TreeNode[] => {
        return inputNodes.map((node, index) => ({
          id: node.slug || `node-${index}`,
          name: node.title,
          children: node.children?.length
            ? transformNodes(node.children)
            : undefined,
        }));
      };
      const treeData: TreeNode[] = transformNodes(nodes);
      const root = d3.hierarchy(treeData[0]);
      const isMobile = window.innerWidth < 768;
      const treeLayout = d3
        .tree<TreeNode>()
        .size(
          isMobile
            ? [dimensions.height - 100, dimensions.width - 100]
            : [dimensions.height - 40, dimensions.width - 180]
        )
        .separation((a, b) => (a.parent === b.parent ? 1 : 1.2));
      treeLayout(root);
      contentGroup
        .selectAll('path.link')
        .data(root.links())
        .join('path')
        .attr('class', 'link')
        .attr(
          'd',
          d3
            .linkHorizontal<
              d3.HierarchyLink<TreeNode>,
              d3.HierarchyPointNode<TreeNode>
            >()
            .x((d) => d.y)
            .y((d) => d.x)
        )
        .style('fill', 'none')
        .style('stroke', '#555')
        .style('stroke-width', 1.5);
      const nodeGroups = contentGroup
        .selectAll('g.node')
        .data(root.descendants())
        .join('g')
        .attr('class', 'node')
        .attr('transform', (d) => `translate(${d.y},${d.x})`);
      nodeGroups
        .append('circle')
        .attr('r', 6)
        .style('fill', (d: d3.HierarchyNode<TreeNode>) =>
          d.children ? '#555' : '#999'
        )
        .style('stroke', '#fff')
        .style('stroke-width', 2);
      nodeGroups
        .append('text')
        .attr('dy', '-1.2em')
        .attr('x', 0)
        .style('text-anchor', 'middle')
        .text((d: d3.HierarchyNode<TreeNode>) => d.data.name)
        .style('font-size', isMobile ? '10px' : '12px')
        .style('font-family', 'sans-serif')
        .style('fill', '#333');
      nodeGroups
        .on(
          'mouseover',
          function (event: MouseEvent, d: d3.HierarchyNode<TreeNode>) {
            d3.select(this)
              .select('circle')
              .transition()
              .duration(200)
              .attr('r', 8)
              .style('fill', '#0066cc');
            d3.select(this).select('text').style('font-weight', 'bold');
          }
        )
        .on(
          'mouseout',
          function (event: MouseEvent, d: d3.HierarchyNode<TreeNode>) {
            d3.select(this)
              .select('circle')
              .transition()
              .duration(200)
              .attr('r', 6)
              .style('fill', d.children ? '#555' : '#999');
            d3.select(this).select('text').style('font-weight', 'normal');
          }
        );
      const zoom = d3
        .zoom()
        .scaleExtent([0.3, 3])
        .on('zoom', (event) => {
          contentGroup.attr('transform', event.transform);
        });
      svg.call(zoom as any);
      if (isMobile) {
        const rootNode = root;
        const rootX = rootNode.y || 0;
        const rootY = rootNode.x || 0;
        const scale = 1.0;
        const viewportCenterX = dimensions.width / 2;
        const viewportCenterY = dimensions.height / 2;
        const translateX = viewportCenterX - rootX * scale;
        const translateY = viewportCenterY - rootY * scale;
        svg.call(
          zoom.transform as any,
          d3.zoomIdentity.translate(translateX, translateY).scale(scale)
        );
      } else {
        const bounds = contentGroup.node()?.getBBox();
        if (bounds) {
          const scale = Math.min(
            dimensions.width / bounds.width,
            dimensions.height / bounds.height,
            0.9
          );
          const x = (dimensions.width - bounds.width * scale) / 2;
          const y = (dimensions.height - bounds.height * scale) / 2;
          svg.call(
            zoom.transform as any,
            d3.zoomIdentity.translate(x, y).scale(scale)
          );
        }
      }
    }, [nodes, dimensions.width, dimensions.height]);
    return (
      <div
        ref={containerRef}
        className="h-full w-full overflow-hidden rounded-lg bg-zinc-100 shadow ring-1 shadow-zinc-200 ring-zinc-200 dark:bg-zinc-900"
        style={{ minHeight: height }}
      />
    );
  }
);

================
File: components/visualizations/visualization-switcher.tsx
================
'use client';
import type React from 'react';
import type { SummaryNode } from '@/lib/content/types';
import {
  Boxes,
  GitBranch,
  Grid,
  Network,
  PieChart,
  Target,
  Terminal,
} from 'lucide-react';
import { memo, useMemo, useState } from 'react';
import { RadialSunburstRenderer } from './renderers/radial/radial-sunburst-renderer';
import { CirclePackRenderer } from './renderers/spatial/circle-pack-renderer';
import { GridLayoutRenderer } from './renderers/spatial/grid-layout-renderer';
import { NestedBoxesRenderer } from './renderers/spatial/nested-boxes-renderer';
import { ASCIITreeRenderer } from './renderers/tree/ascii-tree-renderer';
import { CollapsibleTreeRenderer } from './renderers/tree/collapsible-tree-renderer';
import { NodeLinkDiagramRenderer } from './renderers/tree/node-link-diagram-renderer';
type VisualizationType =
  | 'collapsible-tree'
  | 'ascii-tree'
  | 'nested-boxes'
  | 'grid-layout'
  | 'radial-sunburst'
  | 'node-diagram'
  | 'circle-pack';
interface VisualizationConfig {
  type: VisualizationType;
  label: string;
  icon: React.ReactNode;
  component: React.ComponentType<{ nodes: SummaryNode[] }>;
}
const VISUALIZATION_CONFIGS: VisualizationConfig[] = [
  {
    type: 'node-diagram',
    label: 'شبكة',
    icon: <Network className="h-4 w-4" />,
    component: NodeLinkDiagramRenderer,
  },
  {
    type: 'circle-pack',
    label: 'تراص',
    icon: <Target className="h-4 w-4" />,
    component: CirclePackRenderer,
  },
  {
    type: 'radial-sunburst',
    label: 'شعاع',
    icon: <PieChart className="h-4 w-4" />,
    component: RadialSunburstRenderer,
  },
  {
    type: 'ascii-tree',
    label: 'تفرع',
    icon: <Terminal className="h-4 w-4" />,
    component: ASCIITreeRenderer,
  },
  {
    type: 'collapsible-tree',
    label: 'سلسلة',
    icon: <GitBranch className="h-4 w-4" />,
    component: CollapsibleTreeRenderer,
  },
  {
    type: 'nested-boxes',
    label: 'وعاء',
    icon: <Boxes className="h-4 w-4" />,
    component: NestedBoxesRenderer,
  },
  {
    type: 'grid-layout',
    label: 'مصفوفة',
    icon: <Grid className="h-4 w-4" />,
    component: GridLayoutRenderer,
  },
];
export const VisualizationSwitcher = memo(
  ({ nodes }: { nodes: SummaryNode[] }) => {
    const [visualizationType, setVisualizationType] =
      useState<VisualizationType>(VISUALIZATION_CONFIGS[0].type);
    const currentVisualization = useMemo(() => {
      const config = VISUALIZATION_CONFIGS.find(
        (cfg) => cfg.type === visualizationType
      );
      if (config) {
        const Component = config.component;
        return <Component nodes={nodes} />;
      }
      return null;
    }, [visualizationType, nodes]);
    return (
      <>
        <VisualizationTypeSelector
          visualizationType={visualizationType}
          onVisualizationChange={setVisualizationType}
          configs={VISUALIZATION_CONFIGS}
        />
        <div className="transition-opacity duration-300">
          {currentVisualization}
        </div>
      </>
    );
  }
);
VisualizationSwitcher.displayName = 'VisualizationSwitcher';
const VisualizationTypeSelector = memo(
  ({
    visualizationType,
    onVisualizationChange,
    configs,
  }: {
    visualizationType: VisualizationType;
    onVisualizationChange: (type: VisualizationType) => void;
    configs: VisualizationConfig[];
  }) => {
    return (
      <div className="flex flex-wrap gap-2">
        {configs.map((config) => (
          <button
            key={config.type}
            onClick={() => onVisualizationChange(config.type)}
            className={`flex cursor-pointer items-center gap-2 rounded-md px-3 py-1.5 text-sm transition-colors ${
              visualizationType === config.type
                ? 'bg-zinc-200 text-zinc-900 dark:bg-zinc-700 dark:text-zinc-100'
                : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-300 dark:hover:bg-zinc-700'
            }`}
            aria-label={`تغيير إلى ${config.label}`}
            title={`تغيير إلى ${config.label}`}
          >
            {config.icon}
            <span className="hidden sm:inline">{config.label}</span>
          </button>
        ))}
      </div>
    );
  }
);
VisualizationTypeSelector.displayName = 'VisualizationTypeSelector';

================
File: config/env.ts
================
export const isDev = process.env.NODE_ENV === 'development';

================
File: config/site.ts
================
export const SITE_URL = 'https://usearabic.com';

================
File: constants/arabic-to-english-map.ts
================
export const arabicToEnglishMap: Record<string, string> = {
  ا: 'a',
  ب: 'b',
  ت: 't',
  ث: 'th',
  ج: 'j',
  ح: 'h',
  خ: 'kh',
  د: 'd',
  ذ: 'dh',
  ر: 'r',
  ز: 'z',
  س: 's',
  ش: 'sh',
  ص: 's',
  ض: 'd',
  ط: 't',
  ظ: 'z',
  ع: 'a',
  غ: 'gh',
  ف: 'f',
  ق: 'q',
  ك: 'k',
  ل: 'l',
  م: 'm',
  ن: 'n',
  ه: 'h',
  و: 'w',
  ي: 'y',
  ء: '',
  ى: 'a',
  ئ: 'y',
  ؤ: 'w',
  ة: 'h',
  إ: 'i',
  أ: 'a',
  آ: 'aa',
  'ٓ': '',
  // numbers
  '٠': '0',
  '١': '1',
  '٢': '2',
  '٣': '3',
  '٤': '4',
  '٥': '5',
  '٦': '6',
  '٧': '7',
  '٨': '8',
  '٩': '9',
};

================
File: hooks/use-mobile.ts
================
import * as React from 'react';
const MOBILE_BREAKPOINT = 768;
export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined
  );
  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener('change', onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener('change', onChange);
  }, []);
  return !!isMobile;
}

================
File: hooks/use-sidebar.tsx
================
import type { SummaryNode } from '@/lib/content/types';
import { usePathname } from 'next/navigation';
import { useCallback, useMemo, useState } from 'react';
export function useSidebar(summaryTree: SummaryNode[]) {
  const pathname = usePathname();
  const [expandedSections, setExpandedSections] = useState<
    Record<string, boolean>
  >(() => ({}));
  const toggleSection = useCallback((path: string) => {
    setExpandedSections((prev) => ({
      ...prev,
      [path]: !prev[path],
    }));
  }, []);
  const isCurrentPage = useCallback(
    (fullPath: string) => {
      if (fullPath === '__home') return pathname === '/';
      return pathname === `/learn/${fullPath}/`;
    },
    [pathname]
  );
  const flatItems = useMemo(() => {
    const walk = (
      nodes: SummaryNode[],
      level = 0
    ): { node: SummaryNode; level: number }[] => {
      let result: { node: SummaryNode; level: number }[] = [];
      for (const node of nodes) {
        result.push({ node, level });
        result = result.concat(walk(node.children, level + 1));
      }
      return result;
    };
    return walk(summaryTree);
  }, [summaryTree]);
  const getAllPaths = useCallback((nodes: SummaryNode[]): string[] => {
    let paths: string[] = [];
    for (const node of nodes) {
      const fullPath = [...node.parentPath, node.slug].join('/');
      if (node.children.length > 0) {
        paths.push(fullPath);
        paths = paths.concat(getAllPaths(node.children));
      }
    }
    return paths;
  }, []);
  const expandAll = useCallback(() => {
    const all = getAllPaths(summaryTree);
    const expanded: Record<string, boolean> = {};
    all.forEach((p) => (expanded[p] = true));
    setExpandedSections(expanded);
  }, [summaryTree, getAllPaths]);
  const collapseAll = useCallback(() => {
    setExpandedSections({});
  }, []);
  const toggleAll = useCallback(() => {
    const allPaths = getAllPaths(summaryTree);
    const someExpanded = allPaths.some((path) => expandedSections[path]);
    if (someExpanded) collapseAll();
    else expandAll();
  }, [expandedSections, collapseAll, expandAll, getAllPaths, summaryTree]);
  return useMemo(
    () => ({
      flatItems,
      expandedSections,
      toggleSection,
      isCurrentPage,
      toggleAll,
    }),
    [flatItems, expandedSections, toggleSection, isCurrentPage, toggleAll]
  );
}

================
File: lib/content/core/content-loader.ts
================
import fs from 'fs/promises';
import matter from 'gray-matter';
import path from 'path';
import { remark } from 'remark';
import html from 'remark-html';
import { normalizeTitle } from '../utils/path-utils';
export interface PageSpecificContent {
  pageTitle: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml: string;
  frontmatter: Record<string, any>;
}
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
export async function loadPageSpecificContent(
  slugPath: string[]
): Promise<PageSpecificContent | null> {
  if (slugPath.length === 0) return null;
  const markdownFilePath = path.join(
    CONTENT_BASE_PATH,
    ...slugPath,
    'index.md'
  );
  try {
    const rawMarkdown = await fs.readFile(markdownFilePath, 'utf-8');
    const { data: frontmatter, content: markdownContent } = matter(rawMarkdown);
    const processedHtml = await remark().use(html).process(markdownContent);
    const currentDirSlug = slugPath.at(-1)!;
    const title = frontmatter.title ?? normalizeTitle(currentDirSlug);
    return {
      pageTitle: title,
      pageOrder: frontmatter.order,
      excerpt: frontmatter.excerpt,
      contentHtml: processedHtml.toString(),
      frontmatter,
    };
  } catch (error) {
    return null;
  }
}

================
File: lib/content/core/landing-page-loader.ts
================
import { buildSync } from "esbuild";
import fs from "fs/promises";
import Module from "module";
import path from "path";
import type {
  BookLandingConfigFunction,
  BookLandingPageConfig,
  SummaryNode,
} from "../types";
const CONTENT_BASE_PATH = path.join(process.cwd(), "content");
const LANDING_CONFIG_FILENAME = "landing.ts";
function executeJavaScriptModule(jsCode: string, filename: string): unknown {
  const mod = new Module(filename, module.parent);
  mod._compile(jsCode, filename);
  return mod.exports;
}
export async function loadBookLandingPageConfigForBuild(
  bookNodeSlugPath: string[],
  bookChapters: SummaryNode[],
): Promise<BookLandingPageConfig | null> {
  if (bookNodeSlugPath.length === 0) {
    return null;
  }
  const landingConfigPath = path.join(
    CONTENT_BASE_PATH,
    ...bookNodeSlugPath,
    LANDING_CONFIG_FILENAME,
  );
  try {
    const tsCode = await fs.readFile(landingConfigPath, "utf-8");
    const result = buildSync({
      stdin: {
        contents: tsCode,
        resolveDir: path.dirname(landingConfigPath),
        loader: "ts",
      },
      bundle: false,
      format: "cjs",
      write: false,
      tsconfig: path.join(process.cwd(), "tsconfig.json"),
    });
    if (result.outputFiles && result.outputFiles.length > 0) {
      const jsCode = result.outputFiles[0].text;
      const exportedModule = executeJavaScriptModule(
        jsCode,
        landingConfigPath,
      );
      const configFunction =
        typeof exportedModule === "function"
          ? (exportedModule as BookLandingConfigFunction)
          :
            typeof exportedModule?.default === "function"
            ?
              (exportedModule.default as BookLandingConfigFunction)
            : null;
      if (configFunction) {
        const config = configFunction(bookChapters);
        if (config && Array.isArray(config.sections)) {
          return JSON.parse(JSON.stringify(config)) as BookLandingPageConfig;
        }
        console.warn(
          `Landing config function at ${landingConfigPath} (after transpilation) did not return a valid config object.`,
        );
      } else {
        console.warn(
          `Default export in landing config ${landingConfigPath} (after transpilation) is not a function.`,
        );
      }
    } else {
      console.warn(
        `esbuild failed to produce output for ${landingConfigPath}. Errors: ${result.errors.join(", ")}. Warnings: ${result.warnings.join(", ")}`,
      );
    }
    return null;
  } catch (error) {
    const err = error as NodeJS.ErrnoException & { errors?: any[] };
    if (err.code === "ENOENT") {
    } else if (err.errors && Array.isArray(err.errors)) {
      console.warn(
        `Error transpiling ${landingConfigPath} with esbuild: ${err.errors.map((e: any) => e.text).join("\n")}`,
      );
    } else {
      console.warn(
        `Could not load or parse ${LANDING_CONFIG_FILENAME} for book at ${bookNodeSlugPath.join("/")}. Path: ${landingConfigPath}. Error: ${err.message}`,
      );
    }
    return null;
  }
}

================
File: lib/content/core/tree-builder.ts
================
import fs from 'fs';
import path from 'path';
import type { SummaryNode } from '../types';
import {
  normalizeSlug,
  normalizeTitle,
  parseDirectoryName,
} from '../utils/path-utils';
const CONTENT_BASE_PATH = path.join(process.cwd(), 'content');
let summaryTreeCache: SummaryNode[] | null = null;
function isPrefixMandatoryForDepth(depth: number): boolean {
  return depth >= 3;
}
async function scanContentDirectory(
  currentDirPath: string,
  parentSlugPath: string[] = [],
  currentDepth: number = 0
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(currentDirPath, {
    withFileTypes: true,
  });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith('.')) continue;
    const fullEntryPath = path.join(currentDirPath, entry.name);
    if (entry.isDirectory()) {
      const { order: dirOrder, name: unprefixedDirName } = parseDirectoryName({
        directoryName: entry.name,
        isDirectoryPrefixMandatory: isPrefixMandatoryForDepth(currentDepth),
      });
      const slug = normalizeSlug(unprefixedDirName);
      const title = normalizeTitle(unprefixedDirName);
      const children = await scanContentDirectory(
        fullEntryPath,
        [...parentSlugPath, slug],
        currentDepth + 1
      );
      items.push({
        title,
        slug,
        order: dirOrder,
        parentPath: parentSlugPath,
        children,
      });
    }
  }
  return items.sort((a, b) => {
    if (a.order !== b.order) {
      return a.order - b.order;
    }
    return a.title.localeCompare(b.title);
  });
}
export async function buildContentSummaryTree(): Promise<SummaryNode[]> {
  if (summaryTreeCache) return summaryTreeCache;
  summaryTreeCache = await scanContentDirectory(CONTENT_BASE_PATH);
  return summaryTreeCache;
}
export function clearSummaryTreeCache(): void {
  summaryTreeCache = null;
}

================
File: lib/content/query/find-node.ts
================
import type { SummaryNode } from '../types';
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[]
): SummaryNode | null {
  let currentNodes: SummaryNode[] = tree;
  let foundNode: SummaryNode | null = null;
  for (const slug of slugPath) {
    const nextNode = currentNodes.find((node) => node.slug === slug);
    if (!nextNode) return null;
    foundNode = nextNode;
    currentNodes = nextNode.children;
  }
  return foundNode;
}

================
File: lib/content/query/get-all-paths.ts
================
import { buildContentSummaryTree } from '../core/tree-builder';
import type { SummaryNode } from '../types';
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildContentSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, currentPath: string[] = []) {
    const newPath = [...currentPath, node.slug];
    slugs.push(newPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, newPath));
    }
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: lib/content/query/get-breadcrumbs.ts
================
import type { SummaryNode } from '../types';
import { findDeepestNode } from './find-node';
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[]
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  if (node.parentPath.length === 0) {
    return breadcrumbs;
  }
  let currentParentPath = node.parentPath;
  while (currentParentPath.length > 0) {
    const parentNode = findDeepestNode(tree, currentParentPath);
    if (parentNode) {
      breadcrumbs.unshift({ title: parentNode.title, slug: parentNode.slug });
    }
    currentParentPath = currentParentPath.slice(0, -1);
  }
  return breadcrumbs;
}

================
File: lib/content/query/get-leaf-nodes.ts
================
import type { LeafNodeInfo, SummaryNode } from '../types';
export function getLeafNodes(tree: SummaryNode[]): LeafNodeInfo[] {
  const leaves: LeafNodeInfo[] = [];
  function walk(node: SummaryNode, currentPath: string[] = []) {
    const fullPathSegments = [...currentPath, node.slug];
    if (node.children.length === 0) {
      leaves.push({
        title: node.title,
        fullSlugPath: fullPathSegments.join('/'),
      });
    } else {
      node.children.forEach((child) => walk(child, fullPathSegments));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: lib/content/query/get-node-path.ts
================
import type { SummaryNode } from '../types';
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join('/');
}

================
File: lib/content/utils/path-utils.ts
================
import { transliterate } from '../../text/transliteration';
export interface ParsedNameInfo {
  order: number;
  name: string;
  isPrefixed: boolean;
}
const DEFAULT_ORDER = 0;
export function parseDirectoryName({
  directoryName,
  isDirectoryPrefixMandatory,
}: {
  directoryName: string;
  isDirectoryPrefixMandatory: boolean;
}): ParsedNameInfo {
  if (/\.[a-z0-9]+$/i.test(directoryName)) {
    throw new Error(
      `Directory name "${directoryName}" must not contain a file extension.`
    );
  }
  const match = directoryName.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (match) {
    const [, numericPrefix, remainder] = match;
    const order = parseInt(
      transliterate({ input: numericPrefix, mode: 'arabic-to-latin' }),
      10
    );
    if (isNaN(order)) {
      throw new Error(
        `Invalid numeric prefix in directory name: "${directoryName}". Could not parse "${numericPrefix}" to a number.`
      );
    }
    return {
      order,
      name: remainder,
      isPrefixed: true,
    };
  }
  if (isDirectoryPrefixMandatory) {
    throw new Error(
      `Invalid directory name format: "${directoryName}". Expected format: <number>_<name> as prefix is mandatory at this level.`
    );
  }
  return {
    order: DEFAULT_ORDER,
    name: directoryName,
    isPrefixed: false,
  };
}
export function normalizeSlug(raw: string): string {
  const base = raw.replace(/\.md$/, '');
  const arabicOnly = base.replace(/[^\u0600-\u06FF_]/g, '');
  return transliterate({
    input: arabicOnly,
    mode: 'arabic-to-latin',
  }).replace(/_+/g, '-');
}
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, '');
  return arabicOnly.replace(/_+/g, ' ');
}

================
File: lib/content/utils/tree-utils.ts
================
import type { SummaryNode } from '../types';
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  currentPath: string[] = [],
  level: number = 0
): void {
  for (const node of nodes) {
    callback(node, currentPath, level);
    if (node.children && node.children.length > 0) {
      walkTree(node.children, callback, [...currentPath, node.slug], level + 1);
    }
  }
}
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: lib/content/api.ts
================
import { loadPageSpecificContent } from "./core/content-loader";
import { loadBookLandingPageConfig } from "./core/landing-page-loader";
import {
  buildContentSummaryTree,
  clearSummaryTreeCache as clearInternalSummaryTreeCache,
} from "./core/tree-builder";
import { findDeepestNode } from "./query/find-node";
import type { ContentNode, SummaryNode } from "./types";
export { getTreeSlugs as getAllContentPaths } from "./query/get-all-paths";
export { getBreadcrumbs } from "./query/get-breadcrumbs";
export { getLeafNodes } from "./query/get-leaf-nodes";
export { getNodeSlugPath } from "./query/get-node-path";
export { flattenTree, walkTree } from "./utils/tree-utils";
const BOOK_DEPTH = 2;
export async function getSummaryTree(): Promise<SummaryNode[]> {
  return buildContentSummaryTree();
}
export async function getContentNodeBySlugPath(
  slugPath: string[],
): Promise<ContentNode | null> {
  const tree = await getSummaryTree();
  const summaryNode = findDeepestNode(tree, slugPath);
  if (!summaryNode) {
    return null;
  }
  const pageContent = await loadPageSpecificContent(slugPath);
  const contentNode: ContentNode = {
    ...summaryNode,
  };
  if (pageContent) {
    contentNode.pageTitle = pageContent.pageTitle;
    contentNode.pageOrder = pageContent.pageOrder;
    contentNode.excerpt = pageContent.excerpt;
    contentNode.contentHtml = pageContent.contentHtml;
    contentNode.frontmatter = pageContent.frontmatter;
  }
  const nodeDepth = summaryNode.parentPath.length;
  if (nodeDepth === BOOK_DEPTH) {
    const landingConfig = await loadBookLandingPageConfig(
      slugPath,
      summaryNode.children,
    );
    if (landingConfig) {
      contentNode.landingPageConfig = landingConfig;
    }
  }
  return contentNode;
}
export function clearSummaryCache(): void {
  clearInternalSummaryTreeCache();
}

================
File: lib/content/types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type LeafNodeInfo = {
  title: string;
  fullSlugPath: string;
};
type BookLandingSectionBase = {
  title: string;
};
export type TextLandingSection = BookLandingSectionBase & {
  type: "text";
  content: string[];
};
export type VisualizationLandingSection = BookLandingSectionBase & {
  type: "visualization";
  nodes: SummaryNode[];
};
export type BookLandingSection =
  | TextLandingSection
  | VisualizationLandingSection;
export interface BookLandingPageConfig {
  sections: BookLandingSection[];
}
export type BookLandingConfigFunction = (
  bookChapters: SummaryNode[],
) => BookLandingPageConfig;
export type ContentNode = SummaryNode & {
  pageTitle?: string;
  pageOrder?: number;
  excerpt?: string;
  contentHtml?: string;
  frontmatter?: Record<string, any>;
  landingPageConfig?: BookLandingPageConfig;
};

================
File: lib/styles/tailwind-utils.ts
================
import clsx, { type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

================
File: lib/text/ascii-tree-generator.ts
================
import type { SummaryNode } from '../content/types';
export function generateASCIITree(
  docs: SummaryNode[],
  options: {
    indent?: string;
    splitLevel?: number;
    splitString?: string;
    currentLevel?: number;
  } = {}
): string {
  const {
    indent = '',
    splitLevel = Infinity,
    splitString = '',
    currentLevel = 0,
  } = options;
  return docs
    .map((node, index) => {
      const isLast = index === docs.length - 1;
      const branch = isLast ? '└── ' : '├── ';
      const nextIndent = indent + (isLast ? '    ' : '│   ');
      const label = node.title.replace(/_/g, ' ');
      let output = '';
      if (currentLevel === splitLevel && label !== splitString) {
        return '';
      }
      output += `${indent}${branch}${label}\n`;
      if (node.children.length > 0) {
        output += generateASCIITree(node.children, {
          indent: nextIndent,
          splitLevel,
          splitString,
          currentLevel: currentLevel + 1,
        });
      }
      return output;
    })
    .join('');
}

================
File: lib/text/transliteration.ts
================
type ArabicToLatinOptions = {
  mode: 'arabic-to-latin';
  input: string;
};
type LatinToArabicDigitsOptions = {
  mode: 'latin-to-arabic-digits';
  input: string;
};
type LatinNumbersToArabicDigitsOptions = {
  mode: 'latin-numbers-to-arabic-digits';
  input: string | number;
};
type LatinToArabicOptions = {
  mode: 'latin-to-arabic';
  input: string;
};
type Options =
  | ArabicToLatinOptions
  | LatinToArabicDigitsOptions
  | LatinNumbersToArabicDigitsOptions
  | LatinToArabicOptions;
const LATIN_TO_ARABIC_DIGITS: Record<string, string> = {
  '0': '٠',
  '1': '١',
  '2': '٢',
  '3': '٣',
  '4': '٤',
  '5': '٥',
  '6': '٦',
  '7': '٧',
  '8': '٨',
  '9': '٩',
};
const ARABIC_TO_LATIN_DIGITS: Record<string, string> = Object.fromEntries(
  Object.entries(LATIN_TO_ARABIC_DIGITS).map(([w, a]) => [a, w])
);
const digitSet = new Set(Object.keys(LATIN_TO_ARABIC_DIGITS));
const ARABIC_TO_LATIN_LETTERS: Record<string, string> = {
  ا: 'a',
  ب: 'b',
  ت: 't',
  ث: 'th',
  ج: 'j',
  ح: 'h',
  خ: 'kh',
  د: 'd',
  ذ: 'dh',
  ر: 'r',
  ز: 'z',
  س: 's',
  ش: 'sh',
  ص: 's',
  ض: 'd',
  ط: 't',
  ظ: 'z',
  ع: 'a',
  غ: 'gh',
  ف: 'f',
  ق: 'q',
  ك: 'k',
  ل: 'l',
  م: 'm',
  ن: 'n',
  ه: 'h',
  و: 'w',
  ي: 'y',
  ء: '',
  ى: 'a',
  ئ: 'y',
  ؤ: 'w',
  ة: 'h',
  إ: 'i',
  أ: 'a',
  آ: 'aa',
  'ٓ': '',
  'َ': 'a',
  'ُ': 'u',
  'ِ': 'i',
  'ّ': '',
  'ْ': '',
  'ً': 'an',
  'ٌ': 'un',
  'ٍ': 'in',
};
const ARABIC_TO_LATIN_MAP = {
  ...ARABIC_TO_LATIN_LETTERS,
  ...ARABIC_TO_LATIN_DIGITS,
};
const LATIN_TO_ARABIC_LETTERS: Record<string, string> = Object.fromEntries(
  Object.entries(ARABIC_TO_LATIN_LETTERS)
    .filter(([_arb, lat]) => lat.length > 0)
    .map(([arb, lat]) => [lat, arb])
);
const LATIN_LETTER_KEYS = Object.keys(LATIN_TO_ARABIC_LETTERS).sort(
  (a, b) => b.length - a.length
);
export function transliterate(options: Options): string {
  const { mode } = options;
  const inputStr = options.input.toString();
  switch (mode) {
    case 'arabic-to-latin':
      return [...inputStr].map((ch) => ARABIC_TO_LATIN_MAP[ch] ?? ch).join('');
    case 'latin-to-arabic-digits':
      return inputStr.replace(/[0-9]/g, (d) => LATIN_TO_ARABIC_DIGITS[d]);
    case 'latin-numbers-to-arabic-digits':
      if (!/^\d+$/.test(inputStr)) {
        throw new Error(
          "Mode 'latin-numbers-to-arabic-digits' requires digits only."
        );
      }
      return [...inputStr].map((d) => LATIN_TO_ARABIC_DIGITS[d]).join('');
    case 'latin-to-arabic':
      return transliterateLatinToArabic(inputStr);
    default:
      const _exhaustive: never = mode;
      throw new Error(`Unsupported mode: ${_exhaustive}`);
  }
}
function transliterateLatinToArabic(s: string): string {
  let result = '';
  let i = 0;
  const N = s.length;
  const lower = s.toLowerCase();
  while (i < N) {
    let matched = false;
    for (const key of LATIN_LETTER_KEYS) {
      if (lower.startsWith(key, i)) {
        result += LATIN_TO_ARABIC_LETTERS[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const ch = s[i];
    if (digitSet.has(ch)) {
      result += LATIN_TO_ARABIC_DIGITS[ch];
    } else {
      result += ch;
    }
    i++;
  }
  return result;
}

================
File: lib/output.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
content/
  core/
    build-summary-tree.ts
    get-content-node.ts
  query/
    find-node.ts
    get-all-paths.ts
    get-breadcrumbs.ts
    get-leaf-nodes.ts
    get-node-path.ts
  utils/
    normalize-slug.ts
    normalize-title.ts
    parse-filename-order.ts
    tree-flattener.ts
    tree-walker.ts
  types.ts
styles/
  tailwind.ts
text/
  ascii-generator.ts
  transliteration.ts

================================================================
Files
================================================================

================
File: content/core/build-summary-tree.ts
================
import fs from "fs";
import path from "path";
import type { SummaryNode } from "../types";
import { normalizeSlug } from "../utils/normalize-slug";
import { normalizeTitle } from "../utils/normalize-title";
import { parseFilenameOrder } from "../utils/parse-filename-order";
const MARKDOWN_BASE_PATH = path.join(process.cwd(), "content");
let _cache: SummaryNode[] | null = null;
async function walkDir(
  dir: string,
  parentPath: string[] = []
): Promise<SummaryNode[]> {
  const entries = await fs.promises.readdir(dir, { withFileTypes: true });
  const items: SummaryNode[] = [];
  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    const fullPath = path.join(dir, entry.name);
    const isMarkdownFile = entry.name.endsWith(".md");
    const filenameWithoutExtension = isMarkdownFile
      ? entry.name.replace(/\.md$/, "")
      : entry.name;
    const { fileOrder, rawUnprefixedFilename } = parseFilenameOrder({
      filename: filenameWithoutExtension,
    });
    if (entry.isDirectory()) {
      const children = await walkDir(fullPath, [
        ...parentPath,
        normalizeSlug(rawUnprefixedFilename),
      ]);
      items.push({
        title: normalizeTitle(rawUnprefixedFilename),
        slug: normalizeSlug(rawUnprefixedFilename),
        order: fileOrder,
        parentPath,
        children,
      });
    } else if (isMarkdownFile) {
      continue;
    }
  }
  return items.sort((a, b) => a.order - b.order);
}
export async function buildSummaryTree(): Promise<SummaryNode[]> {
  if (_cache) return _cache;
  _cache = await walkDir(MARKDOWN_BASE_PATH);
  return _cache;
}

================
File: content/core/get-content-node.ts
================
import fs from "fs/promises";
import matter from "gray-matter";
import path from "path";
import { remark } from "remark";
import html from "remark-html";
import type { ContentNode } from "../types";
import { normalizeSlug } from "../utils/normalize-slug";
import { normalizeTitle } from "../utils/normalize-title";
import { parseFilenameOrder } from "../utils/parse-filename-order";
const MARKDOWN_BASE_PATH = path.join(process.cwd(), "content");
export async function getContentNode(
  slugPath: string[]
): Promise<ContentNode | null> {
  if (slugPath.length === 0) return null;
  const normalizedSlugs = slugPath.map(normalizeSlug);
  const filename = `${normalizedSlugs.at(-1)}.md`;
  const filePath = path.join(
    MARKDOWN_BASE_PATH,
    ...normalizedSlugs.slice(0, -1),
    filename
  );
  try {
    const raw = await fs.readFile(filePath, "utf-8");
    const { data, content } = matter(raw);
    const processed = await remark().use(html).process(content);
    const slug = normalizedSlugs.at(-1)!;
    return {
      title: data.title ?? normalizeTitle(slug),
      slug,
      order: data.order ?? parseFilenameOrder({ filename: slug }).fileOrder,
      parentPath: normalizedSlugs.slice(0, -1),
      children: [],
      excerpt: data.excerpt,
      contentHtml: processed.toString(),
    };
  } catch (error) {
    return null;
  }
}

================
File: content/query/find-node.ts
================
import type { SummaryNode } from "../types";
export function findDeepestNode(
  tree: SummaryNode[],
  slugPath: string[]
): SummaryNode | null {
  let current: SummaryNode | undefined;
  for (const slug of slugPath) {
    current = (current?.children ?? tree).find((node) => node.slug === slug);
    if (!current) return null;
  }
  return current ?? null;
}

================
File: content/query/get-all-paths.ts
================
import { buildSummaryTree } from "../core/build-summary-tree";
import type { SummaryNode } from "../types";
export async function getTreeSlugs(): Promise<string[][]> {
  const tree = await buildSummaryTree();
  const slugs: string[][] = [];
  function traverse(node: SummaryNode, path: string[] = []) {
    const currentPath = [...path, node.slug];
    slugs.push(currentPath);
    node.children.forEach((child) => traverse(child, currentPath));
  }
  tree.forEach((node) => traverse(node));
  return slugs;
}

================
File: content/query/get-breadcrumbs.ts
================
import type { SummaryNode } from "../types";
import { findDeepestNode } from "./find-node";
export function getBreadcrumbs(
  node: SummaryNode,
  tree: SummaryNode[]
): { title: string; slug: string }[] {
  const breadcrumbs: { title: string; slug: string }[] = [];
  let current = findDeepestNode(tree, node.parentPath);
  while (current) {
    breadcrumbs.unshift({ title: current.title, slug: current.slug });
    current = findDeepestNode(tree, current.parentPath);
  }
  return breadcrumbs;
}

================
File: content/query/get-leaf-nodes.ts
================
import type { LeafNode, SummaryNode } from "../types";
export function getLeafNodes(tree: SummaryNode[]): LeafNode[] {
  const leaves: LeafNode[] = [];
  function walk(node: SummaryNode, path: string[] = []) {
    const fullPath = [...path, node.slug];
    if (node.children.length === 0) {
      leaves.push({ title: node.title, slug: fullPath.join("/") });
    } else {
      node.children.forEach((child) => walk(child, fullPath));
    }
  }
  tree.forEach((node) => walk(node));
  return leaves;
}

================
File: content/query/get-node-path.ts
================
import { SummaryNode } from "../types";
export function getNodeSlugPath(node: SummaryNode): string {
  return [...node.parentPath, node.slug].join("/");
}

================
File: content/utils/normalize-slug.ts
================
import { transliterate } from "@/lib/text/transliteration";
export function normalizeSlug(raw: string): string {
  const base = raw.replace(/\.md$/, "");
  const arabicOnly = base.replace(/[^\u0600-\u06FF_]/g, "");
  return transliterate({
    input: arabicOnly,
    mode: "arabic-to-latin",
  }).replace(/_+/g, "-");
}

================
File: content/utils/normalize-title.ts
================
export function normalizeTitle(raw: string): string {
  const arabicOnly = raw.replace(/[^\u0600-\u06FF_]/g, "");
  return arabicOnly.replace(/_+/g, " ");
}

================
File: content/utils/parse-filename-order.ts
================
import { transliterate } from "@/lib/text/transliteration";
export function parseFilenameOrder({ filename }: { filename: string }): {
  fileOrder: number;
  rawUnprefixedFilename: string;
} {
  if (/\.[a-z0-9]+$/i.test(filename)) {
    throw new Error(
      `Filename "${filename}" must not contain a file extension.`
    );
  }
  const match = filename.match(/^([٠-٩0-9]+)_+(.+)$/);
  if (!match) {
    throw new Error(
      `Invalid filename format: "${filename}". Expected format: <number>_<name>`
    );
  }
  const [, numericPrefix, remainder] = match;
  const fileOrder = parseInt(
    transliterate({ input: numericPrefix, mode: "arabic-to-latin" }),
    10
  );
  if (isNaN(fileOrder)) {
    throw new Error(
      `Invalid numeric prefix in filename: "${filename}". Could not parse "${numericPrefix}" to a number.`
    );
  }
  return {
    fileOrder,
    rawUnprefixedFilename: remainder,
  };
}

================
File: content/utils/tree-flattener.ts
================
import type { SummaryNode } from "../types";
import { walkTree } from "./tree-walker";
export function flattenTree(tree: SummaryNode[]): SummaryNode[] {
  const flattened: SummaryNode[] = [];
  walkTree(tree, (node) => flattened.push(node));
  return flattened;
}

================
File: content/utils/tree-walker.ts
================
export function walkTree<T extends { slug: string; children: T[] }>(
  nodes: T[],
  callback: (node: T, path: string[], level: number) => void,
  path: string[] = [],
  level: number = 0
): void {
  for (const node of nodes) {
    callback(node, path, level);
    if (node.children.length > 0) {
      walkTree(node.children, callback, [...path, node.slug], level + 1);
    }
  }
}

================
File: content/types.ts
================
type BaseNode = {
  title: string;
  slug: string;
};
type HierarchyMeta = {
  order: number;
  parentPath: string[];
};
export type SummaryNode = BaseNode &
  HierarchyMeta & {
    children: SummaryNode[];
  };
export type ContentNode = SummaryNode & {
  excerpt?: string;
  contentHtml: string;
};
export type LeafNode = BaseNode;

================
File: styles/tailwind.ts
================
import clsx, { type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

================
File: text/ascii-generator.ts
================
import type { SummaryNode } from "../content/types";
export function generateASCIITree(
  docs: SummaryNode[],
  options: {
    indent?: string;
    splitLevel?: number;
    splitString?: string;
    currentLevel?: number;
  } = {}
): string {
  const {
    indent = "",
    splitLevel = Infinity,
    splitString = "",
    currentLevel = 0,
  } = options;
  return docs
    .map((node, index) => {
      const isLast = index === docs.length - 1;
      const branch = isLast ? "└── " : "├── ";
      const nextIndent = indent + (isLast ? "    " : "│   ");
      const label = node.title.replace(/_/g, " ");
      let output = "";
      if (currentLevel === splitLevel && label !== splitString) {
        return "";
      }
      output += `${indent}${branch}${label}\n`;
      if (node.children.length > 0) {
        output += generateASCIITree(node.children, {
          indent: nextIndent,
          splitLevel,
          splitString,
          currentLevel: currentLevel + 1,
        });
      }
      return output;
    })
    .join("");
}

================
File: text/transliteration.ts
================
type ArabicToLatinOptions = {
  mode: "arabic-to-latin";
  input: string;
};
type LatinToArabicDigitsOptions = {
  mode: "latin-to-arabic-digits";
  input: string;
};
type LatinNumbersToArabicDigitsOptions = {
  mode: "latin-numbers-to-arabic-digits";
  input: string | number;
};
type LatinToArabicOptions = {
  mode: "latin-to-arabic";
  input: string;
};
type Options =
  | ArabicToLatinOptions
  | LatinToArabicDigitsOptions
  | LatinNumbersToArabicDigitsOptions
  | LatinToArabicOptions;
const LATIN_TO_ARABIC_DIGITS: Record<string, string> = {
  "0": "٠",
  "1": "١",
  "2": "٢",
  "3": "٣",
  "4": "٤",
  "5": "٥",
  "6": "٦",
  "7": "٧",
  "8": "٨",
  "9": "٩",
};
const ARABIC_TO_LATIN_DIGITS: Record<string, string> = Object.fromEntries(
  Object.entries(LATIN_TO_ARABIC_DIGITS).map(([w, a]) => [a, w])
);
const digitSet = new Set(Object.keys(LATIN_TO_ARABIC_DIGITS));
const ARABIC_TO_LATIN_LETTERS: Record<string, string> = {
  ا: "a",
  ب: "b",
  ت: "t",
  ث: "th",
  ج: "j",
  ح: "h",
  خ: "kh",
  د: "d",
  ذ: "dh",
  ر: "r",
  ز: "z",
  س: "s",
  ش: "sh",
  ص: "s",
  ض: "d",
  ط: "t",
  ظ: "z",
  ع: "a",
  غ: "gh",
  ف: "f",
  ق: "q",
  ك: "k",
  ل: "l",
  م: "m",
  ن: "n",
  ه: "h",
  و: "w",
  ي: "y",
  ء: "",
  ى: "a",
  ئ: "y",
  ؤ: "w",
  ة: "h",
  إ: "i",
  أ: "a",
  آ: "aa",
  "ٓ": "",
  "َ": "a",
  "ُ": "u",
  "ِ": "i",
  "ّ": "",
  "ْ": "",
  "ً": "an",
  "ٌ": "un",
  "ٍ": "in",
};
const ARABIC_TO_LATIN_MAP = {
  ...ARABIC_TO_LATIN_LETTERS,
  ...ARABIC_TO_LATIN_DIGITS,
};
const LATIN_TO_ARABIC_LETTERS: Record<string, string> = Object.fromEntries(
  Object.entries(ARABIC_TO_LATIN_LETTERS)
    .filter(([_arb, lat]) => lat.length > 0)
    .map(([arb, lat]) => [lat, arb])
);
const LATIN_LETTER_KEYS = Object.keys(LATIN_TO_ARABIC_LETTERS).sort(
  (a, b) => b.length - a.length
);
export function transliterate(options: Options): string {
  const { mode } = options;
  const inputStr = options.input.toString();
  switch (mode) {
    case "arabic-to-latin":
      return [...inputStr].map((ch) => ARABIC_TO_LATIN_MAP[ch] ?? ch).join("");
    case "latin-to-arabic-digits":
      return inputStr.replace(/[0-9]/g, (d) => LATIN_TO_ARABIC_DIGITS[d]);
    case "latin-numbers-to-arabic-digits":
      if (!/^\d+$/.test(inputStr)) {
        throw new Error(
          "Mode 'latin-numbers-to-arabic-digits' requires digits only."
        );
      }
      return [...inputStr].map((d) => LATIN_TO_ARABIC_DIGITS[d]).join("");
    case "latin-to-arabic":
      return transliterateLatinToArabic(inputStr);
    default:
      const _exhaustive: never = mode;
      throw new Error(`Unsupported mode: ${_exhaustive}`);
  }
}
function transliterateLatinToArabic(s: string): string {
  let result = "";
  let i = 0;
  const N = s.length;
  const lower = s.toLowerCase();
  while (i < N) {
    let matched = false;
    for (const key of LATIN_LETTER_KEYS) {
      if (lower.startsWith(key, i)) {
        result += LATIN_TO_ARABIC_LETTERS[key];
        i += key.length;
        matched = true;
        break;
      }
    }
    if (matched) continue;
    const ch = s[i];
    if (digitSet.has(ch)) {
      result += LATIN_TO_ARABIC_DIGITS[ch];
    } else {
      result += ch;
    }
    i++;
  }
  return result;
}



================================================================
End of Codebase
================================================================

================
File: providers/theme-provider.tsx
================
'use client';
import { ThemeProvider as NextThemesProvider } from 'next-themes';
import * as React from 'react';
export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps<typeof NextThemesProvider>) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}



================================================================
End of Codebase
================================================================
